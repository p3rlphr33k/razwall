#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2011-11-08"

from endian.firewall.engine import registerSubst
from endian.system.wtmp import Wtmp
from endian.system.nic import Nic

DEVICEPREFIX="L2TPDEVICE"
IPPREFIX="L2TPIP"
PPPDEVICE="l2tp"

class SubstL2tpDevice(object):
    """
    ... autoclass::: SubstL2tpDevice
        substitutes 'value', which is taken as a L2TPDEVICE:<username> string
        into the ppp interface name which the user actually uses.

        If the user is logged in multiple times, a '&' separated list of
        device names will be returned 
    """
    def __init__(self, logger=None, listSeparator="&"):
        """
        ... autofunction::: __init__
        instantiates substitutor with following possible options:

        :param logger: instance to logger, which allows to have debug output
        :type logger: logger instance

        :param listSeparator: defines list separator. if None, real list will
        be returned
        :type listSeparator: string
        """
        self.log = logger
        self.wtmp = None
        self._mapcache = {}
        self.pppdevice = PPPDEVICE
        self.listSeparator = listSeparator

    # XXX: make this better! in super class!
    def debug(self, msg, *args, **kw):
        if self.log:
            self.log.debug(msg, *args, **kw)

    def _lookupWtmpUser(self, user):
        if user == 'ALL':
            return [self.pppdevice + "+"]
        if user not in self._mapcache:
            if self.wtmp is None:
                self.wtmp = Wtmp()
            devices = filter(lambda x: (x['loggedIn'] and 
                                        x['user'].__eq__(user) and 
                                        x['source'].startswith(self.pppdevice)),
                             self.wtmp)
            devices = list(set(map(lambda x: x['source'], devices)))
            self._mapcache[user] = devices
        return self._mapcache[user]

    def process(self, value, rule=None, params=None):
        if not value.startswith(DEVICEPREFIX+":"):
            if self.listSeparator:
                return value
            else:
                return [value]
        username = value.split(':')[1]
        ret = self._lookupWtmpUser(username)
        if not ret:
            raise KeyError("User '%s' not logged in" % username)
        self.debug("Substituted L2TP user '%s' into '%s'",
                   username,
                   ret)
        if self.listSeparator:
            return self.listSeparator.join(ret)
        else:
            return ret


class SubstL2tpIp(object):
    """
    ... autoclass::: SubstL2tpRemoteIp
        substitutes 'value', which is taken as a L2TPIP:<username> string
        into the ip address assigned to the l2tp user.

        If the user is logged in multiple times, a '&' separated list of
        device names will be returned 
    """
    def __init__(self, logger=None, listSeparator="&"):
        """
        ... autofunction::: __init__
        instantiates substitutor with following possible options:

        :param logger: instance to logger, which allows to have debug output
        :type logger: logger instance

        :param listSeparator: defines list separator. if None, real list will
        be returned
        :type listSeparator: string
        """
        self.log = logger
        self.listSeparator = listSeparator
        self._devicegetter = SubstL2tpDevice(logger=logger,
                                             listSeparator=None)
        self.iff = None
        self._mapcache = {}

    # XXX: make this better! in super class!
    def debug(self, msg, *args, **kw):
        if self.log:
            self.log.debug(msg, *args, **kw)

    def _lookupDevice(self, device):
        if device not in self._mapcache:
            if self.iff is None:
                self.iff = Nic()
            if not self.iff[device]['isPPP']:
                return []
            self._mapcache[device] = [str(self.iff[device]['remoteIp'].address)]
        return self._mapcache[device]

    def process(self, value, rule=None, params=None):
        if not value.startswith(IPPREFIX+":"):
            if self.listSeparator:
                return value
            else:
                return [value]
        username = value.split(':')[1]
        devices = self._devicegetter.process(DEVICEPREFIX+":"+username)
        ret = []
        for i in devices:
            if i.endswith("+"):
                continue
            ret.extend(self._lookupDevice(i))
        if not ret:
            raise KeyError("User '%s' not logged in" % username)

        self.debug("Substituted L2TP user '%s' to '%s'",
                   username,
                   ret)
        if self.listSeparator:
            return self.listSeparator.join(ret)
        else:
            return ret
        


registerSubst(DEVICEPREFIX, SubstL2tpDevice())
registerSubst(IPPREFIX, SubstL2tpIp())

__all__ = [
    'SubstL2tpDevice',
    'SubstL2tpIp',
    ]

if __name__ == '__main__':
    a = SubstL2tpDevice()
    try:
        print a.process("L2TPDEVICE:blah")
    except KeyError:
        print "blah not logged in"
    try:
        print a.process("L2TPDEVICE:unkonwn")
    except KeyError:
        print "unknown not logged in"

    b = SubstL2tpIp()
    try:
        print b.process("L2TPIP:blah")
    except KeyError:
        print "blah not logged in"
    try:
        print b.process("L2TPIP:unkonwn")
    except KeyError:
        print "unknown not logged in"
