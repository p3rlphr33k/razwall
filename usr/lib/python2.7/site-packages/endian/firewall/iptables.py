#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import sys
import shlex
import fcntl
import subprocess

__author__ = "Andrea Boomi <a.bonomi@endian.com>"
__date__ = "2010-12-15"

__all__ = ['iptables',
           'match_iptables',
           'delete_iptables']

IPT_LOCKFILE = "/var/lock/iptables_py"
IPTABLES = "/usr/sbin/iptables"
EBTABLES = "/sbin/ebtables"
IPTABLES_SAVE = "/usr/sbin/iptables-save"

def iptables(commands_lines=None, script=None,
             no_lock=False, trace=False, logger=None, failOk=False):
    """
        Call 'iptables' (or 'ebtables', blocking if another instance is already running

        :param commands_lines: iptables/ebtables command or a list of iptables/ebtables commands
                               e.g.
                               iptables(["iptables -t mangle -N QOS" ,
                                         "iptables -t mangle -A POSTROUTING -j QOS"])
                               if command_line is None (and the script parameter is not present),
                               use sys.argv instead
        :type  commands_lines: string or a list of strings
        :param script:         Path of the iptables script to be executed
                               The script is a text file, each line of the script if an iptables/ebtables command
                               e.g.
                               iptable -t mangle -N QOS
                               iptables -t mangle -A POSTROUTING -j QOS
                               ebtables -t nat
                               ...
        :type  script:         string
        :param no_lock:        Make iptables call non-blocking (do not use lock file)
        :type  no_lock:        boolean
        :param trace:          If true, print all the iptables/ebtables command
        :type  trace:          boolean
        :param logger:         optional logger
        :type logger:          logger
        :param failOk:         If true, failing commands will not provocate any
                               error output or failure handling reguarding
                               iptables rule creation.
        :type failOk:          boolean

    """

    lock_file = None
    splitted_commands_lines = []

    def print_error_message(error_message, exc_info=False):
        if logger:
            logger.error(error_message)
        else:
            print error_message

    if commands_lines == None and script == None:
        # No commands, use sys.argv
        command_line = list(sys.argv)
        command_line[0] = IPTABLES
        splitted_commands_lines.append(command_line)

    else:
        if commands_lines and not isinstance(commands_lines, list):
            commands_lines = [str(commands_lines)] # Single command
        elif not isinstance(commands_lines, list):
            commands_lines = []

        if script != None:
            # Read iptables script
            try:
                f = open(script, 'r')
                try:
                    # Parse the file
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith('#'):
                            commands_lines.append(line)
                finally:
                    f.close()
            except Exception, ex:
                error_message = "Unable to read iptables script file %s: %s" % (script, str(ex))
                print_error_message(error_message, exc_info=True)
                return 1

        # Split the command lines
        for command_line in commands_lines:
            splitted_command_line = shlex.split(command_line)
            if splitted_command_line[0] == "iptables":
                splitted_command_line[0] = IPTABLES
            elif splitted_command_line[0] == "ebtables":
                splitted_command_line[0] = EBTABLES
            elif splitted_command_line[0] not in [IPTABLES, EBTABLES]:
                splitted_command_line = [IPTABLES] + splitted_command_line
            splitted_commands_lines.append(splitted_command_line)

    try:
        # Acquire the lock
        try:
            lock_file = open(IPT_LOCKFILE, 'w')
            fcntl.lockf(lock_file, fcntl.LOCK_EX)
        except IOError, ex:
            error_message = "Unable to acquire lockfile %s: %s" % (IPT_LOCKFILE, str(ex))
            print_error_message(error_message, exc_info=True)
            return 1

        # Exec iptables
        try:
            exit_code = 0
            for splitted_command_line in splitted_commands_lines:
                if trace:
                    msg = " ".join(splitted_command_line)
                    if logger:
                        logger.debug(msg)
                    else:
                        print msg
                popen = subprocess.Popen(splitted_command_line, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
                stdoutdata, stderrdata = popen.communicate()
                exit_code = popen.returncode
                # If the exit code is not 0, send the command output to the logger
                if exit_code != 0:
                    command_output = "Error executing '%s' (exit_code %s): " % (" ".join(splitted_command_line), exit_code)
                    if stdoutdata:
                        command_output = command_output + stdoutdata
                    if stderrdata:
                        command_output = command_output + stderrdata
                    if not failOk:
                        print_error_message(command_output)
            return exit_code
        except OSError, ex:
            error_message = "Error executing '%s': %s" % (" ".join(splitted_command_line), str(ex))
            print_error_message(error_message, exc_info=True)
            return 127

    finally:
        # Releases the lock
        if lock_file:
            fcntl.lockf(lock_file, fcntl.LOCK_UN)
            lock_file.close()

def match_iptables(table=None, chain=None, src=None, dst=None, sport=None, dport=None, proto=None, target=None):
    """
        Return a list of matching iptables rules

        :param table:   table
        :type table:    string
        :param chain:   chain
        :type chain:    string
        :param src:     source address
        :type src:      string
        :param dst:     destination address
        :type dst:      string
        :param sport:   source port
        :type sport:    string or number
        :param dport:   destination port
        :type dport:    string or number
        :param proto:   protocol
        :type proto:    string
        :param target:  target chain
        :type target:   string

        :returns: the list of matching rules
        :rtype: list of strings
    """
    result = []
    args = [IPTABLES_SAVE]
    if table:
        args = args + [ '-t', table ]
    popen = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
    stdoutdata, stderrdata = popen.communicate()
    current_table = table
    for line in stdoutdata.split('\n'):
        if not line or line[0] == '#' or line[0] == ':':
            continue
        if line[0] == '*':
            current_table = line[1:]
            continue
        if table and current_table != table:
            continue
        splitted_line = line.split()
        if chain and splitted_line[0] == '-A' and splitted_line[1] != chain:
            continue
        r = {}
        key = None
        for i in splitted_line:
            if key:
                r[key] = i
                key = None
            elif i == '-s':
                key = 'src'
            elif i == '-d':
                key = 'dst'
            elif i == '--sport':
                key = 'sport'
            elif i == '--dport':
                key = 'dport'
            elif i == '-p':
                key = 'proto'
            elif i == '-j':
                key = 'target'
            else:
                key = None
        if src and r.get('src') != src:
            continue
        if dst and r.get('dst') != dst:
            continue
        if sport and r.get('sport') != str(sport):
            continue
        if dport and r.get('dport') != str(dport):
            continue
        if proto and r.get('proto') != proto:
            continue
        if target and r.get('target') != target:
            continue
        result.append(line)
    return result

def delete_iptables(table, chain=None, src=None, dst=None, sport=None, dport=None, proto=None, target=None, logger=None):
    """
        Remove all the matching iptables rules

        :param table:   table
        :type table:    string
        :param chain:   chain
        :type chain:    string
        :param src:     source address
        :type src:      string
        :param dst:     destination address
        :type dst:      string
        :param sport:   source port
        :type sport:    string or number
        :param dport:   destination port
        :type dport:    string or number
        :param proto:   protocol
        :type proto:    string
        :param target:  target chain
        :type target:   string
        :param logger:  optional logger
        :type logger:   logger

        :returns: the list of matching rules
        :rtype: list of strings
    """

    lock_file = None
    try:
        # Acquire the lock
        lock_file = open(IPT_LOCKFILE, 'w')
        fcntl.lockf(lock_file, fcntl.LOCK_EX)

        result = match_iptables(table=table, chain=chain, src=src, dst=dst, sport=sport, dport=dport, proto=proto, target=target)
        for line in result:
            splitted_command_line = [ IPTABLES, '-t', table, '-D' ] + line.split()[1:]
            popen = subprocess.Popen(splitted_command_line, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=False)
            stdoutdata, stderrdata = popen.communicate()
            exit_code = popen.returncode
            if logger is not None and exit_code != 0:
                logger.error(stderrdata)
        return result

    finally:
        # Releases the lock
        if lock_file:
            fcntl.lockf(lock_file, fcntl.LOCK_UN)
            lock_file.close()

if __name__ == '__main__':
    if len(sys.argv) == 3 and sys.argv[1] == '--script':
        exit_code = iptables(script=sys.argv[2])
    else:
        exit_code = iptables()
    sys.exit(exit_code)
