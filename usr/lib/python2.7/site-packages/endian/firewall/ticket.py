#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#
#  ticket
#
#  Created by Peter Warasin on 2008-12-18
#

import fcntl
import pickle
import os

STORAGE='.'

def loadRegistry(id='ticket'):
    """
    Returns a TicketRegistry object
    """
    return TicketRegistry(os.path.join(STORAGE, id))

class TicketRegistry:
    """
    Gives the possibility to register/unregister unique tickets for
    specified items.

    The implementation is thread safe.
    """
    def __init__(self, id, startid=0):
        self.filename = id
        self._fd = None
        self.startId = startid

    def acquire(self):
        """
        Locks the pickle and reads out the data.
        """
        self.data = None
        self._fd = None
	if os.path.exists(self.filename):
            self._fd = open(self.filename, 'r+b')
        else:
            self._fd = open(self.filename, 'w+b')

        fcntl.flock(self._fd.fileno(), fcntl.LOCK_EX)

        self.dirty = True
        try:
            self.data = pickle.load(self._fd)
            self.dirty = False
        except EOFError:
            self._init()

    def release(self):
        """
        Writes down the pickle and unlocks it
        """
        if self._fd == None:
            return
        try:
            if self.dirty:
                self._fd.seek(0,0)
                pickle.dump(self.data, self._fd, -1)
                self._fd.flush()
                self.dirty = False
        finally:
            self._fd.close()
            self._fd = None

    def _init(self):
        """
        Initializes the pickle data structure
        """
        self.data = {}

        """ pointer to the last free id. Starting from here the next free id can be searched"""
        self.data['lastId'] = self.startId

        """Stores assignement of id to realm/value pair"""
        self.data['ids'] = {}

        """Stores the assignement from value to id within a subtree for each realm"""
        self.data['values'] = {}

        """
        Stores the several realms to which the other data structures can point to.
        If a realm is empty it has been removed.
        """
        self.data['realms'] = {'free' : {'name': 'free', 'isEmpty': True}}

        """ If dirty, the pickle needs to be written."""
        self.dirty = True

    def _getRealm(self, realm):
        """
        Gets the specified realm if it is already registered,
        or register it otherwise
        """
        if not self.data['realms'].has_key(realm):
            self.data['realms'][realm] = {'name': realm, 'isEmpty': False}
            self.data['values'][realm] = {}
            self.dirty = True
        return self.data['realms'][realm]

    def _removeRealm(self, realm):
        """
        Removes the specified realm if it does exist
        """
        try:
            r = self.data['realms'][realm]
        except:
            return
        r['isEmpty'] = True
        r['name'] = 'free'
        del self.data['realms'][realm]
        del self.data['values'][realm]
        self.data['lastId'] = self.startId
        self.dirty = True

    def _getNextFree(self):
        """Searches for the next free id"""
        i = self.data['lastId']
        ids = self.data['ids']
        while True:
            if not ids.has_key(i):
                return i
            if ids[i]['realm']['isEmpty']:
                return i
            i += 1

    def _createAssignement(self, value, realm):
        """
        Creates a new id value/realm assignement
        """
        id = self._getNextFree()
        item = {}
        item['value'] = value
        item['realm'] = self._getRealm(realm)
        self.data['ids'][id] = item
        self.data['values'][realm][value] = id
        self.data['lastId'] = id
        self.dirty = True
        return id

    def getItemIdByValue(self, value, realm=0):
        """Returns the id by value of a registration within a specified realm"""
        return self.data['values'][realm][value]

    def _removeAssignement(self, value, realm):
        """
        Removes an assignement from the data structures
        """
        id = self.data['values'][realm][value]
        del self.data['values'][realm][value]
        del self.data['ids'][id]
        if id < self.data['lastId']:
            self.data['lastId'] = id
        self.dirty = True

    def register(self, item, realm=0):
        """
        Registers a unique id for the specified item within the specified
        realm. If the realm is omitted the default realm '0' will be used.

        If an item has already been registered within the specified realm
        the registered id will be returned.
        """
        ret = -1
        self.acquire()
        try:
            try:
                ret = self.getItemIdByValue(item, realm)
            except KeyError:
                ret = self._createAssignement(item, realm)
        finally:
            self.release()
        return ret

    def unregister(self, item, realm=0):
        """
        Unregisters the specified item within the specified realm. If the realm
        is omitted, the default realm '0' will be used.

        If the item is not registered, an KeyError will be thrown.
        """
        self.acquire()
        try:
            try:
                self._removeAssignement(item, realm)
            except:
                raise KeyError("Item '%s' is not registered within realm '%s'."%(item, realm))
        finally:
            self.release()

    def unregisterAll(self, realm=0):
        """
        Unregisters the each item of the specified realm. If the realm
        is omitted, the default realm '0' will be used.

        If there is no item registered, KeyError will be thrown.
        """
        self.acquire()
        try:
            try:
                self._removeRealm(realm)
            except:
                raise KeyError("There are no items registered within realm '%s'."%realm)
        finally:
            self.release()

    def iterValues(self, realm=0):
        """
        Returns an iterator over all values of the specified realm.
        """
        try:
            return self.data['values'][realm].iterkeys()
        except:
            return {}.iterkeys()

