#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#
#  rtable
#
#  Created by Peter Warasin on 2007-02-17

"""
iproute2 routing tables interface
"""

import fcntl
from subprocess import Popen
from subprocess import PIPE
import re
import logging
import types
import warnings
from endian.firewall.ticket import TicketRegistry

IPROUTE2_RTTABLES='/etc/iproute2/rt_tables'
ROUTINGMASK = '0x7F8'
ROUTING_SHIFT_BITS = 3
START_TABLE=256
END_TABLE=START_TABLE+256 # 256 == 8bit of mark bitrange reserved for routing
IPROUTE2_ROUTE='ip route'
REGISTRY = "/var/lib/ticketregistry/routingtable"

from os import path

class RT_TableNames:
    """
    This class represents the iproute2 table names and helps to manage them
    """

    _registry_cache = None

    def __init__(self, filename=IPROUTE2_RTTABLES):
        self.data = {}
        self.datavalues = {}
        self.filename=filename
        self.fd = None

    def _add_data(self, key, value):
        self.data[key] = value
        self.datavalues[value] = key

    def load(self, locking=False):
        """
        Loads the current rt_table and maps the content into a dictionary
        If 'locking' is true, the file keep locked unless it will be store()d
        """
        self.data = {}
        self.datavalues = {}
        file = None
	if path.exists(self.filename):
            file = open(self.filename, "r+")
        else:
            file = open(self.filename, "w+")
        if locking:
            self.fd = file
            fcntl.flock(file, fcntl.LOCK_EX)
        for line in file:
            line = line.strip()
            if line == "":
                continue
            if line.startswith("#"):
                continue
            (number, name) = line.split()
            number = number.strip()
            name = name.strip()
            self._add_data(int(number), name)
        if not locking:
            file.close()
        self.loaddefaults()

    def loaddefaults(self):
        self._add_data(255, 'local')
        self._add_data(254, 'main')
        self._add_data(253, 'default')

    def _sync_data(self):
        # leave tables < START_TABLE alone and let them exist self.data
        # which represents current rt_table file
        self.data = dict(filter(lambda x: x[0]<START_TABLE, self.data.items()))
        self.datavalues = dict(filter(lambda x: x[0]<START_TABLE, self.datavalues.items()))

        # add every registry entry to self.data
        obj = self._getRegistry()
        for value in obj.iterValues():
            key = obj.getItemIdByValue(value)
            self._add_data(key, value)

    def store(self):
        """
        Stores the actual content of the dictionary back to the rt_table file
        """
        file = None
        if self.fd:
            file = self.fd
            file.seek(0)
            file.truncate()
        else:
            file = open(self.filename, "w+")
        file.write("""
# File generated by RT_Tables class (Endian Firewall)
#
""")
        self._sync_data()

        for number in sorted(self.data, reverse=True):
            file.write("%s    %s\n"%(str(number), self.data[number]))
        file.close()
        self.fd = None

    def _getRegistry(self):
        if self._registry_cache == None:
            obj = TicketRegistry(REGISTRY, startid=START_TABLE)
            obj.acquire()
            obj.release()
            self._registry_cache = obj
        return self._registry_cache

    def sync(self):
        """
        Synchronizes ticket registry with iproute rt_table file
        """
        self.load(True)
        self.store()

    def getTable(self, name):
        """
        Returns table number to name mapping for table 'name'.
        If no mapping is registered yet it will be registered.
        """
        if not self.data:
            self.load()
        if name not in self.datavalues:
            obj = self._getRegistry()
            tablenr = obj.register(name)
            self._add_data(tablenr, name)
            self.sync()
        return (name, self.datavalues[name])

    def getNextFreeTable(self, name):
        warnings.warn("endian.core.firewall.rtable.RT_TableNames.getNextFreeTable(): Deprecated! Use getTable() instad")
        (name, tablenr) = self.getTable(name)
        return tablenr

    def getTablebyName(self, name):
        """
        Gets the table number by its name
        Throws an error if the name does not exist.
        """
        obj = self._getRegistry()
        try:
            return obj.getItemIdByValue(name)
        except KeyError:
            raise KeyError("Table name '%s' is not in the map."%name)

    def removeTable(self, name):
        """
        Removes the table(s) 'name' from rt_table file in a thread safe manner.
        If the table name does not exist an exception will be thrown.
        """
        obj = self._getRegistry()
        items = name
        if isinstance(name, types.StringType):
             items = [name]
        for i in items:
            obj.unregister(i)
        self.sync()

    def iterateTables(self, internal=True):
        if not self.data:
            self.load()
        for i in self.data:
            if not internal and i < START_TABLE:
                continue
            yield((i, self.data[i]))

class TableData:
    """
    Contains the data of a routing table
    """
    def __init__(self, name, cmd=IPROUTE2_ROUTE, log=None):
        self.name = name
        self.cmd = "%s show table %s"%(cmd, name)
        self._defaultgw = None
        self._data = {}
        self.log = log
        if self.log == None:
            self.log = logging.getLogger('TableData')
            self.log.setLevel(logging.CRITICAL)

    def getdefaultgw(self):
        if self._defaultgw == None:
            self.load()
        return self._defaultgw

    def getdata(self):
        if len(self._data) == 0:
            self.load()
        return self._data

    defaultgw = property(getdefaultgw)
    data = property(getdata)
    def load(self):
        """
        Loads table data from the systems routing table
        """
        self._defaultgw = None
        self._data = {}
        self.log.info("Load routing table '%s' with command '%s'."%(self.name, self.cmd))
        rx = re.compile("^(\S+)\s+(?:via\s+(\S+)\s*)?")
        p = None
        try:
            p = Popen(self.cmd, shell=True, stdout=PIPE, close_fds=True)
        except OSError, (errno, errstr):
            self.log.error("Could not start command '%s'."%(self.cmd))
            return
        out = p.stdout
        for line in out:
            match = rx.search(line)
            if not match:
                continue
            net, gw = match.groups()
            self._data[net] = gw
            self.log.debug("Got net '%s' gateway '%s' for table '%s'."%(net, gw, self.name))
            if net == 'default':
                self._defaultgw = gw
                self.log.debug("Got default gateway '%s' for table '%s'."%(gw, self.name))
        p.wait()

class RoutingTables:
    """
    This class represents the iproute2 routing tables and allows actions on it
    """
    def __init__(self, rt, cmd=IPROUTE2_ROUTE, log=None):
        self.data = {}
        self.cmd=cmd
        self.rt=rt
        self.log = log
        self.log = log
        if self.log == None:
            self.log = logging.getLogger('TableData')
            self.log.setLevel(logging.CRITICAL)

    def load(self):
        """
        Loads routing table data from system
        """
        self.data = {}
        for num, table in self.rt.data.iteritems():
            self.data[table] = TableData(table, self.cmd, self.log)

    def getTableByDefaultGw(self, gw):
        """
        Returns the name of the table which contains a specific default gw
        """
        for name, data in self.data.iteritems():
            if data.defaultgw != gw:
                continue
            return name
        return None
