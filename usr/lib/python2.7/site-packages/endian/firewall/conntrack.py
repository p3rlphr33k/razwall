#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from endian.datatypes.network import CIDR
import subprocess

__author__ = "Andrea Boomi <a.bonomi@endian.com>"
__date__ = "2012-10-09"

__all__ = ['list_conntrack',
           'match_conntrack',
           'delete_conntrack',
          ]

def list_conntrack():
    """
        List open connections
    """
    result = []
    f = open('/proc/net/ip_conntrack')
    try:
        for line in f:
            item = {}
            for i, s in enumerate(line.split()):
                if i == 0:
                    item['proto'] = s
                    continue
                s = s.split('=')
                if len(s) == 2 and s[0] not in item:
                    item[s[0]] = s[1]
            result.append(item)
    finally:
        if f:
            f.close()
    return result

def match_conntrack(src=None, dst=None, sport=None, dport=None, proto=None):
    """
        Return the connections matching the source, destination,
        source port, destination port and protocol.
        Source and destination can be IP address or CIDR
    """
    result = []
    if src and not isinstance(src, CIDR):
        if '/' in src:
            src = CIDR(src)
        else:
            src = CIDR("%s/32" % src)
    if dst and not isinstance(dst, CIDR):
        if '/' in dst:
            dst = CIDR(dst)
        else:
            dst = CIDR("%s/32" % dst)
    if sport != None:
        sport = str(sport)
    if dport != None:
        dport = str(dport)
    for item in list_conntrack():
        item_src = item.get("src")
        item_dst = item.get("dst")
        if not item_src or not item_dst:
            continue
        if src and not (item_src in src or item_src == src.netaddress):
            continue
        if dst and not (item_dst in dst or item_dst == dst.netaddress):
            continue
        if sport and sport != item.get("sport"):
            continue
        if dport and dport != item.get("dport"):
            continue
        if proto and proto != item.get("proto"):
            continue
        result.append(item)
    return result

def delete_conntrack(src=None, dst=None, sport=None, dport=None, proto=None):
    """
        Delete (close) the connections matching the source, destination,
        source port, destination port and protocol.
        Source and destination can be IP address or CIDR
    """
    result = match_conntrack(src, dst, sport, dport, proto)
    for item in result:
        subprocess.call(["conntrack", "-D", "--src", item.get("src"), "--dst", item.get("dst")])
    return result

