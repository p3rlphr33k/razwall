#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+


"""
util.

Contains some utility functions for the dashboard module.
"""

import os
import math
import subprocess
import time
import datetime
import socket
import re
from itertools import groupby
try:
    import elementtree.ElementTree as ElementTree
except ImportError:
    import xml.etree.ElementTree as ElementTree
from configobj import ConfigObj
from endian.core.i18n import _
from endian.data.ds import DataSource
from endian.core.monit import Monit
from endian.core import version
from endian.core import logger
from endian.data.container.settings import SettingsFile

try:
    from endian.core.redirect.enterprise import ValidityChecker
except ImportError:
    ValidityChecker = None
try:
    from uplinksdaemon.uplinks import UplinksPool
except ImportError:
    UplinksPool = None
try:
    from endian.collectd.status import getCollectdSingleValues
except ImportError:
    def getCollectdSingleValues(*args, **kargs):  # dummy version
        return {}


__all__ = [
    'getCPUCount',
    'getCPUUsage',
    'getCPUStat',
    'getDeactivation',
    'getHostName',
    'getNetworkInformation',
    'getServiceInformation',
    'getStorageInformation',
    'getHardwareInformation',
    'getSysID',
    'getTrades',
    'getUpDates',
    'getRegistration',
    'getUpTime',
]


SIGNATURES_TIMESTAMPS = '/var/efw/download/timestamps'
CLAMAV_INFO = '/var/signatures/clamav/info'

RRD_DIR = '/var/lib/collectd/rrd'
TMP_RRD_DIR = '/tmp/collectd/rrd'

UUID_FILE = '/etc/uuid'
UNITS = ['B', 'K', 'M', 'G', 'T']

EFW_NOT_REGISTERED = 0


def human_readable_size(val):
    """Convert a file size in an human readable string.."""
    if val == 0:
        return "0"

    frac = 0
    u = 0

    while val >= 1024 or u == len(UNITS):
        u = u + 1
        frac = ((val % 1024) * 10 + 1024 / 2) / 1024
        val /= 1024

    if frac >= 10:
        val = val + 1
        frac = 0

    if frac == 0:
        return "%d%s" % (val, UNITS[u])
    else:
        return "%d.%d%s" % (val, frac, UNITS[u])


def getHostName():
    """
    Returns the hostname of the system.

    :return: The hostname of the system.
    :rtype: String
    """
    try:
        return socket.gethostname()
    except Exception:
        return ""


def getDeactivation():
    """
    Returns a string, when the system will be deactivated.
    If this is no problem it returns False.

    :return: The time until the deactivation or False
    :rtype: False or a String
    """
    deactivationtime = None

    if not version.is_community():
        try:
            vc = ValidityChecker()
            tmpdeact = vc.timeUntilDeactivation()
            if tmpdeact is None:
                pass
            elif tmpdeact >= 30 * 24 * 60 * 60:
                pass
            elif tmpdeact >= 24 * 60 * 60:
                deactivationtime = unicode(_("%d days") % (tmpdeact / (24 * 60 * 60)))
            elif tmpdeact >= 60 * 60:
                deactivationtime = unicode(_("%d hours") % (tmpdeact / (60 * 60)))
            elif tmpdeact < 60 * 60:
                deactivationtime = unicode(_("%d hours") % 0)
        except:
            pass

    if deactivationtime is not None:
        return unicode(_("Time left to register before system lock: %s") % deactivationtime)
    else:
        return False


def getUpTime():
    """
    Returns the uptime of the system.

    :return: UpTime of the system.
    :rtype: String
    """
    try:
        try:
            f = open("/proc/uptime")
            uptime = long(f.read().strip().split(' ')[0].split('.')[0])
        finally:
            f.close()
        days, remainder = divmod(uptime, 86400)
        hours, remainder = divmod(remainder, 3600)
        minutes, seconds = divmod(remainder, 60)
        if days:
            return "%dd %dh %dm" % (days, hours, minutes)
        elif hours:
            return "%dh %dm" % (hours, minutes)
        else:
            return "%dm" % minutes
    except:
        return ""


def getSysID():
    """
    Returns the system identfication.

    :return: System identfication.
    :rtype: String
    """
    ds = DataSource('en').settings
    return ds.get('sysid')


def getUpDates():
    """
    Returns the up to date status of the system.

    :return: Up to date status of the system.
    :rtype: Int:
      0: Up to date.
      1: Register for communtiy.
      2: Register for enterprise.
      3: Update required.
    """
    updates = 0
    if version.is_community():
        updates = 1
    elif not getSysID():
        updates = 2
    try:
        f = open('/var/cache/en/update_list', 'r')
        for line in f:
            if line.strip() != "":
                updates = 3
                break
        f.close()
    except Exception:
        pass
    return updates


def getRegistration():
    if not version.is_community():
        return EFW_NOT_REGISTERED
    ds = DataSource('main').settings
    return ds.get('COMMUNITY_USERNAME', EFW_NOT_REGISTERED)


def getTrades():
    """
    Returns the trades status.

    :return: trades status.
    :rtype: Tuple of statuses
      x == 0: Not registered.
      x == 1: Not yet.
      x == 2: Expired.
      x == 3: More then 31 days left.
      x == 4: Less then 31 days left.
    """
    en_base = None
    en_sophos = None
    en_commtouch = None
    now = time.time()
    # Check if the system is registered.
    info_file = '/var/cache/en-%s' % getSysID()
    if os.path.exists(info_file):
        en_info = ConfigObj(info_file)
        for key in en_info.keys():
            if key.endswith("-base") or key == 'base' or key.endswith("-early-adopter"):
                en_base = en_info.get(key)
            elif key == "sophos-antivirus":
                en_sophos = en_info.get(key)
            elif key == "commtouch":
                en_commtouch = en_info.get(key)
    if not en_base:
        maintenance = 0
        maintenance_days_left = -1
    else:
        subscribed = int(en_base.get('subscribed-timestamp'))
        expiration = int(en_base.get('expiration-timestamp'))

        maintenance_days_left = math.ceil((expiration - now) / 86400)
        if expiration < now:
            maintenance = 2
        else:
            if maintenance_days_left <= 31:
                maintenance = 4
            else:
                maintenance = 3
    if not en_sophos:
        sophos = None
        sophos_days_left = -1
    else:
        subscribed = int(en_sophos.get('subscribed-timestamp'))
        expiration = int(en_sophos.get('expiration-timestamp'))

        sophos_days_left = math.ceil((expiration - now) / 86400)
        if subscribed > now:
            sophos = 1
        elif expiration < now:
            sophos = 2
        else:
            if sophos_days_left <= 31:
                sophos = 4
            else:
                sophos = 3
    if not en_commtouch:
        commtouch = None
        commtouch_days_left = -1
    else:
        subscribed = int(en_commtouch.get('subscribed-timestamp'))
        expiration = int(en_commtouch.get('expiration-timestamp'))

        commtouch_days_left = math.ceil((expiration - now) / 86400)
        if subscribed > now:
            commtouch = 1
        elif expiration < now:
            commtouch = 2
        else:
            if commtouch_days_left <= 31:
                commtouch = 4
            else:
                commtouch = 3

    ds = DataSource('support').settings
    if ds.get('ENABLED', '') == "on":
        try:
            timestamp = float(ds.get('VALID_UNTIL', None))
            enabled = "%s %s" % (unicode(_("until")), datetime.datetime.fromtimestamp(timestamp).strftime("%Y.%m.%d %H:%M"))
        except:
            enabled = unicode(_("enabled"))
        support = enabled
    else:
        support = False

    return (maintenance, maintenance_days_left,
            sophos, sophos_days_left,
            commtouch, commtouch_days_left,
            support)


def getRRDInformation(file_name, step, start, end):
    """
    Returns the rrd information of the file.
    Needs /usr/bin/rrdtool

    :param file_name: The file with the information.
    :type file_name: String
    :param step: --step parameter for rrdtool.
    :type step: String
    :param start: -s parameter for rrdtool.
    :type start: String
    :param end: -e parameter for rrdtool.
    :type end: String
    :return: The rrd information.
    :rtype: List
    """
    uuid = ''
    original_file_name = file_name
    if not file_name.startswith('/'):
        try:
            f = open(UUID_FILE, 'r')
            uuid = f.read().strip()
            f.close()
        except Exception, e:
            logger.debug('unable to read UUID file: %s', e)
        if not uuid:
            from socket import gethostname
            uuid = gethostname()
        file_name = '%s/%s/%s' % (TMP_RRD_DIR, uuid, original_file_name)
        if not os.path.isfile(file_name):
            file_name = '%s/%s/%s' % (RRD_DIR, uuid, original_file_name)
    if not os.path.exists(file_name):
        logger.debug('getRRDInformation: unable to read file %s', file_name)
        return 0
    cmd = ['/usr/bin/rrdtool', 'xport',
           '--step', step, '-e', end, '-s', start,
           'DEF:conn_avg=%s:value:AVERAGE' % file_name,
           'CDEF:mytime=conn_avg,TIME,TIME,IF',
           'CDEF:sample_len_raw=mytime,PREV(mytime),-',
           'CDEF:sample_len=sample_len_raw,UN,0,sample_len_raw,IF',
           'CDEF:conn_avg_sample=conn_avg,UN,0,conn_avg,IF,sample_len,*',
           'CDEF:conn_avg_sum=PREV,UN,0,PREV,IF,conn_avg_sample,+',
           'XPORT:conn_avg_sum:total']
    output = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0].strip()
    value = 0
    try:
        tree = ElementTree.fromstring(output)
        row = tree.find('data').findall('row')[-1]
        value = int(float(row.find('v').text))
    except Exception, e:
        logger.debug('getRRDInformation: unable to read rrd data: %s', e)
        return 0
    return value


def getServiceInformation():
    """
    Returns the informations about the services on the firewall.

    :return: Informations about the services.
    :rtype: List
    """
    m = Monit()
    returnlist = []
    presorteddict = {}

    postfix_static = {
        'queue': {
            'COUNT': 0,
            'DESC': unicode(_('mails in queue')),
            'ID': 'queue'
        }
    }

    postfix_dyn = {
        'incoming': {
            'COUNT': [
                getRRDInformation('tail-smtp/connections-incoming.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-smtp/connections-incoming.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('mails received')),
            'ID': 'incoming'
        },
        'clean': {
            'COUNT': [
                getRRDInformation('tail-smtp/connections-clean.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-smtp/connections-clean.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('clean mails received')),
            'ID': 'clean'
        },
        'spam': {
            'COUNT': [
                getRRDInformation('tail-smtp/connections-spam.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-smtp/connections-spam.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('spam mails received')),
            'ID': 'spam'
        },
        'virus': {
            'COUNT': [
                getRRDInformation('tail-smtp/connections-virus.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-smtp/connections-virus.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('viruses found')),
            'ID': 'virus'
        },
        'noqueue': {
            'COUNT': [
                getRRDInformation('tail-smtp/connections-noqueue.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-smtp/connections-noqueue.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('mails rejected')),
            'ID': 'noqueue'
        }
    }

    postfix_static_on = [{'queue': True}]

    postfix_dyn_on = [
        {'incoming': True},
        {'clean': True},
        {'spam': False},
        {'virus': False},
        {'noqueue': True}
    ]

    p3scan = {
        'spam': {
            'COUNT': [
                getRRDInformation('tail-pop/connections-spam.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-pop/connections-spam.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('spam mails found')),
            'ID': 'spam'
        },
        'scanned': {
            'COUNT': [
                getRRDInformation('tail-pop/connections-scanned.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-pop/connections-scanned.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('mails received')),
            'ID': 'scanned'
        },
        'virus': {
            'COUNT': [
                getRRDInformation('tail-pop/connections-virus.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-pop/connections-virus.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('viruses found')),
            'ID': 'virus'
        }
    }

    p3scan_on = [{'spam': True},
                 {'scanned': True},
                 {'virus': True}]

    snort = {
        'logged': {
            'COUNT': [
                getRRDInformation('tail-snort/connections-alert.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-snort/connections-alert.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('attacks logged')),
            'ID': 'logged'
        }
    }
#             'blocked':{'COUNT':[getRRDInformation('tail-snort/connections-drop.rrd','1800','NOW-1h','NOW'),
#                                 getRRDInformation('tail-snort/connections-drop.rrd','1800','NOW-1d','NOW')],
#                        'DESC':unicode(_('attacks blocked')),'ID':'blocked'}}

    snort_on = [{'logged': True},
                {'blocked': True}]

    squid = {
        'miss': {
            'COUNT': [
                getRRDInformation('tail-http/connections-miss.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-http/connections-miss.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('misses')),
            'ID': 'miss'
        },
        'hit': {
            'COUNT': [
                getRRDInformation('tail-http/connections-hit.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-http/connections-hit.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('hits')),
            'ID': 'hit'
        },
        'virus': {
            'COUNT': [
                getRRDInformation('tail-http/connections-virus.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-http/connections-virus.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('viruses found')),
            'ID': 'virus'
        },
        'denied': {
            'COUNT': [
                getRRDInformation('tail-http/connections-denied.rrd', '1800', 'NOW-1h', 'NOW'),
                getRRDInformation('tail-http/connections-denied.rrd', '1800', 'NOW-1d', 'NOW')
            ],
            'DESC': unicode(_('pages filtered')),
            'ID': 'denied'
        }
    }

    squid_on = [{'miss': True},
                {'hit': True},
                {'denied': False},
                {'virus': False}]

    m = m.getStatus()
    if m.get('sections') != "":
        for key, value in m.get('sections').iteritems():
            if key == 'Process':
                for process in value:
                    name = process.get('name')
                    status = process.get('status') or ''
                    status = status.lower()
                    proc = {
                        'ID': name,
                        'NAME': '',
                        'ON': False,
                        'LIVELOG': False,
                        'TASKS': {
                            'DYNAMIC': [],
                            'STATIC': []
                        }
                    }
                    if status in ('running', 'initializing'):
                        proc['ON'] = True
                    if name == 'p3scan':
                        proc['NAME'] = unicode(_('POP3 Proxy'))
                    elif name == 'amavisd' and status == 'running':
                        postfix_dyn_on[3]['virus'] = True
                    elif name == 'dansguardian' and status == 'running':
                        squid_on[2]['denied'] = True
                    elif name == 'havp' and status == 'running':
                        squid_on[3]['virus'] = True
                    elif name == 'snort':
                        proc['NAME'] = unicode(_('Intrusion Detection'))
                        proc['LIVELOG'] = "snort"
                    elif name == 'postfix':
                        proc['NAME'] = unicode(_('SMTP Proxy'))
                        proc['LIVELOG'] = "smtp"
                    elif name == 'squid':
                        proc['NAME'] = unicode(_('HTTP Proxy'))
                        proc['LIVELOG'] = "dansguardian,squid"
                    if proc['NAME'] != '':
                        presorteddict[name] = proc
    try:
        smtpscansettings = DataSource('smtpscan').settings
        if 'SA_ENABLED' in smtpscansettings and smtpscansettings['SA_ENABLED'] == 'on':
            postfix_dyn_on[2]['spam'] = True
    except Exception:
        pass
    if 'squid' in presorteddict:
        for feat in squid_on:
            for key, value in feat.iteritems():
                if value:
                    presorteddict['squid']['TASKS']['DYNAMIC'].append(squid.get(key))
        returnlist.append(presorteddict['squid'])
    if 'postfix' in presorteddict:
        for feat in postfix_dyn_on:
            for key, value in feat.iteritems():
                if value:
                    presorteddict['postfix']['TASKS']['DYNAMIC'].append(postfix_dyn.get(key))
        for feat in postfix_static_on:
            for key, value in feat.iteritems():
                if value:
                    presorteddict['postfix']['TASKS']['STATIC'].append(postfix_static.get(key))
        returnlist.append(presorteddict['postfix'])
    if 'p3scan' in presorteddict:
        for feat in p3scan_on:
            for key, value in feat.iteritems():
                if value:
                    presorteddict['p3scan']['TASKS']['DYNAMIC'].append(p3scan.get(key))
        returnlist.append(presorteddict['p3scan'])
    if 'snort' in presorteddict:
        for feat in snort_on:
            for key, value in feat.iteritems():
                if value:
                    presorteddict['snort']['TASKS']['DYNAMIC'].append(snort.get(key))
        returnlist.append(presorteddict['snort'])

    return returnlist


def getCPUCount():
    """
    Returns the count of cpus of the firewall (reading /proc/cpuinfo).

    :return: The cpu count.
    :rtype: int
    """
    try:
        ret = 0
        try:
            f = open('/proc/cpuinfo')
            for line in f:
                if line.lower().startswith('processor'):  # "processor" on x86, "Processor" on arm :-)
                    ret += 1
        finally:
            f.close()
        return ret
    except:
        return 0

# The meanings of the columns are as follows, from left to right:
# user: normal processes executing in user mode
# nice: niced processes executing in user mode
# system: processes executing in kernel mode
# idle: twiddling thumbs
# iowait: waiting for I/O to complete
# irq: servicing interrupts
# softirq: servicing softirqs
#
# Example:
# cpu  12411 0 25933 190683 3150 377 424 0 0
# cpu0 12411 0 25933 190683 3150 377 424 0 0

_CPU_RE = re.compile("cpu([0-9]*)\s*([0-9]+)\s*([0-9]+)\s*([0-9]+)\s*([0-9]+)")


def getCPUStat():
    """
    Returns cpu activity reading /proc/stat

    :return: Returns a dict (with key 'cpu_id')
             containing dict with the following keys:
             cpu_id, idle, total, user, nice, system
             'cpu_id' is a string and has value 'total' (for the total stat)
             or '0', '1', ... for the cpu 0, cpu 1, ...
    :rtype: dict of dict
    """
    result = {}
    try:
        f = None
        try:
            f = open('/proc/stat', 'r')
            for line in f:
                match = _CPU_RE.match(line)
                if match is not None:
                    (cpu_id, user, nice, system, idle) = match.groups()
                    if not cpu_id:
                        cpu_id = 'global'
                    user = int(user)
                    nice = int(nice)
                    system = int(system)
                    idle = int(idle)
                    total = user + nice + system + idle
                    result[cpu_id] = {
                        'cpu_id': cpu_id,
                        'idle': idle,
                        'total': total,
                        'user': user,
                        'nice': nice,
                        'system': system
                    }
                else:
                    break
            f.close()
        except:
            pass
    finally:
        if f:
            f.close()
    return result


def getCPUUsage(sleep_time=5):
    """
    Returns  information about cpu(s) activity

    :return: Statistics about cpu(s) activity.
    :rtype: dict
    """
    s0 = getCPUStat()
    time.sleep(sleep_time)
    s1 = getCPUStat()
    result = {}
    for id, s0_value in s0.iteritems():
        s1_value = s1[id]
        delta_total = s1_value['total'] - s0_value['total']
        delta_idle = s1_value['idle'] - s0_value['idle']
        if delta_total != 0:
            usage_percent = 100 - 100 * delta_idle / delta_total
        else:
            usage_percent = 0
        result[id] = usage_percent
    return result

def getStorageInformation():
    """
    Returns serveral statistics about the firewall storage and
    memory (reading /proc/meminfo).

    :return: Statistics about the firewall storage and memory.
    :rtype: list
    """
    result = []

    memory = 0
    swap = 0
    memoryused = 0
    swapused = 0
    try:
        f = None
        try:
            f = open('/proc/meminfo', 'r')
            for line in f:
                if line.startswith('MemTotal:'):
                    memory = int(line.split(':')[1].split()[0])
                elif line.startswith('SwapTotal:'):
                    swap = int(line.split(':')[1].split()[0])
                elif line.startswith('MemFree:'):
                    memoryused = memory - int(line.split(':')[1].split()[0])
                elif line.startswith('Buffers:'):
                    memoryused = memoryused - int(line.split(':')[1].split()[0])
                elif line.startswith('Cached:'):
                    memoryused = memoryused - int(line.split(':')[1].split()[0])
                elif line.startswith('SwapFree:'):
                    swapused = swap - int(line.split(':')[1].split()[0])
            f.close()
        except:
            pass
    finally:
        if f:
            f.close()

    if memory > 0:
        d = {}
        d['KEY'] = u'memory'
        d['USAGE'] = unicode(int((float(memoryused) / memory) * 100))
        d['TOTAL'] = u"%d MB" % int(memory / 1024)
        d['NAME'] = unicode(_('Memory'))
        result.append(d)

    if swap > 0:
        d = {}
        d['KEY'] = u'swap'
        d['USAGE'] = unicode(int((float(swapused) / swap) * 100))
        d['TOTAL'] = u"%d MB" % int(swap / 1024)
        d['NAME'] = unicode(_('Swap'))
        result.append(d)

    disk_names = {
        '/': ('root', unicode(_('Main disk'))),
        '/var': ('var', unicode(_('Data disk'))),
        '/var/efw': ('var/efw', unicode(_('Configuration disk'))),
        '/var/log': ('var/log', unicode(_('Log disk'))),
        '/boot': ('boot', unicode(_('Boot disk'))),
        '/mnt/usbstick': ('mnt/usbstick', unicode(_('Backup disk'))),
        '/tmp': ('tmp', unicode(_('Temp'))),
        '/dev': None,
        '/dev/shm': None,
        '/run':     None,
        '/var/volatile': None,
    }
    processed_disks = set()
    try:
        f = None
        try:
            f = open("/proc/mounts", 'r')
            for line in f:
                try:
                    line = line.split()
                    if line[2] != 'none' and \
                            line[1] not in processed_disks and \
                            os.path.ismount(line[1]):
                        if line[1] in disk_names:
                            name, desc = disk_names[line[1]]
                        else:
                            name = line[1]
                            desc = line[1]
                        disk = os.statvfs(line[1])
                        capacity = disk.f_frsize * disk.f_blocks
                        # available = disk.f_frsize * disk.f_bavail
                        # used = disk.f_bsize * (disk.f_blocks - disk.f_bavail)
                        usage = int(100 - 100.0 * disk.f_bavail / disk.f_blocks)
                        processed_disks.add(line[1])
                        result.append({
                            'KEY': u'df-%s' % name,
                            'USAGE': unicode(usage),
                            'NAME': unicode(desc),
                            'TOTAL': unicode(human_readable_size(capacity))
                        })
                except:
                    pass
        except:
            pass
    finally:
        if f:
            f.close()

    return result


def getHardwareInformation(**params):
    return {
        "cpustat": getCPUStat(),
        "storage": getStorageInformation()
    }


def loadUpLinks():
    """
    Returns the uplinks and nics of the firewall.

    :return: Dicts of uplinks and nics.
    :rtype: Tuple of dicts.
    """
    if UplinksPool is None:
        return {}, {}
    _uplinkCache = {}
    _nicCache = {}
    ups = UplinksPool()
    for uplink in ups.iterUplinks():
        settings = uplink.getSettings()
        name = uplink.uplinkname
        data = uplink.getData()
        _uplinkCache[name] = {
            'settings': settings,
            'data': data,
        }
        iff = settings.get('RED_DEV')
        if iff is None:
            iff = data.get('INTERFACE')
        _nicCache[iff] = _uplinkCache[name]
    return _uplinkCache, _nicCache


def getNetworkInformation():
    """
    Returns the informations about the networks of the firewall.

    :return: Informations about the networks.
    :rtype: List
    """
    uplinkcache, niccache = loadUpLinks()
    c = subprocess.Popen(['/sbin/ip','link'], stdout=subprocess.PIPE).communicate()[0].strip()
    lines = c.split("\n")
    lines = map(lambda x: x.strip(), lines)
    devices = []
    ds = DataSource('ethernet').settings
    vpn = DataSource('openvpn').settings
    for line in lines:
        if not line.strip().startswith('link'):
            x = line.split(':')
            if len(x) < 2:
                continue
            device = x[1].strip()
            if device == 'lo':
                continue
            elif device.find('@') > 0:
                device = device.split('@')[0].strip()
            on = unicode(_('Up'))
            if line.find('NO-CARRIER') >= 0:
                on = unicode(_('Down'))
            up = unicode(_('Up'))
            if line.find(',UP,') < 0 and line.find('<UP,') < 0 and line.find(',UP>') < 0:
                up = unicode(_('Down'))
            devices.append({
                'DEVICE': device,
                'LINK': on,
                'STATUS': up,
                'DISPLAY': device.replace('.', '_')
            })
        else:
            x = line.split('link/')
            if len(x) > 1:
                typ = x[1].split(' ')[0]
            if typ == 'ether':
                typ = 'ethernet'
            if len(devices) > 0:
                devices[len(devices) - 1]['TYPE'] = typ
                devices[len(devices) - 1]['IN'] = ''
                devices[len(devices) - 1]['OUT'] = ''
    bridge_interfaces = {}
    for device in devices:
        if device['DEVICE'].startswith('br'):
            if os.path.exists('/var/efw/ethernet/%s' % device['DEVICE']):
                f = open('/var/efw/ethernet/%s' % device['DEVICE'], 'r')
            elif os.path.exists('/usr/lib/efw/ethernet/default/%s' % device['DEVICE']):  # check for default file if user file does not exist
                f = open('/usr/lib/efw/ethernet/default/%s' % device['DEVICE'], 'r')
            else:
                break
            bridge_interfaces[device['DEVICE']] = []
            for line in f:
                if line.strip() != '':
                    bridge_interfaces[device['DEVICE']].append(line.strip())
            f.close()
        elif ds.get('BLUE_DEV').startswith("tun") and ds.get('BLUE_DEV') == device['DEVICE']:
            bridge_interfaces[device['DEVICE']] = []

    # Remove unused bridged interfaces.
    bridge_interfaces = dict([(k, v) for k, v in bridge_interfaces.iteritems() if v])

    devicedict = {}
    used_interfaces = []
    for dev, value in bridge_interfaces.iteritems():
        for d in devices:
            if d['DEVICE'] == dev:
                devicedict[d['DEVICE']] = d
        devicedict[dev]['BRIDGE'] = True
        devicedict[dev]['CLASS'] = 'unknown'
        devicedict[dev]['CHECKED'] = 'checked'
        if ds.get('GREEN_DEV') == dev:
            devicedict[dev]['CLASS'] = 'green'
        elif ds.get('BLUE_DEV') == dev:
            devicedict[dev]['CLASS'] = 'blue'
        elif ds.get('ORANGE_DEV') == dev:
            devicedict[dev]['CLASS'] = 'orange'
        devicedict[dev]['PHYSICAL'] = []
        used_interfaces.append(dev)
        for d in devices:
            if d['DEVICE'] in value and d['DEVICE'] not in used_interfaces:
                d['CHECKED'] = ''
                devicedict[dev]['PHYSICAL'].append(d)
                used_interfaces.append(d['DEVICE'])
    for d in devices:
        if d['DEVICE'] not in used_interfaces:
            devicedict[d['DEVICE']] = d
            devicedict[d['DEVICE']]['BRIDGE'] = False
            devicedict[d['DEVICE']]['CLASS'] = 'unknown'
            devicedict[d['DEVICE']]['CHECKED'] = ''
            if vpn.get('PURPLE_DEVICE') == d['DEVICE']:
                devicedict[d['DEVICE']]['CLASS'] = 'purple'
                devicedict[d['DEVICE']]['CHECKED'] = 'checked'
            elif d['DEVICE'].startswith('ipsec'):
                devicedict[d['DEVICE']]['CLASS'] = 'purple'
                devicedict[d['DEVICE']]['CHECKED'] = 'checked'
            elif d['DEVICE'] in niccache:
                    devicedict[d['DEVICE']]['CLASS'] = 'red'
                    devicedict[d['DEVICE']]['CHECKED'] = 'checked'
            used_interfaces.append(d['DEVICE'])

    newdict = {}
    devicesdict = {}
    collectd_keys = []
    for x, y in devicedict.iteritems():
        if y.get('CLASS') != 'unknown':
            devicesdict[x] = y
            collectd_keys.append("netlink-%s/if_octets" % x)
            if 'PHYSICAL' in devicesdict[x]:
                for d in devicesdict[x]['PHYSICAL']:
                    collectd_keys.append("netlink-%s/if_octets" % d['DEVICE'])
    newdict["devices"] = devicesdict
    newdict["collectd"] = getCollectdSingleValues(keys=collectd_keys)
    return newdict


def getClamavSignature():
    """
    Return a string representing the last time the
    clamav signatures were updated, or None.

    :return: string representing an epoch time.
    :rtype: str
    """
    if not os.path.isfile(CLAMAV_INFO):
        return None
    try:
        cinfo = open(CLAMAV_INFO, 'r')
        # Beware that this may consume a lot of memory,
        # if CLAMAV_INFO can grow a lot (but I don't think it can)
        lines = cinfo.readlines()
        cinfo.close()
        lines.reverse()
        for line in lines:
            if 'Database updated' not in line:
                continue
        date = ' '.join(filter(None, line.split())[:3])
        ts = list(time.strptime(date, '%b %d %H:%M:%S'))
        ts[0] = datetime.datetime.now().year
        ts = tuple(ts)
        return str(int(time.mktime(ts)))
    except Exception, e:
        logger.warn('unable to get clamav signatures: %s', e)
    return None


def getSignaturesInformation(*args, **kwds):
    """
    Return the information about the downloaded signatures.

    :return: Information about the signatures.
    :rtype: List
    """
    signatures = {}
    sf = SettingsFile(SIGNATURES_TIMESTAMPS) or {}
    clamav_ts = getClamavSignature()
    keys_map = {
        'DANSGUARDIAN_BLACKLIST_URL': _('Contentfilter URL blacklist'),
        'DANSGUARDIAN_PHRASELIST_URL': _('Contentfilter phraselist'),
        'DNSMASQ_BLACKHOLE_URL': _('Anti-spyware lists'),
        'DNSMASQ_DNSMASQ_BLACKHOLE_URL': _('Anti-spyware lists'),
        'SNORT_SNORT_RULES_URL': _('IPS signatures'),
        'PANDA_SIGNATURES_URL': _('Panda signatures'),
        'SOPHOS_SIGNATURES_URL': _('Sophos signatures'),
    }
    if clamav_ts:
        sf['ClamAV virus signatures'] = clamav_ts
    if 'DNSMASQ_BLACKHOLE_URL' in sf and 'DNSMASQ_DNSMASQ_BLACKHOLE_URL' in sf:
        del sf['DNSMASQ_BLACKHOLE_URL']
    for key, timestamp in sf.iteritems():
        if not timestamp:
            return
        try:
            dt = datetime.datetime.fromtimestamp(long(timestamp))
            timestamp = dt.strftime("%Y.%m.%d %H:%M")
        except Exception, e:
            logger.warn('unable to convert timestamp %s=%s: %s',
                        key, timestamp, e)
            continue
        # Here is a good place to add a custom
        # conversion from a key found in /var/efw/download/timestamps
        # and a nice name to print.
        # Otherwise, the default is to strip "_URL", split the
        # remaining string at '_', remove consecutive duplicates,
        # join the pieces with ' ' and capitalize.
        if key in keys_map:
            signatures[unicode(keys_map[key])] = timestamp
            continue
        nkey = key.replace('_URL', '')
        skey = nkey.split('_')
        # Remove consecutive duplicates.
        skey = [x[0] for x in groupby(skey)]
        nkey = ' '.join(skey).capitalize()
        nkey = str(nkey)
        signatures[nkey] = timestamp
    return signatures
