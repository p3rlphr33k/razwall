#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import re
import subprocess
import csv

from endian.core.i18n import _
from endian.core.pdict import PersistentDict
from endian.core.lazylist import LazyList
from endian.core.logger import error
from endian.emi import entities
from endian.ca.common import OPENSSL_BIN

from endian.authentication.handlers.ca import CA_CA, \
        CERT_TYPE_OPTIONS, \
        CA_CERTS_DIR, \
        CA_CACERTS_DIR, \
        CA_INDEX, \
        CA_CRLS_DIR, \
        CA_CERTS_STATUS, \
        CERT_STATUS_INVALID, \
        CERT_STATUS_REVOKED, \
        CERT_STATUS_EXPIRED

__all__ = [
    'Certificate',
    'CertificateType',
    'CertificateDigest',
    'CertificateOption',
    'CertificateAuthority',
    'RevokedCertificate',
    'CRL',
]

CERT_TYPE_NAMES = {
    'client' : _("Client"),
    'server' : _("Server"),
    'email' : _("Email"),
    'objsign' : _("Object"),
    'reserved' : _("Reserved"),
    'sslCA' : _("SSL CA"),
    'emailCA' : _("Email CA"),
    'objCA' : _("Object CA")
}

CERT_DIGEST_NAMES = {
    'sha1' : _("SHA1"),
    'sha224' : _("SHA2 224"),
    'sha256' : _("SHA2 256"),
    'sha384' : _("SHA2 384"),
    'sha512' : _("SHA2 512")
}

certs_status = PersistentDict(CA_CERTS_STATUS)

def cert_types():
    values = []
    for key in CERT_TYPE_OPTIONS:
        values.append({'ID': key, 'name': CERT_TYPE_NAMES.get(key, key)})
    return values

def cert_digests():
    values = []
    for key in sorted(CERT_DIGEST_NAMES.keys()):
        values.append({'ID': key, 'name': CERT_DIGEST_NAMES.get(key, key)})
    return values

class CertificateType(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = cert_types()

class CertificateDigest(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = cert_digests()

class CertificateOption(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'new_cert', 'name': _("Generate a new certificate")}, # not stored, only for the gui
        {'ID': 'upload_cert', 'name': _("Upload a certificate")}, # not stored, only for the gui
        {'ID': 'upload_cert_req', 'name': _("Upload a certificate signing request")}, # not stored, only for the gui
    ]

class Certificate(entities.Entity):
    entities.using_options(namespace=CA_CERTS_DIR[1:].replace("/", "."), type='directory', cache_type="file", register_datasource=False, storage_args={'indexes': ['name']})

    directory = CA_CERTS_DIR

    @classmethod
    def storage(cls):
        """
        Use the custom directory storage for certificates
        """
        if cls._storage:
            return cls._storage

        storage_args = cls._storage_args
        storage_args = cls._descriptor.storage_args
        if type(storage_args) != dict:
            storage_args = {}

        from endian.ca.storage import CertificateDirectoryStorage
        cls._storage = CertificateDirectoryStorage(entity=cls, **storage_args)
        return cls._storage

    # set validator to False prevents the controller to validate them
    ID = entities.Field(entities.Unicode,
        primary_key=True,
        nullable=False,
        validator=False)
    name = entities.Field(entities.Unicode,
        nullable=False,
        validator=False)

    pem_filename = entities.Field(entities.Unicode,
        validator=False)
    p12_filename = entities.Field(entities.Unicode,
        validator=False)
    key_filename = entities.Field(entities.Unicode,
        validator=False)

    has_pem = entities.Field(entities.Boolean,
        validator=False)
    has_p12 = entities.Field(entities.Boolean,
        validator=False)
    has_key = entities.Field(entities.Boolean,
        validator=False)

    subject = entities.Field(entities.Unicode,
        validator=False)
    common_name = entities.Field(entities.Unicode,
        validator=False)
    serial = entities.Field(entities.Unicode,
        validator=False)
    issuer = entities.Field(entities.Unicode,
        validator=False)
    issuer_common_name = entities.Field(entities.Unicode,
        validator=False)
    status = entities.Field(entities.Unicode,
        validator=False)

    cert_type = entities.ManyToMany(
        target="ca:CertificateType",
        nullable=True
    )

    not_before = entities.Field(entities.Unicode,
        validator=False)
    not_after = entities.Field(entities.Unicode,
        validator=False)

    text = entities.Field(entities.UnicodeText,
        validator=False)

    @property
    def pem(self):
        f = None
        try:
            f = file(self.pem_filename, 'r')
            return f.read()
        finally:
            if f is not None:
                f.close()

    @property
    def p12(self):
        f = None
        try:
            f = file(self.p12_filename, 'r')
            return f.read()
        finally:
            if f is not None:
                f.close()

    @property
    def ca_id(self):
        ca = self.ca
        return ca is not None and ca.ID or ""

    @property
    def ca_name(self):
        ca = self.ca
        return ca is not None and ca.name or ""

    @property
    def ca(self):
        ca_cn = self.issuer_common_name
        for ca in CertificateAuthority.get_by_common_name(ca_cn):
            if self.check_validity(ca):
                return ca
        return None

    @property
    def issued_by_local_ca(self):
        ca = self.ca
        return ca is not None and ca.has_key

    @property
    def description(self):
        if self.status == CERT_STATUS_REVOKED:
            return _("%s (revoked)" % self.name)
        elif self.status == CERT_STATUS_EXPIRED:
            return _("%s (expired)" % self.name)
        elif self.status == CERT_STATUS_INVALID:
            return _("%s (invalid)" % self.name)
        else:
            return self.name

    @classmethod
    def all(cls):
        return list(cls.storage().load())

    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

    @classmethod
    def get_by_name(cls, name):
        cert = cls.storage().select(name=name)
        if cert and len(cert) > 0:
            return cert[0]
        return None

    @classmethod
    def get_by_common_name(cls, common_name):
        return cls.storage().select(common_name=common_name)

    @classmethod
    def get_by_issuer_common_name(cls, issuer_common_name):
        return cls.storage().select(issuer_common_name=issuer_common_name)

    def check_validity(self, certificate_authority):
        """ Check if the certificate is valid for the given certificate authority """
        if isinstance(certificate_authority, CertificateAuthority):
            certificate_authority = certificate_authority.pem_filename
        p = subprocess.Popen([OPENSSL_BIN, "verify",
                                "-CAfile", os.path.join(CA_CACERTS_DIR, certificate_authority),
                                os.path.join(CA_CERTS_DIR, self.pem_filename)],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT)
        output = p.communicate()[0].strip()
        return check_openssl_verify_output(output)

    @classmethod
    def check_if_certificate_exist(cls, name):
        if not name.endswith('cert.pem'):
            name = name[:-8] + 'cert.pem'
        return os.path.exists(os.path.join(cls.directory, name))

    def delete(self, **args):
        """ Remove the certificate """
        for filename in [self.pem_filename, self.key_filename, self.p12_filename]:
            try:
                os.unlink(filename)
            except:
                pass
        # Delete the broken symlinks
        for name in os.listdir(self.directory):
            link = os.path.join(self.directory, name)
            if os.path.islink(link) and not os.path.exists(os.readlink(link)):
                try:
                    os.unlink(link)
                except:
                    pass
        # Remove the certificate status
        try:
            del certs_status[self.name]
        except:
            pass

    def delete_private_key(self, **args):
        """ Remove the private key (p12 and key.cert) """
        for filename in [self.key_filename, self.p12_filename]:
            try:
                os.unlink(filename)
            except:
                pass

class CertificateAuthority(entities.Entity):
    entities.using_options(namespace=CA_CACERTS_DIR[1:].replace("/", "."), type='directory', cache_type="file", register_datasource=False, storage_args={'indexes': ['name']})

    directory = CA_CACERTS_DIR

    @classmethod
    def storage(cls):
        """
        Use the custom directory storage for certificates
        """
        if cls._storage:
            return cls._storage

        storage_args = cls._storage_args
        storage_args = cls._descriptor.storage_args
        if type(storage_args) != dict:
            storage_args = {}

        from endian.ca.storage import CertificateAuthorityDirectoryStorage
        cls._storage = CertificateAuthorityDirectoryStorage(entity=cls, **storage_args)
        return cls._storage

    # set validator to False prevents the controller to validate them
    ID = entities.Field(entities.Unicode,
        primary_key=True,
        nullable=False,
        validator=False)
    name = entities.Field(entities.Unicode,
        nullable=False,
        validator=False)

    pem_filename = entities.Field(entities.Unicode,
        validator=False)
    p12_filename = entities.Field(entities.Unicode,
        validator=False)
    key_filename = entities.Field(entities.Unicode,
        validator=False)
    crl_filename = entities.Field(entities.Unicode,
        validator=False)

    has_pem = entities.Field(entities.Boolean,
        validator=False)
    has_p12 = entities.Field(entities.Boolean,
        validator=False)
    has_key = entities.Field(entities.Boolean,
        validator=False)
    has_crl = entities.Field(entities.Boolean,
        validator=False)

    subject = entities.Field(entities.Unicode,
        validator=False)
    common_name = entities.Field(entities.Unicode,
        validator=False)
    serial = entities.Field(entities.Unicode,
        validator=False)
    issuer = entities.Field(entities.Unicode,
        validator=False)
    issuer_common_name = entities.Field(entities.Unicode,
        validator=False)

    not_before = entities.Field(entities.Unicode,
        validator=False)
    not_after = entities.Field(entities.Unicode,
        validator=False)

    text = entities.Field(entities.UnicodeText,
        validator=False)

    @property
    def pem(self):
        f = None
        try:
            f = file(self.pem_filename, 'r')
            return f.read()
        finally:
            if f is not None:
                f.close()

    @property
    def p12(self):
        f = None
        try:
            f = file(self.p12_filename, 'r')
            return f.read()
        finally:
            if f is not None:
                f.close()

    @property
    def crl(self):
        f = None
        try:
            f = file(self.crl_filename, 'r')
            return f.read()
        finally:
            if f is not None:
                f.close()

    @property
    def description(self):
        if self.name == CA_CA:
            return _("%s (default)" % self.common_name)
        else:
            return self.name

    def check_validity(self, certificate):
        """ Check if the certificate is valid with this certificate authority """
        if isinstance(certificate, Certificate):
            certificate = certificate.pem_filename
        p = subprocess.Popen([OPENSSL_BIN, "verify",
                                "-CAfile", os.path.join(CA_CACERTS_DIR, self.pem_filename),
                                os.path.join(CA_CERTS_DIR, certificate)],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT)
        output = p.communicate()[0].strip()
        return check_openssl_verify_output(output)

    @classmethod
    def all(cls):
        return list(cls.storage().load())

    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

    @classmethod
    def get_by_name(cls, name):
        ca_cert = cls.storage().select(name=name)
        if ca_cert and len(ca_cert) > 0:
            return ca_cert[0]
        return None

    @classmethod
    def get_by_common_name(cls, common_name):
        return cls.storage().select(common_name=common_name)

    @classmethod
    def check_if_certificate_exist(cls, name):
        if not name.endswith('cert.pem'):
            name = name[:-8] + 'cert.pem'
        return os.path.exists(os.path.join(cls.directory, name))

    @classmethod
    def parse_ca(cls, data):
        """ Parse a CA certificate in PEM or ASN1 format """
        from OpenSSL import crypto
        try:
            cert = crypto.load_certificate(crypto.FILETYPE_PEM, data)
            cert_format = crypto.FILETYPE_PEM
        except crypto.Error:
            cert = crypto.load_certificate(crypto.FILETYPE_ASN1, data)
            cert_format = crypto.FILETYPE_ASN1
        is_a_ca = False
        for i in range(0, cert.get_extension_count()):
            try:
                if 'CA:TRUE' in str(cert.get_extension(i)):
                    is_a_ca = True
            except:
                pass
        subject = cert.get_subject()
        c = dict(subject.get_components())
        for key in ['CN', 'OU', 'O']:
            if key in c:
                cert_name = c[key]
                break
        if not cert_name:
            raise crypto.Error()
        return { "cert": cert, "cert_name": cert_name, "is_a_ca": is_a_ca, "cert_format": cert_format}

    @classmethod
    def check_if_ca_already_exist(cls, cert_name):
        # Check if there is no other entry with the same name
        if (CertificateAuthority.get_by_name(cert_name)) is not None:
            return True
        else:
            # Special case - check the default ca
            default_ca = CertificateAuthority.get_by_name(CA_CA)
            if default_ca is not None and cert_name == default_ca.common_name:
                return True
        return False

    def delete(self, **args):
        """ Remove CA certificate and associated certificates """
        # Delete the associated certificates
        for cert in Certificate.get_by_issuer_common_name(self.common_name):
            if cert.check_validity(self):
                cert.delete()
        # Delete the broken symlinks
        for name in os.listdir(CA_CERTS_DIR):
            link = os.path.join(CA_CERTS_DIR, name)
            if os.path.islink(link) and not os.path.exists(os.readlink(link)):
                try:
                    os.unlink(link)
                except:
                    pass
        # Delete the ca certificate
        try:
            os.unlink(self.pem_filename)
        except:
            pass

def get_revoked_certificates():
    if not os.path.exists(CA_INDEX):
        return []
    try:
        index = csv.reader(open(CA_INDEX, 'r'), delimiter='\t')
        return [RevokedCertificate(ID=row[3].lstrip("0"), \
                                    name=row[5].replace('/',' ').strip())
                                    for row in index if row[0] == 'R']
    except Exception, ex:
        error(str(ex), exc_info=True)
        return []

class RevokedCertificate(entities.Entity):
    entities.using_options(type='dynamic')

    ID = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = LazyList(get_revoked_certificates)

    @classmethod
    def all(cls):
        return list(cls.storage().load())


class CRL(entities.Entity):
    entities.using_options(namespace=CA_CRLS_DIR[1:].replace("/", "."), type='directory', cache_type="file", register_datasource=False, storage_args={'indexes': ['name']})

    directory = CA_CRLS_DIR

    @classmethod
    def storage(cls):
        """
        Use the custom directory storage for certificates
        """
        if cls._storage:
            return cls._storage

        from endian.ca.storage import CRLDirectoryStorage
        storage_args = cls._storage_args
        storage_args = cls._descriptor.storage_args
        if type(storage_args) != dict:
            storage_args = {}
        cls._storage = CRLDirectoryStorage(entity=cls, **storage_args)
        return cls._storage

    # set validator to False prevents the controller to validate them
    ID = entities.Field(entities.Unicode,
        primary_key=True,
        nullable=False,
        validator=False)
    name = entities.Field(entities.Unicode,
        nullable=False,
        validator=False)
    pem_filename = entities.Field(entities.Unicode,
        validator=False)
    has_pem = entities.Field(entities.Boolean,
        validator=False)
    issuer = entities.Field(entities.Unicode,
        validator=False)
    text = entities.Field(entities.UnicodeText,
        validator=False)
    last_update = entities.Field(entities.Unicode,
        validator=False)
    next_update = entities.Field(entities.Unicode,
        validator=False)

    @property
    def pem(self):
        """ Obsolete, use crl """
        f = None
        try:
            f = file(self.path, 'r')
            return f.read()
        finally:
            if f is not None:
                f.close()

    @property
    def crl(self):
        f = None
        try:
            f = file(self.path, 'r')
            return f.read()
        finally:
            if f is not None:
                f.close()

    @classmethod
    def all(cls):
        return list(cls.storage().load())

    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

    @classmethod
    def get_by_name(cls, name):
        ca_cert = cls.storage().select(name=name)
        if ca_cert and len(ca_cert) > 0:
            return ca_cert[0]
        return None

    def delete(self, **args):
        """ Delete the CRL """
        try:
            os.unlink(self.pem_filename)
        except:
            pass

OPENSSL_VERIFY_OUTPUT_RE = re.compile('^error ([0-9]+) at ([0-9]+) depth (.*)$')

# According to the OpenSSL documentation:
# "When a verify operation fails the output messages can be somewhat cryptic."

def parse_openssl_verify_output(output):
    result = { 'error_code': -1, 'depth': -1, 'message': output }
    # parse a message like the following: 'error 2 at 1 depth'
    output = output.split('\n')[-1] # the last line
    print output
    if output.endswith('OK'):
        result['error_code'] = 0
        result['messages'] = 'OK'
        return result
    match = OPENSSL_VERIFY_OUTPUT_RE.match(output)
    if not match:
        return result
    result['error_code'] = int(match.group(1))
    result['depth'] = int(match.group(2))
    result['message'] = match.group(3)
    return result

def check_openssl_verify_output(output):
    result = parse_openssl_verify_output(output)
    if result['error_code'] == 0:
        return True
    # 2 X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: unable to get issuer certificate
    if result['error_code'] == 2 and result['depth'] > 0: # depth > 0 - CA chain
        return True
    return False

