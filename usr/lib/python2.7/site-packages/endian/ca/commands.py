#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import time
import glob
import subprocess
from tempfile import NamedTemporaryFile
from endian.core.i18n import _
from endian.core.logger import error
from endian.core.pdict import PersistentDict
from endian.authentication.handlers.ca import CA_CERTS_DIR, \
    CA_CACERTS_DIR, \
    CA_CRLS_DIR, \
    CA_CERTS_STATUS, \
    CERT_STATUS_VALID
from endian.ca.schema import CertificateAuthority, \
    Certificate, \
    CRL
from endian.ca.common import generate_filename, \
    parse_asn1time, \
    emit_crl_changed, \
    OPENSSL_BIN, \
    DEFAULT_DIGEST
from endian.core import commands
from endian.validators.boolean import to_bool
from endian.authentication import auth_client

__all__ = [
    'create_certificate_authority',
    'upload_certificate',
    'upload_certificate_request',
    'verify_certificate',
    'revoke_certificate',
    'create_certificate',
    'create_certificate_authority',
    'get_common_names',
    'get_file_names',
    'upload_crl',
    'recreate_hash_symlinks',
]

certs_status = PersistentDict(CA_CERTS_STATUS)

def _import_pem(f, data):
    # Check if the certificate is valid
    try:
        warning = _check_uploaded_certificate(f.name)
    except Exception, ex:
        return { "error": str(ex) }

    # Load the certificate and extract the common name
    from OpenSSL import crypto
    try:
        cert = crypto.load_certificate(crypto.FILETYPE_PEM, data)
        subject = cert.get_subject()
        cert_name = dict(subject.get_components())['CN']
    except:
        return { "error": _("Error parsing the uploaded certificate") }

    # Check if a certificate with the same common name already exist
    cert_name = generate_filename(cert_name)
    old_certs = Certificate.get_by_common_name(cert_name)
    if old_certs and old_certs[0].status == CERT_STATUS_VALID:
        return { "error": _("A certificate with the same common name already exist") }

    # Save the host certificate
    filename = "%scert.pem" % cert_name
    try:
        tf = open(os.path.join(CA_CERTS_DIR, filename), 'w+')
        tf.write(data)
        tf.close()

        auth_client.create_hash_symlink(cert_name)
        certs_status[cert_name] = CERT_STATUS_VALID
        common_name = Certificate.get_by_name(cert_name).common_name
        return { "info": warning or _("Certificate uploaded"), "cert_name": cert_name, "cert_filename": filename, "common_name": common_name }
    except Exception, ex:
        return { "error": _("Certificate file creation failed.") }

def _import_pkcs12(f, data, certificate_password):
    from OpenSSL import crypto
    # Extract the CA certificate from the file
    p = subprocess.Popen([OPENSSL_BIN, "pkcs12",
                        "-cacerts", "-nokeys",
                        "-in", f.name,
                        "-passin", "pass:%s" % certificate_password],
                        stdout=subprocess.PIPE)

    ca_certificate = p.communicate()[0]
    exit_code = p.returncode
    if exit_code != 0:
        return { "error": _("Invalid certificate or password.") }

    # Extract the certificate from the file
    p = subprocess.Popen([OPENSSL_BIN, "pkcs12",
                        "-clcerts", "-nokeys",
                        "-in", f.name,
                        "-passin", "pass:%s" % certificate_password],
                        stdout=subprocess.PIPE)

    host_certificate = p.communicate()[0]
    exit_code = p.returncode
    if exit_code != 0:
        return { "error": _("Invalid certificate or password.") }

    # Extract the key from the file
    p = subprocess.Popen([OPENSSL_BIN, "pkcs12",
                        "-clcerts", "-nocerts",
                        "-in", f.name,
                        "-passin", "pass:%s" % certificate_password,
                        "-nodes"],
                        stdout=subprocess.PIPE)

    host_key = p.communicate()[0]
    exit_code = p.returncode
    if exit_code != 0:
        return { "error": _("Invalid certificate or password.") }

    # Load the certificate and extract the common name
    try:
        cert = crypto.load_certificate(crypto.FILETYPE_PEM, host_certificate)
        subject = cert.get_subject()
        cert_name = dict(subject.get_components())['CN']
        cert_name = generate_filename(cert_name)
    except:
        return { "error": _("Error parsing the uploaded certificate") }

    # Check if a certificate with the same common name already exist
    old_certs = Certificate.get_by_common_name(cert_name)
    if old_certs and old_certs[0].status == CERT_STATUS_VALID:
        return { "error": _("A certificate with the same common name already exist") }

    # Check the CA certificate
    try:
        parsed_ca = CertificateAuthority.parse_ca(ca_certificate)
        ca_cert_name = parsed_ca['cert_name']
    except Exception, ex:
        error(ex)
        return { "error": _("Not a valid CA certificate.") }

    ca_already_exist = CertificateAuthority.check_if_ca_already_exist(ca_cert_name)
    if not ca_already_exist:
        # Save the CA certificate
        try:
            tf = open(os.path.join(CA_CACERTS_DIR, "%scert.pem" % ca_cert_name), 'w+')
            tf.write(ca_certificate)
            tf.close()
        except Exception, ex:
            return { "error": _("CA certificate file creation failed") }

        # Create the symlink
        auth_client.create_ca_hash_symlink(ca_cert_name)

    # Save the certificate
    cert_filename = "%scert.pem" % cert_name
    cert_fullpath = os.path.join(CA_CERTS_DIR, cert_filename)
    try:
        tf = open(cert_fullpath, 'w+')
        tf.write(host_certificate)
        tf.close()
    except Exception, ex:
        error(str(ex), exc_info=True)
        return { "error": _("Certificate file creation failed.") }

    # Check the certificate
    try:
        warning = _check_uploaded_certificate(cert_fullpath)
    except Exception, ex:
        os.unlink(cert_fullpath)
        return { "error": str(ex) }

    # Create the symlink and save the certificate status
    auth_client.create_hash_symlink(cert_name)
    certs_status[cert_name] = CERT_STATUS_VALID

    # Save the key
    try:
        key_filename = "%skey.pem" % cert_name
        if "PRIVATE KEY" in host_key: # -----BEGIN RSA PRIVATE KEY-----, -----BEGIN PRIVATE KEY-----
            tf = open(os.path.join(CA_CERTS_DIR, key_filename) , 'w+')
            tf.write(host_key)
            tf.close()
    except Exception, ex:
        return { "error": _("Key file creation failed.") }

    # Save the p12
    try:
        p12_filename = "%s.p12" % cert_name
        tf = open(os.path.join(CA_CERTS_DIR, p12_filename) , 'w+')
        tf.write(data)
        tf.close()
    except Exception, ex:
        return { "error": _("Certificate file creation failed.") }

    common_name = Certificate.get_by_name(cert_name).common_name
    return { "info": warning or _("Certificate uploaded"), "cert_name": cert_name, "cert_filename": cert_filename, "common_name": common_name }


@commands.force_json_output
def create_certificate_authority(cert_name, cert_email="", cert_ou="", cert_organization="",
                       cert_city="", cert_state="", cert_country="", cert_subjectaltname="",
                       cert_days="", cert_filename="", cert_digest=DEFAULT_DIGEST):
    """
        Create a new certificate
        :param cert_name: CN = CommonName
        :type cert_name: string
        :param cert_email: Email address
        :type cert_ou: string
        :param cert_organization: OU = Organization Unit typically certificate type
        :type cert_organization: string
        :param cert_city: L = Locality; generally - city
        :type cert_city: string
        :param cert_state: ST = state or province
        :type cert_state: string
        :param cert_country: C = ISO3166 two character country code
        :type cert_country: string
        :param cert_subjectaltname:
        :type cert_subjectaltname: string
        :param cert_days: default certificate validity in days
        :type cert_days: string or int
        :param cert_filename: certificate file name (equals to cert_name if empty)
        :type cert_filename: string
        :param cert_digest: digest algorithm
        :type cert_digest: string
    """
    try:
        result = auth_client.create_certificate_authority(cert_name=cert_name, cert_email=cert_email, cert_ou=cert_ou, cert_organization=cert_organization,
                                                cert_city=cert_city, cert_state=cert_state, cert_country=cert_country, cert_subjectaltname=cert_subjectaltname,
                                                cert_days=cert_days, cert_filename=cert_filename, cert_digest=cert_digest)
        common_name = cert_name
        cert_name = os.path.basename(result['cert_filename']).replace('cert.pem','').replace('.pem','')
        filename = "%scert.pem" % cert_name
        return { "info": _("Certificate Authority generated"), "cert_name": cert_name, "cert_filename": filename, "common_name": common_name }
    except Exception, ex:
        msg = str(ex)
        if msg.startswith("AuthException:"):
            msg = msg[14:]
        error(str(ex), exc_info=True)
        return { "error": str(ex) }

def _check_uploaded_certificate(filename):
    """
    Check the uploaded certificate (PEM format)
    Return the warning message as a string and raise an exception in case of error
    """
    warning = None
    p = subprocess.Popen([OPENSSL_BIN, "verify",
                          "-crl_check",
                          "-CApath", CA_CERTS_DIR,
                          filename],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.STDOUT)
    output = p.communicate()[0].strip()
    valid = output.endswith("OK")
    if "certificate revoked" in output:
        raise Exception(_("The certificate has been revoked."))

    if 'unable to get certificate CRL' in output:
        p = subprocess.Popen([OPENSSL_BIN, "verify",
                            "-CApath", CA_CERTS_DIR,
                            filename],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.STDOUT)
        output = p.communicate()[0].strip()
        valid = output.endswith("OK")

    if "error 9" in output: # certificate is not yet valid
        valid = True # upload the not already valid certificates
        warning = _("Warning: Certificate is not yet valid (the 'notBefore' date is after the current time.")
    if "unable to get local issuer certificate" in output:
        raise Exception(_("Cannot import the certificate. Please upload the certificate CA."))
    elif "certificate has expired" in output:
        raise Exception(_("The certificate is expired."))
    if not valid:
        raise Exception(_("Invalid certificate (reason: '%s'). " % output))
    return warning

@commands.force_json_output
def upload_certificate(certificate_data, certificate_password=None):
    """
        Install a certificate

        :param certificate_data: certificate content (PEM or PKCS12)
        :type certificate_data: string
        :param certificate_password: optional PKCS12 password
        :param certificate_password: string
    """
    try:
        # Create a temp file and copy the uploaded certificate on it
        f = NamedTemporaryFile()
        f.write(certificate_data);
        f.flush()

        try:
            from OpenSSL import crypto
            crypto.load_certificate(crypto.FILETYPE_PEM, certificate_data)
            is_pem = True
        except:
            is_pem = False

        if is_pem:
            return _import_pem(f, certificate_data)
        else: # Try to import the file as a PKCS12
            return _import_pkcs12(f, certificate_data, certificate_password)

    finally:
        f.close() # delete the temp file

@commands.force_json_output
def upload_certificate_request(certificate_request_data, certificate_request_validity, cert_type="", cert_start_date="", revoke_old_certificate=""):
    """
        Create a certificate from a certificate signing request

        :param certificate_request_data: request content
        :type certificate_request_data: string
        :param certificate_request_validity: certificate validity in days
        :type certificate_request_validity: int
        :param cert_type: optional certificate type (check CERT_TYPE_OPTIONS for valid options)
        :type cert_type: string
        :param cert_start_date: optional certificate validity notBefore
        :type cert_start_date: string in YYMMDDHHMMSSZ format
        :param revoke_old_certificate: revoke the old certificate if exist
        :type revoke_old_certificate: string ("True" or "False")
    """
    # Check the certificate and extract the common name
    from OpenSSL import crypto
    try:
        req = crypto.load_certificate_request(crypto.FILETYPE_PEM, certificate_request_data)
        subject = req.get_subject()
        cert_name = dict(subject.get_components())['CN']
    except:
        return { "error": _("Error parsing the uploaded certificate request") }

    # Check the certificate name
    cert_name = generate_filename(cert_name)
    if Certificate.check_if_certificate_exist(cert_name):
        cert_name = "%s-%s" % (cert_name, int(time.time())) # generate an unique name

    # Create a file for the certificate request
    req_filename = os.path.join(CA_CERTS_DIR, cert_name + 'req.csr')
    f = file(req_filename, 'w+')
    f.write(certificate_request_data)
    f.close()

    revoke_old_certificate = to_bool(revoke_old_certificate)

    # Create the certificate
    try:
        try:
            auth_client.sign_certificate_request(cert_name=cert_name, cert_days=certificate_request_validity, cert_type=cert_type, cert_start_date=cert_start_date, revoke_old_certificate=revoke_old_certificate)
            common_name = Certificate.get_by_name(cert_name).common_name
            filename = "%scert.pem" % cert_name
            return { "info": _("Certificate request signed"), "cert_name": cert_name, "cert_filename": filename, "common_name": common_name }
        except Exception, ex:
            error(str(ex), exc_info=True)
            return { "error": str(ex) }
    finally:
        # Delete the certificate request
        try:
            os.unlink(req_filename)
        except:
            pass

@commands.force_json_output
def create_certificate(cert_name, cert_email="", cert_ou="", cert_organization="",
                       cert_city="", cert_state="", cert_country="", cert_subjectaltname="",
                       cert_password="", cert_days="", cert_type="", cert_filename="",
                       cert_start_date="", cert_digest=DEFAULT_DIGEST):
    """
        Create a new certificate

        :param cert_name: CN = CommonName
        :type cert_name: string
        :param cert_email: Email address
        :type cert_ou: string
        :param cert_organization: OU = Organization Unit typically certificate type
        :type cert_organization: string
        :param cert_city: L = Locality; generally - city
        :type cert_city: string
        :param cert_state: ST = state or province
        :type cert_state: string
        :param cert_country: C = ISO3166 two character country code
        :type cert_country: string
        :param cert_subjectaltname:
        :type cert_subjectaltname: string
        :param cert_password: certificate password
        :type cert_password: string
        :param cert_days: default certificate validity in days
        :type cert_days: string or int
        :param cert_type: optional certificate type (check CERT_TYPE_OPTIONS for valid options)
        :type cert_type: string
        :param cert_filename: certificate file name (equals to cert_name if empty)
        :type cert_filename: string
        :param cert_start_date: optional certificate validity notBefore
        :type cert_start_date: string in YYMMDDHHMMSSZ format
        :param cert_digest: digest algorithm
        :type cert_digest: string
    """
    try:
        result = auth_client.create_certificate(cert_name=cert_name, cert_email=cert_email, cert_ou=cert_ou, cert_organization=cert_organization,
                                                cert_city=cert_city, cert_state=cert_state, cert_country=cert_country, cert_subjectaltname=cert_subjectaltname,
                                                cert_password=cert_password, cert_days=cert_days, cert_type=cert_type, cert_filename=cert_filename,
                                                cert_start_date=cert_start_date, cert_digest=cert_digest)
        common_name = cert_name
        cert_name = os.path.basename(result['p12_filename']).replace('cert.p12','').replace('.p12','')
        filename = "%scert.pem" % cert_name
        return { "info": _("Certificate generated"), "cert_name": cert_name, "cert_filename": filename, "common_name": common_name }
    except Exception, ex:
        msg = str(ex)
        if msg.startswith("AuthException:"):
            msg = msg[14:]
        error(str(ex), exc_info=True)
        return { "error": msg }

@commands.force_json_output
def verify_certificate(cert_id):
    """
        Verify a certificate

        :param cert_id: certificate name
        :type cert_id: string
    """
    try:
        if cert_id.endswith('cert.pem'):
            cert_id = cert_id[:-8]
        verify = auth_client.verify_certificate(cert_id)
        return verify
    except Exception, ex:
        msg = str(ex)
        if msg.startswith("AuthException:"):
            msg = msg[14:]
        return { "error": msg }

@commands.force_json_output
def revoke_certificate(cert_id):
    """
        Revoke a certificate

        :param cert_id: certificate name
        :type cert_id: string
    """
    try:
        if cert_id.endswith('cert.pem'):
            cert_id=cert_id[:-8]
        result = auth_client.revoke_certificate(cert_id)
        if result.get('action') == 'delete':
            return { "info": _("Certificate deleted") }
        else:
            emit_crl_changed() # Force CRLs reloading
            return { "info": _("Certificate revoked") }
    except Exception, ex:
        msg = str(ex)
        if msg.startswith("AuthException:"):
            msg = msg[14:]
        return { "error": msg }

@commands.force_json_output
def upload_crl(crl_data):
    """
        Install a CRL
        Usage example:
        curl -k 'https://.../manage/commands/commands.ca.uploadCrl' --data-urlencode crl_data@<FILENAME>

        :param crl_data: CRL content (PEM or DER)
        :type crl_data: string
    """
    from OpenSSL import crypto
    try:
        try:
            crl = crypto.load_crl(crypto.FILETYPE_PEM, crl_data)
            crl_format = crypto.FILETYPE_PEM
        except crypto.Error:
            try:
                crl = crypto.load_crl(crypto.FILETYPE_ASN1, crl_data)
                crl_format = crypto.FILETYPE_ASN1
            except crypto.Error:
                crl_data = ''.join([chr(ord(x)) for x in crl_data]) # unicode -> bytes
                crl = crypto.load_crl(crypto.FILETYPE_ASN1, crl_data)
                crl_format = crypto.FILETYPE_ASN1
        issuer = crl.get_issuer()
        c = dict(issuer.get_components())
        for key in ['CN', 'OU', 'O']:
            if key in c:
                crl_name = c[key]
                break
        if not crl_name:
            raise crypto.Error()
    except crypto.Error, ex:
        error(str(ex), exc_info=True)
        return { "error": _("Not a valid CRL") }

    # Check if the CA for this CRL exist
    if (CertificateAuthority.get_by_name(crl_name)) is None:
        return { "error": _("CA does not exist. Please upload the CA before the certificate revocation list.") }

    # Check if the CRL already exist
    existing_crl = CRL.get_by_name(crl_name)
    if existing_crl is not None:
        if existing_crl.last_update is not None and existing_crl.last_update >= parse_asn1time(crl.get_lastUpdate()):
            return { "error": _("A newer version of the CRL already exist.") }

    # Save the CRL
    try:
        crl_filename = os.path.join(CA_CRLS_DIR, "%s.crl" % crl_name)
        if crl_format == crypto.FILETYPE_ASN1:
            # Convert DER(ASN.1) to PEM
            temp_filename = os.path.join(CA_CRLS_DIR, "%s.tmp" % crl_name)
            try:
                f = open(temp_filename, 'w+')
                f.write(crl_data)
                f.close()
                subprocess.call([OPENSSL_BIN, "crl", "-in", temp_filename, "-inform", "DER", "-out", crl_filename, "-outform", "PEM"])
            finally:
                try:
                    os.unlink(temp_filename)
                except:
                    pass
        else:
            f = open(crl_filename, 'w+')
            f.write(crl_data)
            f.close()
    except Exception:
        return {"error": _("CRL file creation failed") }

    # Create the symlink
    auth_client.create_crl_hash_symlink(crl_name)

    # Force CRLs reloading
    emit_crl_changed()
    return { "info": _("Certificate revocation list uploaded"), "crl_name": crl_name }

@commands.force_json_output
def get_common_names():
    """
        Return the list of the certificates common names
    """
    return sorted(set([x.common_name for x in Certificate.all()]))

@commands.force_json_output
def get_file_names():
    """
        Return the list of the certificates file names
    """
    try:
        return sorted([os.path.basename(x) for x in glob.glob(os.path.join(CA_CERTS_DIR, "*cert.pem"))])
    except:
        return []

def download_crl(cert_id):
    """
        Download a CRL

        :param cert_id: crl name
        :type cert_id: string
    """
    try:
        if not cert_id.endswith('.crl'):
            cert_id = cert_id + '.crl'
        return CRL.get_by_id(cert_id).crl
    except Exception:
        return { "error": "Not found" }

def download_certificate(cert_id):
    """
        Download a certificate

        :param cert_id: certificate name
        :type cert_id: string
    """
    try:
        if not cert_id.endswith('cert.pem'):
            cert_id = cert_id + 'cert.pem'
        return Certificate.get_by_id(cert_id).pem
    except Exception:
        return { "error": "Not found" }

@commands.force_json_output
def recreate_hash_symlinks():
    """
       Recreate all the CAs, certificates, and CRLs hash symlinks
    """
    try:
        return auth_client.recreate_hash_symlinks()
    except Exception, ex:
        return { "error": str(ex) }

commands.registerCommand('commands.ca.createCertificateAuthority', create_certificate_authority)
commands.registerCommand('commands.ca.uploadCertificate', upload_certificate)
commands.registerCommand('commands.ca.downloadCertificate', download_certificate)
commands.registerCommand('commands.ca.uploadCertificateRequest', upload_certificate_request)
commands.registerCommand('commands.ca.verifyCertificate', verify_certificate)
commands.registerCommand('commands.ca.revokeCertificate', revoke_certificate)
commands.registerCommand('commands.ca.createCertificate', create_certificate)
commands.registerCommand('commands.ca.uploadCrl', upload_crl)
commands.registerCommand('commands.ca.downloadCrl', download_crl)
commands.registerCommand('commands.ca.getCommonNames', get_common_names)
commands.registerCommand('commands.ca.getFileNames', get_file_names)
commands.registerCommand('commands.ca.recreateHashSymlinks', recreate_hash_symlinks)
