#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import subprocess
import pyasn1.type.univ
assert(pyasn1.type.univ)
from pyasn1.codec.ber import decoder

from endian.core.pdict import PersistentDict
from endian.emi.storage.directorystorage import DirectoryStorage, DirectoryCacheEntry

from endian.authentication.handlers.ca import CERT_TYPE_OPTIONS, CA_PRIVATE_DIR, CA_CRLS_DIR, CA_CERTS_STATUS
from endian.ca.common import parse_asn1time, OPENSSL_BIN

__all__ = [
    'CertificateDirectoryStorage',
    'CertificateAuthorityDirectoryStorage',
    'CRLDirectoryStorage',
]

certs_status = PersistentDict(CA_CERTS_STATUS)

class CertificateDirectoryCacheEntry(DirectoryCacheEntry):
    file_filter = "*cert.pem"

    def _get_name(self, info):
        return info['ID'][:-8]

    def _get_p12_filename(self, info):
        return info['path'][:-8] + ".p12"

    def _get_key_filename(self, info):
        return info['path'][:-8] + "key.pem"

    def _get_certificate(self, pem):
        from OpenSSL import crypto
        return crypto.load_certificate(crypto.FILETYPE_PEM, pem)

    def _get_subject(self, cert):
        subject = cert.get_subject()
        if not subject:
            return ""
        components = []
        for k,v in subject.get_components():
            components.append("%s=%s" % (k,v))
        return " ".join(components)

    def _get_common_name(self, cert):
        subject = cert.get_subject()
        if not subject:
            return ""
        c = dict(subject.get_components())
        for key in ['CN', 'OU', 'O']:
            if key in c:
                return c[key]
        return "" # :-(

    def _get_serial(self, cert):
        return cert.get_serial_number()

    def _get_issuer(self, cert):
        issuer = cert.get_issuer()
        if not issuer:
            return ""
        components = []
        for k,v in issuer.get_components():
            components.append("%s=%s" % (k,v))
        return " ".join(components)

    def _get_issuer_common_name(self, cert):
        issuer = cert.get_issuer()
        if not issuer:
            return ""
        return dict(issuer.get_components()).get('CN', "")

    def _get_type(self, cert):
        try:
            ext = [cert.get_extension(i) for i in range(0, cert.get_extension_count()) if cert.get_extension(i).get_short_name() == 'nsCertType'][0]
            data = decoder.decode(ext.get_data())[0]
            return [CERT_TYPE_OPTIONS[i] for i in range(0, min(len(CERT_TYPE_OPTIONS), len(data))) if data[i]]
        except:
            return []

    def _not_before(self, cert):
        return parse_asn1time(cert.get_notBefore())

    def _not_after(self, cert):
        return parse_asn1time(cert.get_notAfter())

    def _has_expired(self, cert):
        return cert.has_expired and True or False

    def _get_text(self, path):
        return subprocess.Popen([OPENSSL_BIN, "x509", "-text", "-in", path], stdout=subprocess.PIPE).communicate()[0]

    def parse_file_for_cache(self, info):
        info['name'] = self._get_name(info)
        info['pem_filename'] = info['path']
        info['p12_filename'] = self._get_p12_filename(info)
        info['key_filename'] = self._get_key_filename(info)

        pem = self.read_file(info['pem_filename'])
        if not pem:
            return info
        cert = self._get_certificate(pem)
        if not cert:
            return info

        info['subject'] = self._get_subject(cert)
        info['common_name'] = self._get_common_name(cert)
        info['serial'] = self._get_serial(cert)
        info['issuer'] = self._get_issuer(cert)
        info['issuer_common_name'] = self._get_issuer_common_name(cert)

        info['cert_type'] = self._get_type(cert)

        info['not_before'] = self._not_before(cert)
        info['not_after'] = self._not_after(cert)

        del cert
        del pem

        return info

    def parse_file_always(self, info):
        info['has_pem'] = os.path.exists(info['pem_filename'])
        info['has_p12'] = os.path.exists(info['p12_filename'])
        info['has_key'] = os.path.exists(info['key_filename'])
        info['status'] = certs_status.get(info['name'])
        info['has_type_server'] = "server" in info['cert_type'] and True or False
        info['has_type_client'] = "client" in info['cert_type'] and True or False
        return info

    def parse_file(self, info):
        pem = self.read_file(info['pem_filename'])
        cert = self._get_certificate(pem)
        info['has_expired'] = self._has_expired(cert)

        info['text'] = self._get_text(info['pem_filename'])

        del cert
        del pem

        return info

class CertificateDirectoryStorage(DirectoryStorage):
    """
    Load/store files from/to directory.
    """
    cache_entry_class = CertificateDirectoryCacheEntry

    def delete(self, id=None, check_acl=True):
        raise Exception("This storage does not support delete.")

class CertificateAuthorityDirectoryCacheEntry(CertificateDirectoryCacheEntry):
    file_filter = "*cert.pem"

    def _get_key_filename(self, info):
        return os.path.join(CA_PRIVATE_DIR, info['ID'][:-8] + "key.pem")

    def _get_crl_filename(self, info):
        return os.path.join(CA_CRLS_DIR, info['ID'][:-8] + "crl.pem")

    def parse_file_for_cache(self, info):
        info = super(CertificateAuthorityDirectoryCacheEntry, self).parse_file_for_cache(info)
        info['crl_filename'] = self._get_crl_filename(info)
        return info

    def parse_file_always(self, info):
        info = super(CertificateAuthorityDirectoryCacheEntry, self).parse_file_always(info)
        info['has_crl'] = os.path.exists(info['crl_filename'])
        return info

    def parse_file(self, info):
        info = super(CertificateAuthorityDirectoryCacheEntry, self).parse_file(info)
        return info


class CertificateAuthorityDirectoryStorage(DirectoryStorage):
    """
    Load/store files from/to directory.
    """
    cache_entry_class = CertificateAuthorityDirectoryCacheEntry


class CRLDirectoryCacheEntry(DirectoryCacheEntry):
    file_filter = "*.crl"

    def _get_name(self, info):
        return info['ID'][:-4]

    def _get_crl(self, crl):
        from OpenSSL import crypto
        return crypto.load_crl(crypto.FILETYPE_PEM, crl)

    def _get_issuer(self, crl):
        issuer = crl.get_issuer()
        if not issuer:
            return ""
        components = []
        for k,v in issuer.get_components():
            components.append("%s=%s" % (k,v))
        return " ".join(components)

    def _get_last_update(self, crl):
        return parse_asn1time(crl.get_lastUpdate())

    def _get_next_update(self, crl):
        return parse_asn1time(crl.get_nextUpdate())

    def _get_text(self, path):
        return subprocess.Popen([OPENSSL_BIN, "crl", "-text", "-noout", "-in", path], stdout=subprocess.PIPE).communicate()[0]

    def parse_file_for_cache(self, info):
        info['name'] = self._get_name(info)
        info['crl_filename'] = info['path']

        pem = self.read_file(info['crl_filename'])
        if not pem:
            return info
        crl = self._get_crl(pem)
        if not crl:
            return info
        info['issuer'] = self._get_issuer(crl)
        info['last_update'] = self._get_last_update(crl)
        info['next_update'] = self._get_next_update(crl)
        return info

    def parse_file_always(self, info):
        info['has_crl'] = os.path.exists(info['crl_filename'])
        return info

    def parse_file(self, info):
        info['text'] = self._get_text(info['crl_filename'])
        return info

class CRLDirectoryStorage(DirectoryStorage):
    """
    Load/store files from/to directory.
    """
    cache_entry_class = CRLDirectoryCacheEntry

    def delete(self, id=None, check_acl=True):
        raise Exception("This storage does not support delete.")
