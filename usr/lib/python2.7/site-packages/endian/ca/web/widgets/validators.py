#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import re
from endian.core.i18n import _
from endian.core import logger
from endian.validators.core import Invalid, Schema, FormValidator, UnicodeString, Int, Email
from endian.datatypes import network

from endian.ca.common import is_demo, DEMO_TEXT

__all__ = [
    "HostnameUnicodeString",
    "CertificateUnicodeString",
    "CertificateCommonName",
    "SubjectAltName",
    "CreateCertificateSchema",
    "CreateCertificateAuthoritySchema",
    "CertificateValidator"
]

class HostnameUnicodeString(UnicodeString):
    """
    Hostname must be a valid fully qualified domain name or ip address
    """
    messages = {
        'invalid': _("Invalid hostname - must be a valid fully qualified domain name or an IP address")
    }

    re_allowed = re.compile("(?!-)[A-Z\d-]{1,63}(?<!-)$", re.IGNORECASE)

    def is_valid_fqdn(self, hostname):
        if hostname.startswith('*.'):
            hostname = hostname[2:]
        for part in hostname.split("."):
            if not self.re_allowed.match(part):
                return False
        return True

    def is_valid_ipv4(self, ip):
        try:
            network.IPAddress(ip)
            return True
        except:
            return False

    def validate_python(self, value, state):
        if not self.is_valid_fqdn(value) and not self.is_valid_ipv4(value):
            raise Invalid(self.message('invalid', state), value, state)
        return value


class CertificateCommonName(UnicodeString):
    # See RFC 5280
    # X520CommonName ::= CHOICE {
    #       teletexString     TeletexString   (SIZE (1..ub-common-name)),
    #       printableString   PrintableString (SIZE (1..ub-common-name)),
    #       universalString   UniversalString (SIZE (1..ub-common-name)),
    #       utf8String        UTF8String      (SIZE (1..ub-common-name)),
    #       bmpString         BMPString       (SIZE (1..ub-common-name)) }

    def validate_python(self, value, state):
        if value:
            value = value.strip()
        return value


class CertificateUnicodeString(UnicodeString):
    # See RFC 5280
    # X520LocalityName, etc.. ::= CHOICE {
    #       teletexString     TeletexString   (SIZE (1..ub-common-name)),
    #       printableString   PrintableString (SIZE (1..ub-common-name)),
    #       universalString   UniversalString (SIZE (1..ub-common-name)),
    #       utf8String        UTF8String      (SIZE (1..ub-common-name)),
    #       bmpString         BMPString       (SIZE (1..ub-common-name)) }

    def validate_python(self, value, state):
        if value:
            value = value.strip()
        return value


class SubjectAltName(UnicodeString):

    messages = {
        'invalid_chars': _("SubjectAltName is a comma separated list of email, dns, uri, rid and IP objects. <br/>"
                           "email:an email address. Syntax email:copy takes the email field from the cert to be used. <br/>"
                           "DNS:a valid domain name. URI:any valid uri. <br/>"
                           "RID:registered object identifier. <br/>"
                           "IP:an IP address. <br/>"
                           "Note:charset is limited and case is significant. <br/>"
                           "Example: <br/>"
                           "email:user@yourmail.com,email:copy, DNS:www.yourdomain.com, IP:127.0.0.1, URI:http://url/to/something"),
    }

    re_valid_chars = re.compile(r'^(email|URI|DNS|RID|IP):[a-zA-Z0-9 :\/,\.\-_@]*$')

    def validate_python(self, value, state):
        if not self.re_valid_chars.match(value):
            raise Invalid(self.message('invalid_chars', state), value, state)
        return value

class CreateCertificateSchema(Schema):
    allow_extra_fields = True

    new_cert_name = CertificateCommonName(not_empty=True, max=60)
    new_cert_email = Email(not_empty=False)
    new_cert_ou = CertificateUnicodeString(not_empty=False, max=60)
    new_cert_organization = CertificateUnicodeString(not_empty=False)
    new_cert_city = CertificateUnicodeString(not_empty=False)
    new_cert_state = CertificateUnicodeString(not_empty=False)
    new_cert_country = CertificateUnicodeString(not_empty=True)
    new_cert_subjectaltname = SubjectAltName(not_empty=False)
    new_cert_days = Int(not_empty=False, min=1)
    new_cert_password = UnicodeString(not_empty=True, min=5)
    new_cert_password_confirm = UnicodeString(not_empty=True, min=5)
    new_cert_type = CertificateUnicodeString(not_empty=False)

class CreateCertificateAuthoritySchema(Schema):
    allow_extra_fields = True

    new_cert_name = HostnameUnicodeString(not_empty=True, max=60) # hostname
    new_cert_email = Email(not_empty=False)
    new_cert_ou = CertificateUnicodeString(not_empty=False, max=60)
    new_cert_organization = CertificateUnicodeString(not_empty=True)
    new_cert_city = CertificateUnicodeString(not_empty=False)
    new_cert_state = CertificateUnicodeString(not_empty=False)
    new_cert_country = CertificateUnicodeString(not_empty=True)
    new_cert_subjectaltname = SubjectAltName(not_empty=False)
    new_cert_days = Int(not_empty=False, min=1)

class CertificateValidator(FormValidator):
    """
    Validator for certificate options
    """

    select_name = None

    messages = {
        'upload_cert': not is_demo() and _("Missing certificate") or _("Uploading certificates not allowed"),
        'upload_cert_req':  not is_demo() and _("Missing certificate signing request") or _("Uploading certificate signing requests not allowed"),
        'missing_value': _("Please enter a value")
    }

    re_secret = re.compile(r'[\'",&]')

    def __init__(self, select_name, *args, **kws):
        self.select_name = select_name
        super(CertificateValidator, self).__init__(*args, **kws)

    def _to_python(self, value_dict, state):
        cert_option = value_dict.get(self.select_name)
        if cert_option in ['new_cert', 'upload_cert', 'upload_cert_req'] and is_demo():
            error_dict = {
                'upload_cert': self.message('upload_cert', state),
                'upload_cert_req': self.message('upload_cert_req', state)
            }
            raise Invalid(DEMO_TEXT, value_dict, state, error_dict=error_dict)
        if cert_option == 'new_cert': # Generate a new certificate
            logger.debug("Generate a new certificate")
            cert_values = CreateCertificateSchema.to_python(value_dict)
            logger.debug("%s" % cert_values)
        elif cert_option == 'upload_cert': # Upload a certificate
            logger.debug("Upload certificate")
            upload_cert = value_dict.get('upload_cert', None)
            data = upload_cert is not None and upload_cert.file.read() or None
            if not data:
                error_dict = {
                    'upload_cert': self.message('upload_cert', state)
                }
                raise Invalid("", value_dict, state, error_dict=error_dict)
            value_dict['upload_cert_filename'] = upload_cert.filename
            value_dict['upload_cert_data'] = data
        elif cert_option == 'upload_cert_req': # Upload a certificate request
            logger.debug("Upload certificate request")
            upload_cert_req = value_dict.get('upload_cert_req', None)
            data = upload_cert_req is not None and upload_cert_req.file.read() or None
            if not data:
                error_dict = {
                    'upload_cert_req': self.message('upload_cert_req', state)
                }
                raise Invalid("", value_dict, state, error_dict=error_dict)
            value_dict['upload_cert_req_filename'] = upload_cert_req.filename
            value_dict['upload_cert_req_data'] = data
        return value_dict
