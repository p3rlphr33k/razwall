#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from endian.core.i18n import _
from endian.core import logger
from endian.emi import controllers
from endian.emi.framework import response
from endian.data import DataSource
from endian.ca import commands
from endian.ca.common import generate_filename, is_demo, DEMO_TEXT, DEFAULT_DIGEST
from endian.ca.schema import Certificate, CertificateAuthority
from endian.ca.web.widgets.ca import CertificateInfoWidget

__all__ = [
    "root_ca_exists",
    "BaseCertificateSettingsController",
    "BaseCertificateGridController",
    "DEFAULT_DIGEST"
]

def root_ca_exists():
    return CertificateAuthority.get_by_id("cacert.pem") is not None

def _get_certificate_info(id):
    certificate = Certificate.get_by_id(id)
    if certificate:
        verify = commands.verify_certificate(certificate.name)
    else:
        verify = { 'valid': False, 'output': '' }
    return {
        'text': certificate and certificate.text or _('Could not read certificate'),
        'valid': verify['valid'],
        'valid_output': verify['output'],
    }

def _on_store(cert_option, data, filename_field=None):
    if cert_option in ['new_cert', 'upload_cert', 'upload_cert_req'] and is_demo():
        vargs = data.copy()
        vargs['error'] = DEMO_TEXT
        return vargs
    if cert_option == 'new_cert':
        if not root_ca_exists():
            vargs = data.copy()
            vargs['error'] = '<a style="color: #fff;" href="/manage/ca/certificate_authority/">%s</a>' % \
                _("Root certificate authority does not exist. Please create the root CA before creating certificates.")
            return vargs

        if Certificate.check_if_certificate_exist(data.get('new_cert_name')):
            vargs = data.copy()
            vargs['error'] = _("A certificate with the same name already exist")
            return vargs

        # Create new certificate
        result = commands.create_certificate(cert_name=data["new_cert_name"],
            cert_filename=generate_filename(data["new_cert_name"]),
            cert_email=data["new_cert_email"],
            cert_ou=data["new_cert_ou"],
            cert_organization=data["new_cert_organization"],
            cert_city=data["new_cert_city"],
            cert_state=data["new_cert_state"],
            cert_country=data["new_cert_country"],
            cert_subjectaltname=data["new_cert_subjectaltname"],
            cert_password=data["new_cert_password"],
            cert_days=data["new_cert_days"],
            cert_type=data["new_cert_type"],
            cert_digest=data["new_cert_digest"])
        logger.debug("Generate certificate: %s" % str(result))
        if 'error' in result:
            logger.error(result['error'])
            data['error'] = result['error']
        elif filename_field:
            data[filename_field] = result['cert_filename']
        if 'info' in result:
            data['info'] = result['info']
    elif cert_option == 'upload_cert':
        # Upload certificate
        result = commands.upload_certificate(
            certificate_data=data['upload_cert_data'],
            certificate_password=data['upload_cert_password'])
        logger.debug("Upload certificate: %s" % str(result))
        if 'error' in result:
            logger.error(result['error'])
            data['error'] = result['error']
        elif filename_field:
            data[filename_field] = result['cert_filename']
        if 'info' in result:
            data['info'] = result['info']
    elif cert_option == 'upload_cert_req':
        # Upload certificate request
        result = commands.upload_certificate_request(
            certificate_request_data=data['upload_cert_req_data'],
            certificate_request_validity=data['upload_cert_req_days'])
        logger.debug("Upload certificate request: %s" % str(result))
        if 'error' in result:
            logger.error(result['error'])
            data['error'] = result['error']
        elif filename_field:
            data[filename_field] = result['cert_filename']
        if 'info' in result:
            data['info'] = result['info']
    return data

class BaseCertificateSettingsController(controllers.SettingsController):
    cert_option_field = None
    filename_field = None

    certificate_info_widget = CertificateInfoWidget()

    def __init__(self, *args, **vargs):
        if not self.cert_option_field:
            raise Exception("BaseCertificateController.cert_option_field not defined")
        return super(BaseCertificateSettingsController, self).__init__(*args, **vargs)

    @controllers.expose(content_type="application/x-download")
    def pem(self, **args):
        """ Return the certificate pem file """
        response.headers["Content-Disposition"] = 'attachment; filename="%s"' % args['ID']
        try:
            return Certificate.get_by_id(args['ID']).pem
        except:
            return ""

    @controllers.expose(content_type="application/x-pkcs12")
    def p12(self, **args):
        """ Return the certificate p12 file """
        response.headers["Content-Disposition"] = 'attachment; filename="%s"' % args['ID'].replace(".pem", ".p12")
        try:
            return Certificate.get_by_id(args['ID']).p12
        except:
            return ""

    @controllers.expose(template="endian.emi.templates.basecontroller")
    def info(self, **args):
        """ Return the certificate detailed info """
        result = { 'args': { 'data': '' },
                   'container': self.certificate_info_widget,
                   'controllername': 'grid'}
        try:
            data = _get_certificate_info(args['ID'])
            result['args']['data'] = data
        except Exception, ex:
            logger.error(str(ex), exc_info=True)
            result['error'] = _("Not found")
        return result

    def onStore(self, data):
        cert_option = data.get(self.cert_option_field)
        return _on_store(cert_option=cert_option, data=data, filename_field=self.filename_field)

class BaseCertificateGridController(controllers.GridController):
    cert_option_field = None
    filename_field = None
    actions = controllers.GridController.actions + ["delete_private_key"]

    certificate_info_widget = CertificateInfoWidget()

    def __init__(self, *args, **vargs):
        if not self.cert_option_field:
            raise Exception("BaseCertificateController.cert_option_field not defined")
        return super(BaseCertificateGridController, self).__init__(*args, **vargs)

    @controllers.expose(content_type="application/x-download")
    def pem(self, **args):
        """ Return the certificate pem file """
        response.headers["Content-Disposition"] = 'attachment; filename="%s"' % args['ID']
        try:
            return Certificate.get_by_id(args['ID']).pem
        except:
            return ""

    @controllers.expose(content_type="application/x-pkcs12")
    def p12(self, **args):
        """ Return the certificate p12 file """
        response.headers["Content-Disposition"] = 'attachment; filename="%s"' % args['ID'].replace(".pem", ".p12")
        try:
            return Certificate.get_by_id(args['ID']).p12
        except:
            return ""

    @controllers.expose(template="endian.emi.templates.basecontroller")
    def info(self, **args):
        """ Return the certificate detailed info """
        result = { 'args': { 'data': '' },
                   'container': self.certificate_info_widget,
                   'controllername': 'grid'}
        try:
            data = _get_certificate_info(args['ID'])
            result['args']['data'] = data
        except Exception, ex:
            logger.error(str(ex), exc_info=True)
            result['error'] = _("Not found")
        return result

    def onStore(self, id, data):
        cert_option = data.get(self.cert_option_field)
        return _on_store(cert_option=cert_option, data=data, filename_field=self.filename_field)

    def onNew(self, id, data):
        """
        Triggered before starting to edit a new item
        """
        DS = DataSource()
        try:
            data["new_cert_country"] = DS.VPN.SETTINGS.ROOTCERT_COUNTRY
        except:
            pass
        try:
            data["new_cert_organization"] = DS.VPN.SETTINGS.ROOTCERT_ORGANIZATION
        except:
            pass
        data["new_cert_type"] = "client"
        data["new_cert_digest"] = DEFAULT_DIGEST
        return data

    def delete_private_key(self, **args):
        """
           Delete the private key and the p12
        """
        error = []
        empty = True
        idlist = []
        for raw_id in self.to_list(args.get("ID", args.get("ID[]", ""))):
            try:
                id = raw_id or ""
                try: # convert int ids into int
                    id = int(id)
                except:
                    logger.debug("id is not int")
                idlist.append(id)
            except Exception, e:
                error.append("%s " % e)
        for id in idlist:
            try:
                empty = False
                item = self.storage.load(id=id)
                item.delete_private_key()
            except Exception, e:
                error.append("%s " % e)
        if empty:
            error.append(_("You have to choose at least one element"))
        if error:
            args['error'] = "<br />".join(error)
        return args
