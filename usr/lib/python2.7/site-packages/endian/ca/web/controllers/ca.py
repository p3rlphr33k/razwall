#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import subprocess

from endian.core.i18n import _
from endian.core.logger import error
from endian.core.settingsfile import SettingsFile
from endian.validators.core import Invalid
from endian.emi import controllers
from endian.emi.framework import response

from endian.ca import commands
from endian.ca.common import chown, \
    chgrp, \
    is_demo, \
    DEMO_TEXT, \
    OPENSSL_BIN, \
    DEFAULT_DIGEST
from endian.authentication.handlers.ca import CA_CACERTS_DIR, \
    CA_CRL, \
    CA_CRLS_DIR, \
    CA_INDEX, \
    CA_CA
from endian.ca.schema import CertificateAuthority
from endian.ca.web.widgets.ca import CreateCertificateAuthoritySettings, \
    CertificateAuthorityGrid, \
    CertificateInfoWidget
from endian.ca.web.widgets.validators import CreateCertificateAuthoritySchema
from endian.ca.web.controllers.common import root_ca_exists

__all__ = [
    "CreateCertificateAuthorityController",
    "CertificateAuthorityController",
]

VPN_SETTINGS = "/var/efw/vpn/settings"
DEFAULT_CERT_TYPE = "client"

class CreateCertificateAuthorityController(controllers.SettingsController):
    settingsWidget = CreateCertificateAuthoritySettings

    def index_internal(self, **args):
        if not args.get("new_cert_digest"):
            args["new_cert_digest"] = DEFAULT_DIGEST
        # args['cert_name'] = get current host name or ip
        if root_ca_exists():
            return { 'error': _("Root certificate already exists."),
                     'controllername': 'create_certificate_authority' }
        return controllers.SettingsController.index_internal(self, **args)

    def process(self, **args):
        action = args.get("ACTION")
        if action == "store":
            args = self.create_certificate_authority(**args)
        if not 'info' in args:
            args['info'] = _("WARNING: Generating the root and host certificates may take a long time.")
            args['controllername'] = 'create_certificate_authority'
        return args

    def create_certificate_authority(self, **args):
        # Validate form fields
        try:
            vargs = args.copy()
            vargs = self.settingsWidget.validate(vargs)
        except Invalid, i:
            args["ACTION"] = "edit"
            self.error(args, i)
            return vargs

        if is_demo():
            return { "error": DEMO_TEXT }

        # Create the CA certificate
        ca_cert_name = "%s CA" % args.get('new_cert_organization')
        try:
            commands.create_certificate_authority(cert_name=ca_cert_name,
                cert_email=args.get('new_cert_email'),
                cert_ou=args.get('new_cert_ou'),
                cert_organization=args.get('new_cert_organization'),
                cert_city=args.get('new_cert_city'),
                cert_state=args.get('new_cert_state'),
                cert_country=args.get('new_cert_country'),
                cert_subjectaltname=args.get('new_cert_subjectaltname'),
                cert_days=args.get('new_cert_days'),
                cert_digest=args.get('new_cert_digest'),
                cert_filename="ca")
        except Exception, ex:
            vargs['error'] = hasattr(ex, 'message') and ex.message or str(ex)
            vargs['controllername'] = 'create_certificate_authority'
            return vargs

        # Create the host certificate
        try:
            commands.create_certificate(cert_name=args.get('new_cert_name'),
                cert_email=args.get('new_cert_email'),
                cert_ou=args.get('new_cert_ou'),
                cert_organization=args.get('new_cert_organization'),
                cert_city=args.get('new_cert_city'),
                cert_state=args.get('new_cert_state'),
                cert_country=args.get('new_cert_country'),
                cert_subjectaltname=args.get('new_cert_subjectaltname'),
                cert_days=args.get('new_cert_days'),
                cert_digest=args.get('new_cert_digest'),
                cert_type="server")
        except Exception, ex:
            vargs['error'] = hasattr(ex, 'message') and ex.message or str(ex)
            vargs['controllername'] = 'create_certificate_authority'
            return vargs

        # Save the settings file
        d = SettingsFile(VPN_SETTINGS)
        d['ROOTCERT_HOSTNAME'] = args.get('new_cert_name')
        d['ROOTCERT_COUNTRY'] = args.get('new_cert_country')
        d['ROOTCERT_ORGANIZATION'] = args.get('new_cert_organization')
        d.write()
        chown(VPN_SETTINGS, "nobody")
        chgrp(VPN_SETTINGS, "nogroup")

        controllers.redirect('/manage/ca/certificate_authority/')

class CertificateAuthorityController(controllers.GridController):
    entity = CertificateAuthority

    gridWidget = CertificateAuthorityGrid

    do_store = False # we have a readonly storage
    do_delete = False # we have a readonly storage

    certificate_info_widget = CertificateInfoWidget()
    create_certificate_authority = CreateCertificateAuthorityController(schema=CreateCertificateAuthoritySchema)

    @controllers.expose(template="endian.ca.web.templates.certificate_authorities")
    def index(self, **args):
        result = self.index_internal(**args)
        result['root_ca_exists'] = root_ca_exists()
        return result

    @controllers.expose(content_type="application/x-download")
    def pem(self, **args):
        """ Return the certificate pem file """
        try:
            response.headers["Content-Disposition"] = 'attachment; filename="%s"' % args['ID']
            return CertificateAuthority.get_by_id(args['ID']).pem
        except:
            return ""

    @controllers.expose(content_type="application/x-download")
    def crl(self, **args):
        """ Return the certificate revokation list file """
        try:
            response.headers["Content-Disposition"] = 'attachment; filename="%s"' % args['ID'].replace(".pem", ".crl")
            return CertificateAuthority.get_by_id(args['ID']).crl
        except:
            return ""

    @controllers.expose(template="endian.emi.templates.basecontroller")
    def info(self, **args):
        """ Return the certificate detailed info """
        result = { 'args': { 'data': '' },
                   'container': self.certificate_info_widget,
                   'controllername': 'grid'}
        try:
            certificate = CertificateAuthority.get_by_id(args['ID'])
            data = {
                'text': certificate and certificate.text or _('Could not read CA certificate'),
                'valid': None,
                'valid_output': "",
            }
            result['args']['data'] = data
        except Exception, ex:
            error(str(ex), exc_info=True)
            result['error'] = _("Not found")
        return result

    def _upload_ca_certificate(self, **args):
        """ Upload CA certificate """
        if is_demo():
            return { "error": DEMO_TEXT }

        try:
            # Check the uploaded certificate
            upload_file = args.get('ca_file', None)
            data = upload_file is not None and upload_file.file.read() or None
            if not data:
                raise Exception(_("CA certificate is required"))
            try:
                parsed_ca = CertificateAuthority.parse_ca(data)
                cert_name = parsed_ca['cert_name']
                cert_format = parsed_ca['cert_format']
            except:
                raise Exception(_("Not a valid certificate"))
            if not parsed_ca['is_a_ca']:
                raise Exception(_("Not a valid CA certificate"))

            # Check if there is no other entry with the same name
            if CertificateAuthority.check_if_ca_already_exist(cert_name):
                raise Exception( _("A CA certificate with this name already exists"))

            # Save (or convert and save) the certificate
            try:
                from OpenSSL import crypto
                cert_filename = os.path.join(CA_CACERTS_DIR, "%scert.pem" % cert_name)
                if cert_format == crypto.FILETYPE_ASN1:
                    # Convert DER(ASN.1) to PEM
                    temp_filename = os.path.join(CA_CACERTS_DIR, "%scert.crt" % cert_name)
                    try:
                        f = open(temp_filename, 'w+')
                        f.write(data)
                        f.close()
                        subprocess.call([OPENSSL_BIN, "x509", "-in", temp_filename, "-inform", "DER", "-out", cert_filename, "-outform", "PEM"])
                    finally:
                        try:
                            os.unlink(temp_filename)
                        except:
                            pass
                else:
                    # Save the certificate
                    f = open(cert_filename, 'w+')
                    f.write(data)
                    f.close()
            except Exception, ex:
                raise Exception(_("Certificate file creation failed."))

            from endian.authentication.auth_client import create_ca_hash_symlink
            create_ca_hash_symlink(cert_name)

        except Exception, ex:
            vargs = args.copy()
            vargs['error'] = hasattr(ex, 'message') and ex.message or str(ex)
            return vargs

        return { "info": _("CA certificate uploaded") }

    def onDelete(self, ca_id, item):
        if is_demo():
            raise Exception(DEMO_TEXT)
        ca = CertificateAuthority.get_by_id(ca_id)
        if ca is None:
            raise Exception(_("CA certificate not found"))
        # Delete the ca certificate and the associated certificates
        ca.delete()
        # Delete the crl
        try:
            os.unlink(os.path.join(CA_CRLS_DIR, "%s.crl" % ca.name))
        except:
            pass
        try:
            os.unlink(CA_CRL)
        except:
            pass
        # Truncate the index file
        if ca.name == CA_CA:
            open(CA_INDEX,'w+').close()
        return True

