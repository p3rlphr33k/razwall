#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2008-01-12"
"""
Abstract class which defines implementatino of multiline
configuration files including config file handling and
insert/append default lines handling
"""

import types
from endian.datatypes.config_dict import ConfigDict
from endian.datatypes.config_list import ConfigList
import ConfigParser
import glob
import UserList
import UserDict
import fcntl
import os
from endian.data.interfaces import ContainerInterface
from endian.data.interfaces import ExpireableFile

_validators_eval_local_dict = None
_validators_cache = {}

class InvalidSettingsFile(Exception):
    pass
class ConfigFileParseError(Exception):
    pass

class SanitizedFile(file):
    def __init__(self, fname, mode='r'):
        file.__init__(self, fname, mode)
        lock = fcntl.LOCK_SH
        if mode != 'r':
            lock = fcntl.LOCK_EX
        fcntl.flock(self, lock)
    def next(self):
        return file.next(self).replace("\r","")

class AbstractConfigFile(ConfigList,
                         ContainerInterface,
                         ExpireableFile):
    def __init__(self, configfiles,
                 filename=None,
                 settingsDefault=None,
                 obj=None):
        ContainerInterface.__init__(self, filename)
        ExpireableFile.__init__(self, filename)
        self._fileData = {self.filename: {'status': ''}}
        self._settingsDefault = {}
        self._configfiles = configfiles
        if settingsDefault:
            self._settingsDefault = settingsDefault

        # read out config file if configfiles is not already a parsed config
        # object
        if isinstance(configfiles, ConfigParser.ConfigParser):
            self._config = configfiles
            self._configfiles = ''
        else:
            self._config = ConfigParser.ConfigParser(settingsDefault)
            try:
                self._config.read(self._configfiles)
            except (ConfigParser.MissingSectionHeaderError,
                    ConfigParser.ParsingError), e:
                raise InvalidSettingsFile("%s: %s"%(self._configfiles, e))

        self._defineFormat()
        self._defineValidators()
        self._defaultFiles = {
            'insert': {},
            'append': {},
            'default': {},
            }
        self._setDefaults()

        # if the type of obj does not allow to contain some
        # usable data read out the file
        if (type(obj) is not types.ListType
            and not isinstance(obj, UserList.UserList)):
            ConfigList.__init__(self)
            self.read()
            return

        # check if it is a simple list with unformatted
        # content
        ilist = map(lambda x: (isinstance(x, dict)
                               or isinstance(x, UserDict.UserDict)), obj)
        if len(obj) < 1 or False in ilist:
            ConfigList.__init__(self)
            if len(obj) > 0:
                self._parse(obj)
            self.read(onlyDefault=True)
            return

        # ok, it's a list of dictionaries, convert them
        # to ConfigDicts getting rid of default values
        insert = []
        append = []
        data = []
        try:
            insert = map(lambda x: ConfigDict(x), obj.defaultInsert)
        except AttributeError:
            pass
        try:
            append = map(lambda x: ConfigDict(x), obj.defaultAppend)
        except AttributeError:
            pass
        try:
            data = obj.data
        except AttributeError:
            data = obj
        objlist = map(lambda x: ConfigDict(x), data)
        ConfigList.__init__(self, objlist, insert, append)

    def _defineFormat(self):
        pass

    def _defineValidators(self):
        """
           Parse the validators configuration
        """
        self.validators = {}
        global _validators_eval_local_dict
        if not _validators_eval_local_dict:
            # Avoid recursive imports: datasource -> validators -> i18n -> datasource -> ...
            from endian.validators import get_all_validators
            _validators_eval_local_dict = get_all_validators()
        try:
            for name in self._config.options('validators'):
                if name not in ['user_d', 'state_d', 'persistent_d', 'prefix', 'base']:
                    v  = self._config.get('validators', name)
                    # Try to get the validator instance from the validators cache
                    validator = _validators_cache.get(v, None)
                    # Create the validator instance if it is not in the cache
                    if validator is None:
                        validator = eval(v, globals(), _validators_eval_local_dict)
                        if isinstance(validator, types.ClassType):
                            validator = validator()
                        _validators_cache[v] = validator
                    # Set the validator for this field
                    self.validators[name] = validator
        except (ConfigParser.NoOptionError, ConfigParser.NoSectionError):
            pass

    def _setDefaults(self):
        for section in self._config.sections():
            if section == 'config':
                continue

            includeType = ""
            try:
                includeType = self._config.get(section, 'includeType')
            except ConfigParser.NoOptionError:
                continue

            explodeSection = ""
            try:
                explodeSection = section % self._settingsDefault
            except KeyError:
                raise InvalidSettingsFile(
                    "%s: Section '%s' needs substitution for variable " % (
                        self._configfiles, section))

            if includeType not in self._defaultFiles:
                raise InvalidSettingsFile(
                    "%s: Invalid includeType '%s'. Must be "
                    "'insert' or 'append' or 'default'" % (
                        self._configfiles, includeType))
            for i in glob.glob(explodeSection):
                self._defaultFiles[includeType][i] = {'status': ''}

    def read(self, onlyDefault=False):
        parseRegistry = [
            {'files': self._fileData,
             'target': self.data, 'raiseError': True, 'default': False},
            {'files': self._defaultFiles['insert'],
             'target': self.defaultInsert, 'raiseError': False,
             'default': True},
            {'files': self._defaultFiles['append'],
             'target': self.defaultAppend, 'raiseError': False,
             'default': True}
            ]

        # if file does not exist, read the first default file if specified
        if (not self._fileData.keys()[0]
            or not os.access(self._fileData.keys()[0], os.F_OK)):
            df = self._defaultFiles['default']
            if len(df) > 0:
                selectfile = df.keys()
                selectfile.sort(reverse=True)
                self._fileData.clear()
                self._fileData[selectfile[0]] = df[selectfile[0]]
                parseRegistry[0]['default'] = True

        # read file, appending and inserting files
        for data in parseRegistry:
            if not data['default'] and onlyDefault:
                continue
            keys = data['files'].keys()
            keys.sort()
            for file in keys:
                if file is None:
                    continue
                try:
                    f = SanitizedFile(file)
                    try:
                        self._parse(f, data['target'])
                        data['files'][file]['status'] = 'OK'
                    except (IOError, ConfigFileParseError), e:
                        data['files'][file]['status'] = e
                        if data['raiseError']:
                            f.close()
                            raise ConfigFileParseError(e)
                    f.close()
                except IOError, e:
                    data['files'][file]['status'] = e
        ContainerInterface.read(self)

    def readDefaults(self):
        self.read(True)

    def _parse(self, obj, data=None):
        if data is None:
            data = self.data
        for row in obj:
            item = ConfigDict()
            item['line'] = row.strip()
            data.append(item)
