#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2008-01-02"
"""
plain text container for Endian datasource
"""
import os
from endian.core.cache import Expirer
from endian.core.cache import fsExpirer
from endian.data.exceptions import InvalidGetMethod
from endian.data.constants import constants, IGNORESUFFICES
from endian.core.filetools import openLocking as open
from endian.data.interfaces import ContainerInterface
from endian.data.interfaces import ExpireableFile
from endian.data.container.defaultresolver import DefaultResolver
from UserList import UserList

READFILEORDER = [
    {'base': 'USER_D', 'dir': '',
     'back': False, 'user': True, 'glob': False},
    {'base': 'STATE_D', 'dir': '',
     'back': False, 'user': False, 'glob': False},
    {'base': 'PERSISTENT_D', 'dir': 'default',
     'back': True, 'user': False, 'glob': True,
     'globprio': True},
    {'base': 'PROVISIONING_D', 'dir': 'default',
     'back': True, 'user': False, 'glob': False},
    {'base': 'USER_D', 'dir': 'default',
     'back': True, 'user': False, 'glob': False},
    {'base': 'STATE_D', 'dir': 'default',
     'back': True, 'user': False, 'glob': False},
]

class PlainFile(UserList,
                ContainerInterface,
                DefaultResolver,
                ExpireableFile):
    """Small interface to efw plain files,

    If the file does not exist, PlainFile loads from
    a number of default files:

    <STATE_D>/<path>
    <USER_D>/<path>
    <PROVISIONING_D>/<path>
    **<PERSISTENT_D>/dirname(<path>)/default/basename(<path>).*
    **<PERSISTENT_D>/dirname(<path>)/default/basename(<path>)
    **<STATE_D>/dirname(<path>)/default/basename(<path>)
    **<USER_D>/dirname(<path>)/default/basename(<path>)

    **: each path will be searched back the directory hierarchy
    for a default/vendor - directory which contains the searched
    file. Those files will be read out also and with precedence
    of it's hierarchy level.

    for example:
    PlainFile('ethernet/br0')
    reads:
    /var/lib/ethernet/settings
    /var/efw/ethernet/settings
    /var/emc/ethernet/settings
    /usr/lib/efw/ethernet/default/settings.*
    /usr/lib/efw/ethernet/default/settings
    /var/efw/ethernet/default/settings
    /var/lib/efw/ethernet/default/settings

    Meaning of directories:
    PERSISTENT_D: should contain only packaged files which will be
                 changed only when upgrading (default: /usr/lib/efw)
    STATE_D: should contain only files which the system creates. This
            way the system can override default values and/or
            the actual configuration (default: /var/lib/efw)
    USER_D: should contain only files the user created/modified
            (default: /var/efw)
    PROVISIONING_D: where the provisioning settings files are stored
            (defualt: /var/emc)

    default: contain files with default values packaged by the
             original package.
             vendor or product related default files can be
             done by creating files like settings.mybrand
    """
    def __init__(self, path, obj=None,
                 basePaths=constants,
                 readFileOrder=READFILEORDER,
                 filterSuffices=IGNORESUFFICES
                 ):

        UserList.__init__(self, obj)
        self._basePaths = basePaths.copy()

        # ensures backwards compatibility. SettingsFile has been instantiated
        # mostly supplying the full path which includes the known USER_D.
        # i.e: /var/efw/ethernet/settings /var/efw/ needs to be splitted away
        # in order to remain fully compatible to old style and allowing also
        # new style overrides using old style instantiation
        userdir = self._basePaths['USER_D'].rstrip('/')
        if userdir != '' and path.startswith(userdir):
            path = path[len(userdir):]
            path = path.lstrip('/')

        # class has been instantiated with an absolute path to the settingsfile
        # which however does not lie within USER_D. new style overrides will not
        # apply.
        if path.startswith('/'):
            filename = path
        else:
            filename = os.path.join(userdir, path)
        ContainerInterface.__init__(self, filename)
        ExpireableFile.__init__(self, filename)

        self._filterSuffices = filterSuffices
        self._readFileOrder = readFileOrder
        self._basename = os.path.basename(path)
        self._path = os.path.dirname(path)
        if self._path.startswith('/'):
            self._pathsplit = [self._path]
        else:
            self._pathsplit = self._path.split('/')
        if obj is None:
            self.read()

    def read(self):
        for (filename, isUser) in self._getReadFiles():
            f = None
            try:
                try:
                    f = open(filename)
                    data = map(lambda x: x.rstrip("\n\r"), f.readlines())
                    self.data = data
                    break
                except (IOError, OSError):
                    # pass to read the next file in list
                    pass
            finally:
                if f is not None:
                    f.close()
        ContainerInterface.read(self)

    def write(self, filename=None):
        if not filename:
            filename = self.filename
        f = None
        try:
            f = open(filename, "w")
            for line in self.data:
                f.write("%s\n"%line)
        finally:
            if f is not None:
                f.close()
        ContainerInterface.write(self, filename)

def getFileContent(filename, res):
    if 'filestatus' in res:
        raise InvalidGetMethod("File '%s' not found"%filename)
    if 'filecache' in res:
        return res['filecache']

    try:
        content = PlainFile(filename)
        res['filecache'] = content
        return content
    except (OSError, IOError):
        res['filestatus'] = "File '%s' not found"%filename
        raise InvalidGetMethod(res['filestatus'])

def fileExpirer(cache):
    obj = cache.get()
    return fsExpirer(obj.filename, cache.timestamp)
Expirer.register(fileExpirer, ExpireableFile)

