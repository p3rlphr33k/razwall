#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Simon Kirchner <simon@endian.com>"
__date__ = "2011-11-28"
"""
YAML container for Endian datasource
"""

from endian.datatypes.config_dict import ConfigDict
from endian.data.container.abstractconfig import InvalidSettingsFile
from endian.data.container.abstractconfig import ConfigFileParseError
from endian.data.container.abstractconfig import AbstractConfigFile
from endian.core.filetools import openLocking as open
import yaml
try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

__all__ = [
    'YamlFileException',
    'YamlConfigFile',
    'ConfigDict',
    'InvalidSettingsFile',
    'ConfigFileParseError',
    'AbstractConfigFile'
]

class YamlFileException(ConfigFileParseError):
    pass

class YamlConfigFile(AbstractConfigFile, object):
    def _prepare_dict(self, value, id):
        value = ConfigDict(value)
        value['ID'] = id
        return value

    def _parse(self, obj, data=None):
        if data is None:
            data = self.data

        # obj can be a endian.data.container.fileconfig.PlainFile or endian.data.container.abstractconfig.SanitizedFile instance
        if hasattr(obj, '_getReadFiles'): # PlainFile
            # here we don't use the read function of the plainFile because
            # we want the original file content, non splitted in lines
            fulldata = ''
            for (filename, isUser) in obj._getReadFiles():
                try:
                    with open(filename) as f:
                        fulldata = f.read()
                except:
                    pass
        else: # SanitizedFile
            fulldata = obj

        try:
            values = yaml.load(fulldata, Loader=Loader)
            keys = values.keys()
            keys.sort()
            result = []
            for key in keys:
                value = values[key]
                result.append(self._prepare_dict(value, key))
            data.extend(result)
        except ValueError, e:
            raise YamlFileException(e)
        except AttributeError, e:
            raise YamlFileException(e)

    def write(self, filename=None):
        if not filename:
            filename = self.filename
        if isinstance(self.data, dict):
            data = self.data
        else:
            data = {}
            for entry in self.data:
                id = entry['ID']
                entry = dict(entry)
                if 'id' in entry:
                    del entry['id']
                data[id] = entry
        data = yaml.dump(data, Dumper=Dumper)
        with open(filename, 'w') as f:
            f.write(data)
        AbstractConfigFile.write(self, filename)
