#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2008-01-09"
"""
settingsfile container for endian datasource
"""

import os
import pwd
import grp
from endian.datatypes.config_dict import ConfigDict
import string
import types
import UserDict
from endian.core.filetools import openLocking as open
from endian.data.interfaces import ContainerInterface
from endian.data.interfaces import ExpireableFile
from endian.data.container.defaultresolver import DefaultResolver
from endian.data.constants import constants, IGNORESUFFICES

__all__ = [
    'ConfigDict',
    'ContainerInterface',
    'ExpireableFile',
    'DefaultResolver',
    'constants',
    'SettingsException',
    'SettingsFile',
    'READFILEORDER',
]

class SettingsException(Exception):
    pass

READFILEORDER = [
    {'base': 'PERSISTENT_D', 'dir': 'default', 'back': True, 'user': False, 'glob': True},
    {'base': 'USER_D', 'dir': 'default', 'back': True, 'user': False, 'glob': False},
    {'base': 'PERSISTENT_D', 'dir': 'vendor', 'back': True, 'user': False, 'glob': False},
    {'base': 'USER_D', 'dir': 'vendor', 'back': True, 'user': False, 'glob': False},
    {'base': 'STATE_D', 'dir': 'default', 'back': True, 'user': False, 'glob': False},
    {'base': 'PROVISIONING_D', 'dir': '', 'back': False, 'user': False, 'glob': False},
    {'base': 'USER_D', 'dir': '', 'back': False, 'user': True, 'glob': False},
    {'base': 'STATE_D', 'dir': '', 'back': False, 'user': False, 'glob': True}
]

class SettingsFile(ConfigDict,
                   ContainerInterface,
                   DefaultResolver,
                   ExpireableFile,
                   object):
    """Small interface to the efw settings files,
    which allows to load all key/value pairs from a file
    specified by a path.
    SettingsFile behaves like a dict, which allows to
    give access to the key/value pairs in an easy manner.

    Each key is case in-sensitive and is accessible also
    through __getattr__.

    >>> ds = SettingsFile('ethernet/settings')
    >>> ds['GREEN_IPS']
    ... '10.1.1.1/24'
    >>> ds['green_ips']
    '10.1.1.1/24'
    >>> ds['green_ips']
    '10.1.1.1/24'
    >>> ds['GREEN_ips']
    '10.1.1.1/24'
    >>> ds.GREEN_ips
    '10.1.1.1/24'
    >>> ds.GREEN_IPS
    '10.1.1.1/24'
    >>> ds.green_ips
    '10.1.1.1/24'

    SettingsFile pre-loads the dict with default values
    from a number of files:

    **<PERSISTENT_D>/dirname(<path>)/default/basename(<path>)
    **<PERSISTENT_D>/dirname(<path>)/default/basename(<path>).*
    **<USER_D>/dirname(<path>)/default/basename(<path>)
    **<PERSISTENT_D>/dirname(<path>)/vendor/basename(<path>)   (deprecated by glob)
    **<USER_D>/dirname(<path>)/vendor/basename(<path>)         (deprecated by glob)
    **<STATE_D>/dirname(<path>)/default/basename(<path>)
    <USER_D>/<path>
    <STATE_D>/<path>
    <STATE_D>/<path>.*

    **: each path will be searched back the directory hierarchy
    for a default/vendor - directory which contains the searched
    file. Those files will be read out also and with precedence
    of it's hierarchy level.

    for example:
    SettingsFile('openvpnclients/client1/settings')
    reads:
    /usr/lib/efw/openvpnclients/default/settings
    /usr/lib/efw/openvpnclients/default/client1/settings
    /usr/lib/efw/openvpnclients/default/settings.*
    /usr/lib/efw/openvpnclients/default/client1/settings.*
    /var/efw/openvpnclients/default/settings
    /var/efw/openvpnclients/default/client1/settings
    /usr/lib/efw/openvpnclients/vendor/settings
    /usr/lib/efw/openvpnclients/vendir/client1/settings
    /var/efw/efw/openvpnclients/vendor/settings
    /var/efw/efw/openvpnclients/vendir/client1/settings
    /var/lib/efw/openvpnclients/default/settings
    /var/lib/efw/openvpnclients/default/client1/settings
    /var/efw/openvpnclients/client1/settings
    /var/lib/openvpnclients/client1/settings
    /var/lib/openvpnclients/client1/settings.*

    Meaning of directories:
    PERSISTENT_D: should contain only packaged files which will be
                 changed only when upgrading (default: /usr/lib/efw)
    STATE_D: should contain only files which the system creates. This
            way the system can override default values and/or
            the actual configuration (default: /var/lib/efw)
    USER_D: should contain only files the user created/modified
            (default: /var/efw)

    default: contain files with default values packaged by the
             original package.
             vendor or product related default files can be
             done by creating files like settings.mybrand
    vendor: *DEPRECATED* contains files which are packaged by a branding
            package

    The readout of default and vendor files in /var/efw is for
    backwards compatibility only.

    Modifiying values within the dict using __setitem__ allows to
    alter values. If they will be written down using save() causes
    to write down only the difference to the default/vendor values.

    """

    def __init__(self, path, d=None,
                 basePaths=constants,
                 readFileOrder=READFILEORDER,
                 inexistentOk=True, strict=False,
                 filterSuffices=IGNORESUFFICES,
                 **kwargs):
        """
        Inizializes the object and reads out the settings residing within
        the path 'path'. Default settings within defaults directory below the
        specified path will be read out before and overwritten by the vendor
        settings within vendors directory below the specified path whicht then
        will be overwritten by the user settings.

        With 'basePath' the base directory path can be changed. Default is
        '/var/efw/'. If 'default' / 'vendor' will be set to 'False' the
        default / vendor values will not be read out.
        """

        passdict = None

        # user passed data to be used
        if (type(d) is types.DictType
            or isinstance(d, UserDict.UserDict)):
            passdict = d
            d = None
        ConfigDict.__init__(self, passdict, string.upper, **kwargs)

        self._attributes.append('default')
        self._attributes.append('filename')

        self.default = ConfigDict()
        self._basePaths = basePaths.copy()
        self._readFileOrder = readFileOrder
        self._inexistentOk = inexistentOk
        self._strict = strict
        self._filterSuffices = filterSuffices

        # This is for backwards compatibility.
        # Second parameter has been basePath
        if type(d) == types.StringType:
            self._basePaths['USER_D'] = d
            d = None
        # third possibility is user passed a file content,
        # which will be passed to read()

        if path is None:
            raise TypeError("need string, NoneType found")


        # ensures backwards compatibility. SettingsFile has been instantiated
        # mostly supplying the full path which includes the known USER_D.
        # i.e: /var/efw/ethernet/settings /var/efw/ needs to be splitted away
        # in order to remain fully compatible to old style and allowing also
        # new style overrides using old style instantiation
        userdir = self._basePaths['USER_D'].rstrip('/')
        if userdir != '' and path.startswith(userdir):
            path = path[len(userdir):]
            path = path.lstrip('/')

        # class has been instantiated with an absolute path to the settingsfile
        # which however does not lie within USER_D. new style overrides will not
        # apply.
        if path.startswith('/'):
            filename = path
        else:
            filename = os.path.join(userdir, path)
        ContainerInterface.__init__(self, filename)
        ExpireableFile.__init__(self, filename)
        self._basename = os.path.basename(path)
        self._path = os.path.dirname(path)
        if self._path.startswith('/'):
            self._pathsplit = [self._path]
        else:
            self._pathsplit = self._path.split('/')
        self.read(d)

    def load(path, prefix=None):
        return SettingsFile(path, prefix)
    load = staticmethod(load)

    def read(self, data=None):
        """
        Reads out the setting, default and vendor values if they exist.
        No error will be thrown if no settings exist.
        """
        source = self.filename
        if data:
            source = data

        userdata = {}
        # preread user data in order to check if the user data
        # files are ok
        try:
            self._parseConfig(source, userdata, isDefault=False,
                              strict=self._strict)
        except (IOError, OSError), e:
            # user files may only not exist if _inexistentOk is True
            if not self._inexistentOk:
                raise SettingsException(e)

        for (file, isUser) in self._getReadFiles():
            if isUser:
                self.update(userdata)
                continue
            # never load the user file as default file. That leads
            # in empty diff's and write() then truncates the user file
            # to zero length
            if file == self.filename:
                continue
            try:
                self._parseConfig(file, self, isDefault=True,
                                  strict=self._strict)
            except (IOError, OSError):
                # default files may not exist
                pass
        ContainerInterface.read(self)

    def _parseConfig(self, file, data={}, isDefault=False, strict=False):
        """parses the config files"""
        f = []
        isFile = False
        try:
            if type(file) is types.StringType:
                f = open(file, "r")
                isFile = True
            else:
                f = file
            for line in f:
                if line.startswith("#"):
                    continue
                if line.strip() == "":
                    continue
                parts = line.split('=', 1)

                # skip lines without valid key=value pair,
                # if strict is not set
                if len(parts) < 2:
                    if strict:
                        if isFile:
                            raise SettingsException("File '%s' contains line not in key=value form:"%file)
                        else:
                            raise SettingsException("Data contains line not in key=value form: %s"%file)
                    continue

                key = parts[0].strip()
                value = parts[1].strip()
                data[key] = value
                if isDefault:
                    self.default[key] = value
        finally:
            if isFile:
                f.close()

    def dump(self):
        """
        Returns the configuration in raw mode
        """
        raw_file_lines = []
        keys = self.keys()
        keys.sort()
        for key in keys:
            raw_file_lines.append("%s=%s" % (self.origkeys[key], self[key]))
        return "\n".join(raw_file_lines)

    def diffDump(self):
        """
        Returns the configuration in raw mode as a diff to
        the default settings
        """
        raw_file_lines = []
        keys = self.keys()
        keys.sort()
        for key in keys:
            value = self[key]
            try:
                if self.default[key] == value:
                    continue
            except KeyError:
                pass
            raw_file_lines.append("%s=%s" % (self.origkeys[key], value))
        return "\n".join(raw_file_lines)

    def settings(self):
        """
        Returns the configuration settings dictionary.

        @deprecated settings Only for backwards compatibily
        """
        return self.data

    def write(self, file=None, diff=True):
        """
        writes down the new configuration file as a diff
        to the default settings.

        """
        filename = self.filename
        if file:
            filename = file
        if filename != self.filename:
            diff = False

        data = ""
        if diff:
            data = self.diffDump()
        else:
            data = self.dump()

        f = None
        try:
            f = open(filename, "w")
            f.write("%s\n" % data)
        finally:
            if f is not None:
                f.close()
        # change the owner of the file to nobody
        try:
            uid = pwd.getpwnam("nobody").pw_uid
            gid = grp.getgrnam("nogroup").gr_gid
            os.chown(filename, uid, gid)
        except:
            pass
        ContainerInterface.write(self, filename)

    def __str__(self):
        return "%s: %s"%(self.filename, str(self.data))
    def __delitem__(self, key):
        try:
            self[key] = self.default[key]
        except KeyError:
            ConfigDict.__delitem__(self, key)
