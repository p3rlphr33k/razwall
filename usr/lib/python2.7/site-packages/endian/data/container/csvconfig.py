#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2008-01-12"
"""
CSV container for Endian datasource
"""

import csv
import ConfigParser
from endian.data.container.abstractconfig import InvalidSettingsFile
from endian.data.container.abstractconfig import ConfigFileParseError
from endian.data.container.abstractconfig import AbstractConfigFile

from endian.datatypes.config_dict import ConfigDict
from endian.core.filetools import openLocking as open

__all__ = [
    'InvalidModelException',
    'CsvFileException',
    'InvalidSettingsFile',
    'ConfigFileParseError',
    'AbstractConfigFile',
    'ConfigDict'
]

class InvalidModelException(Exception):
    pass
class CsvFileException(ConfigFileParseError):
    pass

class CsvConfigFile(AbstractConfigFile, object):

    def __init__(self, configfiles, filename=None,
                 obj=None, delimiter=',', tolerant=False,
                 settingsDefault=None):
        self.model = []
        self._dialect = csv.excel()
        self._dialect.delimiter = delimiter
        self._tolerant = tolerant
        AbstractConfigFile.__init__(self, configfiles,
                                    filename, settingsDefault, obj)

    def _defineFormat(self):
        try:
            data = self._config.get('config', 'model')
            self.model = data.split(self._dialect.delimiter)
        except (ConfigParser.NoOptionError, ConfigParser.NoSectionError), e:
            raise InvalidModelException("%s: %s"%(self._configfiles, e))
        if len(self.model) <= 1:
            raise InvalidModelException("Only one field in '%s'"%self._configfiles)

    def _parse(self, obj, data=None):
        if data is None:
            data = self.data
        rows = csv.reader(obj, self._dialect)
        for row in rows:
            if len(row) <= 0:
                continue
            if not self._tolerant:
                if len(self.model) != len(row):
                    raise CsvFileException("Row has to few fields compared with meta information")
            item = ConfigDict()
            for i in range(0, len(self.model)):
                name = self.model[i]
                if self._tolerant:
                    try:
                        item[name] = row[i]
                    except IndexError:
                        item[name] = ''
                else:
                    item[name] = row[i]
                # Validation and type conversion
                # (string -> datatype)
                if self.validators:
                    validator = self.validators.get(name, None)
                    if validator is not None:
                        try:
                            item[name] = validator.to_python(item[name])
                        except Exception:
                            item[name] = None

            data.append(item)

    def write(self, filename=None):
        if not filename:
            filename = self.filename
        outfile = None
        try:
            outfile = open(filename, "w")
            out = csv.writer(outfile, self._dialect)
            if self.data is not None:
                for i in self.data:
                    row = []
                    for name in self.model:
                        value = ""
                        if self._tolerant:
                            value = i.get(name, '')
                        else:
                            value = i[name]
                        # Validation and type conversion
                        # (datatype -> string)
                        if self.validators:
                            validator = self.validators.get(name, None)
                            if validator is not None:
                                try:
                                    value = validator.from_python(value)
                                except Exception:
                                    value = None
                        row.append(value)
                    out.writerow(row)
        finally:
            if outfile is not None:
                outfile.close()
        AbstractConfigFile.write(self, filename)
