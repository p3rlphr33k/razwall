#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2012-04-27"

"""
CSV driver for Endian datasource
"""

import os
from endian.data.exceptions import InvalidGetMethod
from endian.data.constants import constants
from endian.data.container.abstractconfig import InvalidSettingsFile
from endian.data.methods import register_lookup, lookup
import ConfigParser

__all__ = ['get_configuration_files',
           'get_configuration',
           'get_backend',
          ]

def get_configuration_files(key, obj):
    """
       Get the list of the configuration files for a given DataSource key

       :param key: the key
       :type key: string
       :param obj: the datasource instance
       :type obj: DataSource
    """

    # obj may not be None but can be an empty dict so lets only check for None
    if obj is None or not key:
        return None

    path = obj.path
    if not path: # path can be None or empty string when its the root path
        path = ""

    configname = "%s.config" % key
    configfiles = [
        os.path.join(constants['PERSISTENT_D'], path, configname),
        os.path.join(constants['PERSISTENT_D'], path, 'vendor', configname),
    ]
    return configfiles

def get_configuration(key, obj):
    """
       Read the configuration for a given DataSource key

       :param key: the key
       :type key: string
       :param obj: the datasource instance
       :type obj: DataSource
    """
    configfiles = get_configuration_files(key, obj)
    config = ConfigParser.ConfigParser(constants)
    if not configfiles:
        return []
    try:
        read_ok_filenames = config.read(configfiles)
        config.read_ok_filenames = read_ok_filenames
    except (ConfigParser.MissingSectionHeaderError,
            ConfigParser.ParsingError), e:
        raise InvalidSettingsFile("%s: %s" % (configfiles, e))
    return config

def get_backend(configfiles):
    """
       Read the backend option from the config section of the given configfiles

       :param configfiles:
       :type configfiles: ConfigParser instance or a list of config file names
       :return: The backend as a string or None
       :rtype: String or None
    """
    if configfiles:
        # Read out config file if configfiles is not already a parsed config object
        if not isinstance(configfiles, ConfigParser.ConfigParser):
            cp = ConfigParser.ConfigParser(constants)
            try:
                cp.read(configfiles)
            except (ConfigParser.MissingSectionHeaderError,
                    ConfigParser.ParsingError), e:
                raise InvalidSettingsFile("%s: %s" % (configfiles, e))
            configfiles = cp
        try:
            return configfiles.get('config', 'backend')
        except:
            #read_ok_filenames = getattr(configfiles, 'read_ok_filenames')
            #if read_ok_filenames:
            #    warnings.warn("Please add the 'backend' option to the 'config' section to one of the following config file: %s" % ",".join(read_ok_filenames))
            pass
    return None

def _commons_get_config(key, obj, res, configfiles=None, raise_exceptions=False):
    # Read the config files
    if not configfiles:
        configfiles = get_configuration(key, obj)
    # Get the backend configuration
    backend = get_backend(configfiles)
    if not backend:
        raise InvalidGetMethod()
    # Lookup the backend function
    fn = lookup('get', key, 'leaf', backend)
    fn = fn.next()
    # Exec the backend function
    return fn(key, obj, res, configfiles=configfiles, raise_exceptions=True)

def init():
    register_lookup(100, 'get', _commons_get_config, 'leaf', '*')
