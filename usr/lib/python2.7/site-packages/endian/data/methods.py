#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2008-01-01"

"""
datasource lookup registry
"""

from endian.data import drivers

__all__ = [ 'register_lookup',
            'unregister_lookup',
            'lookup',
            'get_backends',
            # Obsolete
            'registerLookup',
            'unregisterLookup',
          ]

METHODS = ['get', 'iter', 'in', 'nodeType', 'init'] # Use only 'get' - the other methods are obsolete
TYPES = ['node', 'leaf', '*']

_drivers_loaded = False
_lookupProxy = {} # Lookup registry
_backends = {} # Backend lookup registry - A map backend.method -> function

def register_lookup(prio, method, cb, typefilter='*', keyfilter='*', backend=None):
    """
        Registers a lookup callback for method 'method' with priority
        'prio' to the datasource lookup registry.

        :type  prio: number
        :param prio: specifies a priority in which order of precedence the
                     lookup callback should be called. Lesser has more
                     precedence. If prio is None, don't register the
                     callback in the lookup registry but, only if the
                     backend argument is present, in the backends lookup
                     registry.

        :type  method: string
        :param method: Specifies for which lookup method the callback
                       should be registered.
                       Valid values are: 'I{get}', 'I{iter}',
                       'I{in}', 'I{nodeType}', 'I{init}'
                       The respective method's will be triggered by the
                       respective real DataSource methods L{<DataSource.get>},
                       L{DataSource.__iter__} and
                       L{DataSource.__contains__}.


        :type  cb: function
        :param cb: Specifies the callback function to be called when this
                   method triggers. The function needs to have the following
                   format:

                   C{method(key, obj, res)}

                   where I{key} will be the value of the key called by
                   the lookup method (where it makes sense)
                   and I{obj} points to the L{<DataSource>} object from
                   where the method has been called. This way the lookup
                   methods have access to the entire DataSource tree.
                   I{res} specifies a dict resource to which the
                   callback may access in order to store data forth for
                   following lookup iterations


        :type  typefilter: string
        :param typefilter: if supplied, causes the callback to
                           trigger only if the key for which the
                           lookup callback should be triggered is
                           of the specified node-type.
                           Valid values are 'I{node}', 'I{leaf}' and 'I{*}'
                           Default is 'I{*}', which means apply to any
                           type.

        :type  keyfilter: string
        :param keyfilter: if supplied, causes the callback to
                          trigger only if the key for which the
                          lookup callback should be triggered is
                          same as the value of keyfilter.
                          A value of 'I{*}' means, apply to any key.
                          'I{*}' is the default.

        :type backend: string
        :param backend: backend name, if supplied register the callback for
                        the given backend/method


    """
    if method not in METHODS:
        raise ValueError("method must be one of %s"%",".join(METHODS))
    if typefilter not in TYPES:
        raise ValueError("node-type filter must be one of %s"%",".join(TYPES))
    # Register the callback for the given backend
    if backend:
        _backends['%s.%s' % (backend, method)] = cb
    # If prio is None, don't register the lookup callback
    if prio is None:
        return
    #Â Register the lookup callback
    keyfilter = keyfilter.lower()
    if method not in _lookupProxy:
        _lookupProxy[method] = {}
    if prio not in _lookupProxy[method]:
        _lookupProxy[method][prio] = {}
    if keyfilter not in _lookupProxy[method][prio]:
        _lookupProxy[method][prio][keyfilter] = {}
    if typefilter not in _lookupProxy[method][prio][keyfilter]:
        _lookupProxy[method][prio][keyfilter][typefilter] = []

    _lookupProxy[method][prio][keyfilter][typefilter].append(cb)

registerLookup = register_lookup

def unregister_lookup(prio, method, cb, typefilter='*', keyfilter='*'):
    try:
        fn = _lookupProxy[method][prio][keyfilter][typefilter]
        del(_lookupProxy[method][prio][keyfilter][typefilter])
        for key in [k for (k,v) in _backends.iteritems() if v in fn]:
            del _backends[key]
    except KeyError:
        pass

unregisterLookup = unregister_lookup

def lookup(method, key=None, t=None, backend=None):
    load_drivers()

    if backend:
        m = _backends.get("%s.%s" % (backend, method))
        if m:
            yield m
            return
        backends_name = get_backends()
        if backend not in backends_name and False:
            raise Exception("Invalid backend '%s' (valid backends are: %s)" % (backend, ",".join(backends_name)))
        else:
            raise Exception("Undefined method '%s' for backend '%s'" % (method, backend))

    m = _lookupProxy.get(method)
    if not m:
        return
    if key:
        key = key.lower()
    checkMatrix = [(key, t),
              ('*', t),
              (key, '*'),
              ('*', '*')]
    prios = m.keys()
    prios.sort()
    for prio in prios:
        for i in checkMatrix:
            try:
                for cb in m[prio][i[0]][i[1]]:
                    yield(cb)
            except KeyError:
                continue

def get_backends():
    """
       Return the list of all the defined backends
    """
    load_drivers()
    return list(set([x.split('.')[0] for x in _backends.keys()]))

def load_drivers():
    """
       Load and init the data drivers
    """
    global _drivers_loaded
    if _drivers_loaded:
        return
    drivers.init()
    _drivers_loaded = True
