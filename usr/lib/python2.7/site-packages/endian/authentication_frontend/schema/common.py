#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from endian.core.i18n import _
from endian.emi import widgets
from endian.emi import entities
from endian.emi.widgets.otp import OTPSecretInputField as BaseOTPSecretInputField
from endian.data import DataSource
from endian.core.lazylist import LazyList

from endian.validators.boolean import to_bool
from endian.validators.core import FancyValidator, CIDR, IPAddress, Invalid

__all__ = [
    "IPsecTunnel",
    "NATValidator",
    "PushGreenCheckBox",
    "L2TPEnabledCheckBox",
    "UseExternalPasswordProviderCheckbox",
    "has_proxy_provider",
    "has_otp_provider",
]

def get_ipsec_tunnels():
    try:
        from endian.ipsec.schema import IPsecConnection
        result = [IPsecTunnel(ID='',name=_('Select a tunnel...'))] + \
                 [IPsecTunnel(ID=con.ID, name=con.name) \
                 for con in IPsecConnection.storage().select(connection_type="l2tp", enabled=True)]
        return result
    except ImportError:
        return [IPsecTunnel(ID='',name='')]

class IPsecTunnel(entities.Entity):
    entities.using_options(type='dynamic')

    ID = entities.Field(entities.Unicode, primary_key=True, nullable=True)
    name = entities.Field(entities.Unicode, nullable=True)

    values = LazyList(get_ipsec_tunnels)

    @classmethod
    def all(cls):
        return list(cls.storage().load())

class NATValidator(FancyValidator):
    """
    Validator for NAT
    """

    messages = {
        'bad_format': _('Please enter client and server networks in the following format: CLIENT-SIDE-IP/CIDR SERVER-SIDE-IP')
    }

    def _to_python(self, value, state):
        if not value:
            return ""
        try:
            value = value.strip()
            client, server = value.split()
            if "/" not in client:
                client = client + "/32"
            CIDR(client)
            IPAddress(server)
            return "%s %s" % (client, server)
        except Exception:
            raise Invalid(self.message("bad_format", state), value, state)

class PushGreenCheckBox(widgets.CheckBox):
    """ This checkbox is disabled if the OpenVPN server is bridged """

    def readonly_condition(self, *d):
        try:
            ds = DataSource()
            return to_bool(ds.openvpn.settings.BRIDGED)
        except :
            return False

    def update_params(self, d):
        widgets.CheckBox.update_params(self, d)
        try:
            if d['attrs']['readonly']:
                d['attrs']['disabled'] = True
        except:
            pass

class L2TPEnabledCheckBox(widgets.CheckBox):
    """ This checkbox is disabled if there are no IPSec/L2TP tunnel """

    def readonly_condition(self, *d):
        ds = DataSource('l2tp') or {}
        l2tp_disabled = ds.get('SETTINGS', {}).get('ENABLED') != 'on'
        if l2tp_disabled or len(IPsecTunnel.all()) == 1: # the first item is the empty value
            return True
        else:
            return False

    def update_params(self, d):
        widgets.CheckBox.update_params(self, d)
        try:
            if d['attrs']['readonly']:
                d['attrs']['disabled'] = True
        except:
            pass

def has_proxy_provider():
    """ Return True if an authentication provider with type proxy... is defined """
    from endian.emi.storage.yamlstorage import YamlStorage
    provider_storage = YamlStorage(namespace="access.provider")
    return bool([x.get('provider_type') for x in provider_storage.select() if x.get('provider_type', '').startswith('proxy')])

class UseExternalPasswordProviderCheckbox(widgets.CheckBox):

    def hidden_condition(self, d):
        return not has_proxy_provider()

def has_otp_provider():
    """ Return True if an authentication provider with type proxy_otp is defined """
    from endian.emi.storage.yamlstorage import YamlStorage
    provider_storage = YamlStorage(namespace="access.provider")
    return bool([x.get('provider_type') for x in provider_storage.select() if x.get('provider_type', '') == 'proxy_otp'])


class OTPSecretInputField(BaseOTPSecretInputField):

    def hidden_condition(self, d):
        return not has_otp_provider()

