#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import re
from endian.core.i18n import _
from endian.core import logger
from endian.validators.core import Multiline, Email, Regex
from endian.validators.network import IPAddress as IPAddressValidator, NetworkAddress
from endian.emi import entities
from endian.emi import widgets
from endian.authentication.common import TYPE_USER, LABEL_USER, TYPE_USERGROUP, TYPE_USERGROUP_PREFIX
from endian.authentication_frontend.schema.common import NATValidator, PushGreenCheckBox, \
                                                         UseExternalPasswordProviderCheckbox, \
                                                         OTPSecretInputField

__all__ = [
    'UserCertificateOptions',
    'User'
]

TYPES = [
    {'ID': TYPE_USER, 'name': LABEL_USER},
]

SYNC = {
    TYPE_USER: [{"from": "memberof", "to": "member", "target": [("UserGroup", TYPE_USERGROUP)]}]
}

DOMAIN_RE = re.compile(r'^[a-zA-Z\d-]{,63}(\.[a-zA-Z\d-]{,63})*$')

class UserCertificateOptions(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
            {'ID': 'cert', 'name': _("Don't change")},
            {'ID': 'new_cert', 'name': _("Generate a new certificate")},
            {'ID': 'upload_cert', 'name': _("Upload a certificate")},
            {'ID': 'upload_cert_req', 'name': _("Upload a certificate request")},
    ]

class L2TPCheckBox(widgets.CheckBox):

    def condition(self, d):
        try:
            from endian import l2tp
            assert(l2tp)
            return True
        except:
            return False

class User(entities.Entity):
    entities.using_options(namespace='access.user', type='yaml', register_datasource=False, storage_args={'indexes': ['name']})

    # common attributes
    ID = entities.Field(entities.Integer,
        primary_key=True,
        autoincrement=True,
        hidden=True,
        expands=True)
    name = entities.Field(entities.Unicode,
        label_text=_("Username"),
        readonly_if_not_empty=True,
        nullable=False,
        help_text=_("Username must be unique"))
    type = entities.Field(entities.String,
        hidden=True,
        default=TYPE_USER)
    remark = entities.Field(entities.Unicode,
        label_text=_("Remark"))
    password = entities.Field(entities.Unicode,
        label_text=_("Password"),
        nullable=True,
        widget=widgets.PasswordField,
        toggle_name="use_external_password_provider",
        toggle_option="off")
    verify = entities.Field(entities.Unicode,
        label_text=_("Confirm Password"),
        nullable=True,
        widget=widgets.PasswordField,
        toggle_name="use_external_password_provider",
        toggle_option="off")
    password_type = entities.Field(entities.Unicode,
        hidden=True,
        expands=False)
    use_external_password_provider = entities.Field(entities.Boolean,
        label_text=_("Authenticate using external authentication server"),
        widget=UseExternalPasswordProviderCheckbox,
        expands=True)
    otp_secret = entities.Field(entities.Unicode,
        label_text=_("One Time Password secret"),
        widget=OTPSecretInputField,
        expands=False)

    enabled = entities.Field(entities.Boolean,
        label_text=_("Enabled"),
        default=True,
        expands=True)

    user_email = entities.Field(entities.Unicode,
        label_text=_("Email address"),
        nullable=True,
        validator=Email)
    user_organization = entities.Field(entities.Unicode,
        label_text=_("Organization name"),
        nullable=True,
        expands=False)
    user_department = entities.Field(entities.Unicode,
        label_text=_("Organizational unit name"),
        nullable=True,
        expands=False)
    user_city = entities.Field(entities.Unicode,
        label_text=_("City"),
        nullable=True,
        expands=False)
    user_state = entities.Field(entities.Unicode,
        label_text=_("State or province"),
        nullable=True,
        expands=False)
    user_country = entities.ManyToOne(
        label_text=_("Country"),
        target="core:Country",
        singleselect_type="chosen",
        nullable=True,
        expands=False)

    user_memberof = entities.ManyToMany(
        label_text=_("Member of"),
        multiselect_title=_("Group membership"),
        target="authentication_frontend:UserGroup",
        target_key="name", target_label="name",
        target_key_prefix=TYPE_USERGROUP_PREFIX,
        target_label_prefix=" ",
        target_filter_key="provider_name",
        target_filter_value="",
        expands=True)

    disabled_scopes = entities.ManyToMany(
        label_text=_("Disabled on"),
        multiselect_title=_("Disabled for service"),
        target="authentication_frontend:Scope",
        target_key="name", target_label="label",
        target_label_prefix=" ",
        expands=True)

    # OpenVPN options START
    vpn_override_options = entities.Field(entities.Boolean,
        label_text=_("Override %s options") % "OpenVPN",
        default=False,
        expands=False)
    ## Client routing options START
    vpn_red = entities.Field(entities.Boolean,
        label_text=_("Direct all client traffic through the VPN server"),
        default=False)
    vpn_dont_push_routes = entities.Field(entities.Boolean,
        label_text=_("Push only global options to this client"),
        default=False)
    vpn_orange = entities.Field(entities.Boolean,
        label_text=_("Push route to ORANGE zone"),
        default=False)
    vpn_blue = entities.Field(entities.Boolean,
        label_text=_("Push route to BLUE zone"),
        default=False)
    vpn_green = entities.Field(entities.Boolean,
        label_text=_("Push route to GREEN zone"),
        widget=PushGreenCheckBox,
        default=False,
        expands=True)
    ## Client routing options END
    ## one-to-one NAT START
    vpn_snat = entities.Field(entities.UnicodeText,
        label_text=_("Source One-to-One NAT"),
        validator=Multiline(NATValidator))
    vpn_dnat = entities.Field(entities.UnicodeText,
        label_text=_("Destination One-to-One NAT"),
        validator=Multiline(NATValidator))
    ## one-to-one NAT END
    vpn_remote_nets = entities.Field(entities.UnicodeText,
        label_text=_("Networks behind client"),
        validator=Multiline(NetworkAddress))
    ## Custom push configuration START
    vpn_explicit_routes = entities.Field(entities.UnicodeText,
        label_text=_("Push only these networks"),
        validator=Multiline(NetworkAddress))
    vpn_static_ips = entities.Field(entities.UnicodeText,
        label_text=_("Static IP addresses"),
        validator=Multiline(IPAddressValidator),
        expands=True)
    vpn_push_custom_dns = entities.Field(entities.Boolean,
        label_text=_("Push these nameservers"),
        default=False)
    vpn_custom_dns = entities.Field(entities.UnicodeText,
        label_text=_("Nameservers"),
        validator=Multiline(IPAddressValidator))
    vpn_push_domain = entities.Field(entities.Boolean,
        label_text=_("Push these domains"),
        default=False)
    vpn_domain = entities.Field(entities.UnicodeText,
        label_text=_("Domain"),
        validator=Multiline(Regex(regex=DOMAIN_RE)))
    ## Custom push configuration END
    # VPN options END

    # L2TP START
    l2tp_override_options = entities.Field(entities.Boolean,
        label_text=_("Override %s options") % "L2TP",
        default=False,
        expands=False,
        widget=L2TPCheckBox)
    l2tp_ipsec_tunnel = entities.ManyToOne(
        target="authentication_frontend:IPsecTunnel",
        label_text=_("IPsec Tunnel"),
        required=False)
    # L2TP END

    # LDAP START
    provider_name = entities.Field(entities.Unicode,
        hidden=True,
        default="")
    synced = entities.Field(entities.Boolean,
        hidden=True,
        default=False)
    # LDAP END

    def user_in_groups(self, groups):
        return self.groups.intersection(set(groups))

    @property
    def groups(self):
        return set([g.replace(TYPE_USERGROUP_PREFIX, '', 1) for g in self.get('user_memberof') or []])

    @property
    def provider(self):
        if self.provider_name:
            return [self.provider_name]
        from endian.authentication_frontend.schema.provider import Provider
        provider = []
        for p in Provider.get_by_provider_type("local"):
            if not p.local_select_groups: # all groups means, all users
                provider.append(p.name)
                continue
            if self.user_in_groups(p.local_user_groups):
                provider.append(p.name)
                continue
        return provider

    # VPN only properties START
    # @property
    # def connected_scopes(self):
    #     status = []
    #     for scope, session in auth_client.list_open_sessions(username=self.name):
    #     if self.get('name','') in online_openvpn_users:
    #         status.append('OpenVPN')
    #     if self.get('name','') in online_l2tp_users:
    #         status.append('L2TP')
    #     if not status:
    #         return _("Disconnected")
    #     else:
    #         return "%s (%s)" % (_("Connected"), ",".join(status))

    # VPN only properties END
    @classmethod
    def all(cls):
        return cls.storage().select()

    @classmethod
    def get_by_id(cls, id_):
        try:
            id_ = int(id_)
        except (ValueError, TypeError):
            return None
        return cls.storage().load(id=id_)

    @classmethod
    def get_by_name(cls, name, check_acl=False):
        result = cls.storage().select(name=name, check_acl=check_acl)
        return result and result[0] or None

    @classmethod
    def sync(cls, name, type_, _delete=False, _renaming=None):
        from endian.authentication_frontend.schema import UserGroup
        schemas = { 'UserGroup': UserGroup }
        user = cls.get_by_name(name, check_acl=False) # get user which needs to get synced
        userID = "%s:%s" % (type_, user.get('name', ""))
        _renamingName = ''
        if _renaming is not None:
            _renamingName = "%s:%s" % (type_, _renaming)
        # do all sync actions for this type of user
        for sync in (SYNC.get(type_) or []):
            source = "%s_%s" % (type_, sync.get('from', "")) # field ID used in the entity
            sourceValues = (user.get(source) or []) # all items which need to be synced
            logger.debug("sync from %s" % source)
            for targetEntity, targetType in (sync.get('target') or []): # sync to all targets
                target = '%s_%s' % (targetType, sync.get('to', "")) # field ID used in the target entity
                items = schemas[targetEntity].all() # read all items which may need to be synced
                logger.debug("sync to %s %s" % (targetEntity, target))
                for item in items:
                    itemID = "%s:%s" % (targetType, item.get('name', ""))
                    logger.debug("sync to item %s" % itemID)
                    targetValues = (item.get(target) or [])
                    if _renamingName and _renamingName in targetValues:
                        try:
                            item[target].remove(_renamingName)
                        except:
                            logger.warn("could not remove renamed %s from %s" % (_renamingName, item[target]))
                    if userID in targetValues: # already present for the item
                        logger.debug("is already present")
                        if _delete or (itemID not in sourceValues): # should not be present -> remove
                            logger.debug("should not be present")
                            try:
                                item[target].remove(userID)
                            except:
                                logger.warn("could not remove %s from %s" % (userID, item[target]))
                            logger.debug("removed")
                    elif itemID in sourceValues: # should be present but is not -> add
                        logger.debug("is not present")
                        targetValues.append(userID)
                        item[target] = targetValues
                        logger.debug("added")
                schemas[targetEntity].storage().store(items, check_acl=False)

    @classmethod
    def sync_user(cls, name, _delete=False, _renaming=None):
        return cls.sync(name=name, type_=TYPE_USER, _delete=_delete, _renaming=_renaming)

