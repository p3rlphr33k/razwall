#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import re
from endian.core.i18n import _
from endian.core import logger
from endian.validators.core import Multiline, Regex
from endian.validators.network import IPAddress as IPAddressValidator, NetworkAddress
from endian.emi import entities
from endian.authentication.common import TYPE_USERGROUP, LABEL_USERGROUP, TYPE_USER, TYPE_USER_PREFIX
from endian.authentication_frontend.schema.common import NATValidator, PushGreenCheckBox

__all__ = [
    "UserGroup"
]

TYPES = [
    {'ID': TYPE_USERGROUP, 'name': LABEL_USERGROUP},
]

SYNC = {
    'usergroup': [
        {"from": "member", "to": "memberof", "target": [("User", TYPE_USER)]},
    ]
}

DOMAIN_RE = re.compile(r'^[a-zA-Z\d-]{,63}(\.[a-zA-Z\d-]{,63})*$')

class UserGroup(entities.Entity):
    entities.using_options(namespace='access.usergroup', type='yaml', register_datasource=False, storage_args={'indexes': ['name']})
    search_keys = [
        "name",
        "remark"
    ]

    ID = entities.Field(entities.Integer,
        primary_key=True,
        hidden=True,
        autoincrement=True)
    name = entities.Field(entities.Unicode, label_text=_("Group Name"),
        help_text=_("Name must be unique in users groups"),
        readonly_if_not_empty=True,
        nullable=False,
        expands=True)
    remark = entities.Field(entities.Unicode, label_text=_("Remark"),
        nullable=True,
        expands=True)
    usergroup_member = entities.ManyToMany(
        label_text=_("Group members"),
        multiselect_title=_("Users"),
        target="authentication_frontend:User",
        target_key="name", target_label="name",
        target_key_prefix=TYPE_USER_PREFIX,
        target_label_prefix=" ",
        target_filter_key="type&provider_name",
        target_filter_value="%s&" % TYPE_USER,
        toggle_name="READONLY",
        toggle_option="off",
        expands=True)
    enabled = entities.Field(entities.Boolean,
        label_text=_("Enabled"),
        default=True,
        expands=True)

    # OpenVPN options START
    vpn_override_options = entities.Field(entities.Boolean,
        label_text=_("Override %s options") % "OpenVPN",
        default=False,
        expands=False)
    ## Client routing options START
    vpn_red = entities.Field(entities.Boolean,
        label_text=_("Direct all client traffic through the VPN server"),
        default=False)
    vpn_dont_push_routes = entities.Field(entities.Boolean,
        label_text=_("Push only global options to this client"),
        default=False)
    vpn_green = entities.Field(entities.Boolean,
        label_text=_("Push route to GREEN zone"),
        widget=PushGreenCheckBox,
        default=False,
        expands=True)
    vpn_blue = entities.Field(entities.Boolean,
        label_text=_("Push route to BLUE zone"),
        default=False)
    vpn_orange = entities.Field(entities.Boolean,
        label_text=_("Push route to ORANGE zone"),
        default=False)
    ## Client routing options END
    ## one-to-one NAT START
    vpn_snat = entities.Field(entities.UnicodeText,
        label_text=_("Source One-to-One NAT"),
        validator=Multiline(NATValidator))
    vpn_dnat = entities.Field(entities.UnicodeText,
        label_text=_("Destination One-to-One NAT"),
        validator=Multiline(NATValidator))
    ## one-to-one NAT END
    vpn_remote_nets = entities.Field(entities.UnicodeText,
        label_text=_("Networks behind client"),
        validator=Multiline(NetworkAddress))
    ## Custom push configuration START
    vpn_explicit_routes = entities.Field(entities.UnicodeText,
        label_text=_("Push these networks"),
        validator=Multiline(NetworkAddress))
    vpn_push_custom_dns = entities.Field(entities.Boolean,
        label_text=_("Push these nameservers"),)
    vpn_custom_dns = entities.Field(entities.UnicodeText,
        label_text=_("Nameservers"),
        validator=Multiline(IPAddressValidator))
    vpn_push_domain = entities.Field(entities.Boolean,
        label_text=_("Push these domains"),
        default=False)
    vpn_domain = entities.Field(entities.UnicodeText,
        label_text=_("Domain"),
        validator=Multiline(Regex(regex=DOMAIN_RE)))
    ## Custom push configuration END
    # VPN options END

    # L2TP START
    l2tp_override_options = entities.Field(entities.Boolean,
        label_text=_("Override %s options") % "L2TP",
        default=False,
        expands=False)
    l2tp_ipsec_tunnel = entities.ManyToOne(
        target="authentication_frontend:IPsecTunnel",
        label_text=_("IPsec Tunnel"),
        required=False)
    # L2TP END

    # LDAP START
    provider_name = entities.Field(entities.Unicode,
        hidden=True,
        default="")
    synced = entities.Field(entities.Boolean,
        hidden=True,
        default=False)
    # LDAP END

    @property
    def provider(self):
        if self.provider_name:
            return [self.provider_name]
        from endian.authentication_frontend.schema.provider import Provider
        provider = []
        for p in Provider.get_by_provider_type("local"):
            if not p.local_select_groups: # all groups means, all users
                provider.append(p.name)
                continue
            if self.name in p.local_user_groups:
                provider.append(p.name)
                continue
        return provider

    @classmethod
    def all(cls, type_=None, check_acl=True):
        return cls.storage().load(check_acl=check_acl)

    @classmethod
    def get_by_id(cls, id_, type_=None, check_acl=True):
        try:
            id_ = int(id_)
        except (ValueError, TypeError):
            return None
        return cls.storage().load(id=id_, check_acl=check_acl)

    @classmethod
    def get_by_name(cls, name, type_=None, check_acl=True):
        result = cls.storage().select(name=name, check_acl=check_acl)
        return result and result[0] or None

    @classmethod
    def sync(cls, name, type_, _delete=False, _renaming=None):
        from endian.authentication_frontend.schema import User
        schemas = { 'User': User }
        _renamingName = ''
        if _renaming is not None:
            _renamingName = "%s:%s" % (type_, _renaming)
        group = cls.get_by_name(name, type_=type_,check_acl=False) # get group which needs to get synced
        groupID = "%s:%s" % (type_, group.get('name', ""))
        logger.debug("sync %s" % groupID)
        # do all sync actions for this type of group
        for sync in (SYNC.get(type_) or []):
            source = "%s_%s" % (type_, sync.get('from', "")) # field ID used in the entity
            sourceValues = (group.get(source) or []) # all items which need to be synced
            logger.debug("sync from %s" % source)
            for targetEntity, targetType in (sync.get('target') or []): # sync to all targets
                target = '%s_%s' % (targetType, sync.get('to', "")) # field ID used in the target entity
                items = schemas[targetEntity].all() # read all items which may need to be synced
                logger.debug("sync to %s %s" % (targetEntity, target))
                for item in items:
                    itemID = "%s:%s" % (targetType, item.get('name', ""))
                    targetValues = (item.get(target) or [])
                    if _renamingName and _renamingName in targetValues:
                        try:
                            item[target].remove(_renamingName)
                        except:
                            logger.warn("could not remove renamed %s from %s" % (_renamingName, item[target]))
                    if groupID in targetValues: # already present for the item
                        logger.debug("is already present")
                        if _delete or (itemID not in sourceValues): # should not be present -> remove
                            logger.debug("should not be present, removing '%s' from '%s'", groupID, target)
                            try:
                                item[target].remove(groupID)
                            except:
                                logger.warn("could not remove %s from %s" % (groupID, item[target]))
                            logger.debug("removed")
                    elif itemID in sourceValues: # should be present but is not -> add
                        logger.debug("is not present")
                        targetValues.append(groupID)
                        item[target] = targetValues
                        logger.debug("added")
                schemas[targetEntity].storage().store(items, check_acl=False)

    @classmethod
    def sync_usergroup(cls, name, _delete=False, _renaming=None):
        return cls.sync(name=name, type_='usergroup', _delete=_delete, _renaming=_renaming)

