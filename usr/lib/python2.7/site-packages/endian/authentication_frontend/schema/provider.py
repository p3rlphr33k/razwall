#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from endian.core.i18n import _
from endian.core import logger
from endian.core.lazylist import CachedList
from endian.emi import entities
from endian.emi import widgets
from endian.validators.network import Port
from endian.authentication.common import TYPE_USER, TYPE_USERGROUP

__all__ = [
    'provider_type',
    'ProviderType',
    'Provider',
    'LDAPServerType',
    'LDAPGroupMemberAttribute'
]

SYNC = [
    {"from": "name", "to": "provider_name", "target": [("User", TYPE_USER), ("UserGroup", TYPE_USERGROUP)]},
    {"from": "name", "to": "providers", "target": [("Scope", None)]}
]

OTP_BACK_TO_THE_FUTURE = 5

def provider_type(id):
    if not id:
        return {}
    from endian.authentication.auth_client import get_provider_type
    return get_provider_type(id)

def provider_types():
    from endian.authentication.auth_client import get_provider_types
    types = []
    for key, value in get_provider_types().iteritems():
        types.append({
            'ID': key,
            'name': value['name'],
            'can_authenticate': value['can_authenticate'],
            'can_get_user': value['can_get_user'],
            'can_list_users': value['can_list_users']
        })
    return sorted(types, cmp=lambda x,y: cmp(x['name'], y['name']))

class ProviderType(entities.Entity):
    entities.using_options(type='dynamic')

    ID = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)
    can_authenticate = entities.Field(entities.Boolean, nullable=False)
    can_get_user = entities.Field(entities.Boolean, nullable=False)
    can_list_users = entities.Field(entities.Boolean, nullable=False)

    values = CachedList(provider_types)

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        try:
            return cls.storage().filter(ID=id)[0]
        except:
            return None

def ldap_server_types():
    """
        return a list of LDAP presets
        currently read from LDAP_SERVER_TYPES located within endian.authentication.utils.pldap
        maybe it should be saved in a csv or yaml file so it can easily expanded
    """
    presets = []
    try:
        from endian.authentication.utils.pldap import LDAP_SERVER_TYPES
        for key, value in LDAP_SERVER_TYPES.iteritems():
            presets.append({'ID': key, 'name': value.get("name")})
    except ImportError:
        logger.debug("could not import pldap provider")
    presets = sorted(presets, cmp=lambda x,y: cmp(x['name'], y['name']))
    presets.insert(0, {'ID': "none", 'name': _("Generic")})
    return presets

class LDAPServerType(entities.Entity):
    """
        Represents LDAP presets with predefined ldap options
        ldap_user_searchfilter, ldap_user_uidattribute,
        ldap_group_searchfilter, ldap_group_memberattribute
    """
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    values = ldap_server_types()

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

class LDAPGroupMemberAttribute(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    values = [
        {'ID': 'uniqueMember', 'name': 'uniqueMember'},
        {'ID': 'memberUid', 'name': 'memberUid'},
        {'ID': 'member', 'name': 'member'},
        {'ID': 'memberOf', 'name': 'memberOf'},
        {'ID': 'groupMembership', 'name': 'groupMembership'}
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

class Provider(entities.Entity):
    entities.using_options(namespace='access.provider', type='yaml', register_datasource=False)

    ID = entities.Field(entities.Integer,
        primary_key=True,
        hidden=True,
        autoincrement=True)
    name = entities.Field(entities.Unicode,
        label_text=_("Name"),
        readonly_if_not_empty=True,
        nullable=False,
        expands=False)
    provider_type = entities.ManyToOne(
        label_text=_("Type"),
        readonly_if_not_empty=True,
        target="authentication_frontend:ProviderType",
        target_key="ID", target_label="name",
        expands=True)
    enabled = entities.Field(entities.Boolean,
        label_text=_("Enabled"),
        nullable=False,
        default=True,
        expands=False)

    # selected groups START
    local_select_groups = entities.Field(entities.Boolean,
        label_text=_("Limit to specified groups"),
        expands=True,
        default=False,
        nullable=True)
    local_user_groups = entities.ManyToMany(
        label_text=_("Allowed user groups"),
        multiselect_title=_("User groups"),
        target="authentication_frontend:UserGroup",
        target_key="name",
        target_label="name",
        target_filter_key="provider_name",
        target_filter_value="",
        toggle_name="local_select_groups",
        toggle_option="on",
        expands=True)
    # selected groups END

    # LDAP options START
    ldap_uri = entities.Field(entities.Unicode,
        label_text=_("LDAP server URI"),
        default="ldap://",
        nullable=True,
        expands=False)
    ldap_preset = entities.ManyToOne(
        label_text=_("LDAP server type"),
        target="authentication_frontend:LDAPServerType",
        target_key="ID", target_label="name",
        expands=False)
    ldap_bind_dn = entities.Field(entities.Unicode,
        label_text=_("LDAP bind DN username"),
        nullable=True)
    ldap_bind_password = entities.Field(entities.Unicode,
        label_text=_("LDAP bind DN password"),
        widget=widgets.PasswordField,
        nullable=True)
    ldap_user_basedn = entities.Field(entities.Unicode,
        label_text=_("LDAP user base DN"),
        nullable=True)
    ldap_user_searchfilter = entities.Field(entities.Unicode,
        label_text=_("LDAP user search filter"),
        default="(objectClass=person)",
        nullable=True,
        toggle_name="ldap_preset", # show only if no preset is selected
        toggle_option="none")
    ldap_user_uidattribute = entities.Field(entities.Unicode,
        label_text=_("LDAP user unique ID attribute"),
        default="uid",
        nullable=True,
        toggle_name="ldap_preset", # show only if no preset is selected
        toggle_option="none")
    ldap_group_basedn = entities.Field(entities.Unicode,
        label_text=_("LDAP group base DN"),
        nullable=True)
    ldap_group_searchfilter = entities.Field(entities.Unicode,
        label_text=_("LDAP group search filter"),
        default="(objectClass=posixGroup)",
        nullable=True,
        toggle_name="ldap_preset", # show only if no preset is selected
        toggle_option="none")
    ldap_group_uidattribute = entities.Field(entities.Unicode,
        label_text=_("LDAP group unique ID attribute"),
        default="cn",
        nullable=True,
        toggle_name="ldap_preset", # show only if no preset is selected
        toggle_option="none")
    ldap_group_memberattribute = entities.ManyToOne(
        label_text=_("LDAP group member attribute"),
        default="memberUid",
        target="authentication_frontend:LDAPGroupMemberAttribute",
        toggle_name="ldap_preset", # show only if no preset is selected
        toggle_option="none")
    ldap_select_groups = entities.Field(entities.Boolean,
        label_text=_("Limit to specified groups"),
        expands=True,
        default=False,
        nullable=True)
    ldap_user_groups = entities.ManyToMany(
        label_text=_("Allowed user groups"),
        multiselect_title=_("User groups"),
        multiselect_url="/manage/commands/json/commands.authentication.listAllLDAPGroups",
        multiselect_data_fields=[
            "ldap_uri",
            "ldap_preset",
            "ldap_bind_dn",
            "ldap_bind_password",
            "ldap_user_basedn",
            "ldap_user_searchfilter",
            "ldap_user_uidattribute",
            "ldap_group_basedn",
            "ldap_group_uidattribute",
            "ldap_group_memberattribute",
            "ldap_group_searchfilter"
        ],
        target="authentication_frontend:UserGroup",
        target_key="name",
        target_label="name",
        toggle_name="ldap_select_groups",
        toggle_option="on",
        expands=True)
    # LDAP options END

    # RADIUS options START
    radius_server = entities.Field(entities.Unicode,
        label_text=_("RADIUS server"),
        nullable=True)
    radius_secret = entities.Field(entities.Unicode,
        label_text=_("RADIUS shared secret"),
        nullable=True)
    radius_authport = entities.Field(entities.Unicode,
        label_text=_("RADIUS authentication port"),
        default="1812",
        validator=Port)
    radius_acctport = entities.Field(entities.Unicode,
        label_text=_("RADIUS accounting port"),
        default="1813",
        validator=Port)
    radius_identifier = entities.Field(entities.Unicode,
        label_text=_("RADIUS identifier"),
        nullable=True,
        expands=True)
    # RADIUS options END

    # PROXY options START
    proxy_password_provider = entities.Field(entities.Unicode,
        label_text=_("Password provider"),
        target="authentication_frontend:Provider",
        target_key="name", target_label="label",
        widget=widgets.SingleSelectField,
        toggle_name="provider_type",
        toggle_option=["proxy", "proxy_otp"])
    proxy_user_provider = entities.Field(entities.Unicode,
        label_text=_("User information provider"),
        target="authentication_frontend:Provider",
        target_key="name", target_label="label",
        target_filter_key="can_get_user",
        target_filter_value="True",
        toggle_name="provider_type",
        toggle_option=["proxy", "proxy_otp"])
    # PROXY options END

    # OTP options END
    otp_back_to_the_future = entities.Field(entities.Integer,
        label_text="Number of old tokens to be checked",
        default=OTP_BACK_TO_THE_FUTURE)
    # OTP options START

    @property
    def label(self):
        from endian.authentication.auth_client import get_provider_type
        try:
            return "%s (%s)" % (self.name, get_provider_type(self.provider_type).get('name'))
        except:
            return self.name

    @property
    def scopes(self):
        from endian.authentication_frontend.schema.scope import Scope
        scopes = []
        for scope in Scope.all():
            if not self.name in scope.get("providers", []):
                continue
            scopes.append(scope)
        return scopes

    @property
    def get_groups(self):
        return self.get('user_groups')

    @property
    def can_authenticate(self):
        pt = ProviderType.get_by_id(self['provider_type'])
        return pt is not None and pt.can_authenticate

    @property
    def can_get_user(self):
        pt = ProviderType.get_by_id(self['provider_type'])
        return pt is not None and pt.can_get_user

    @property
    def can_list_users(self):
        pt = ProviderType.get_by_id(self['provider_type'])
        return pt is not None and pt.can_list_users

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_name(cls, name):
        for provider in cls.all():
            if provider['name'] == name:
                return provider
        return None

    @classmethod
    def get_by_provider_type(cls, provider_type):
        return cls.storage().select(provider_type=provider_type)

    @classmethod
    def sync(cls, name, _delete=False):
        from endian.authentication_frontend.schema import User, UserGroup, Scope
        schemas = { 'User': User, 'UserGroup': UserGroup, 'Scope': Scope }
        provider = cls.get_by_name(name) # get provider which needs to get synced
        providerID = provider.get('name', "")
        logger.debug("sync %s" % providerID)
        for sync in SYNC:
            source = sync.get('from', "") # field ID used in the entity
            sourceValues = (provider.get(source) or []) # all items which need to be synced
            if not isinstance(sourceValues, (list, tuple)):
                sourceValues = [sourceValues]
            logger.debug("sync from %s" % source)
            for targetEntity, targetType in (sync.get('target') or []): # sync to all targets
                target = sync.get('to', "") # field ID used in the target entity
                logger.debug("sync to %s %s" % (targetEntity, target))
                items = schemas[targetEntity].all()
                store_items = []
                for item in items: # read all items which may need to be synced
                    if targetType:
                        itemID = "%s:%s" % (targetType, item.get('name', ""))
                    else:
                        itemID = item.get('name', "")
                    targetValues = (item.get(target) or [])
                    if providerID in targetValues: # already present for the item
                        logger.debug("is already present")
                        if _delete or (itemID not in sourceValues): # should not be present -> remove
                            logger.debug("should not be present, removing '%s' from '%s'", providerID, target)
                            try:
                                # delete user and group if type is not local
                                if targetEntity in ["User", "UserGroup"]:
                                    if provider.get("provider_type") != "local": # delete synced users and groups
                                        schemas[targetEntity].storage().delete(item.get("ID"), check_acl=False)
                                elif targetEntity in ["Scope"] and _delete:
                                    item[target].remove(providerID)
                                    store_items.append(item)
                            except:
                                logger.warn("could not remove %s from %s" % (providerID, item[target]))
                            logger.debug("removed")
                if store_items:
                    schemas[targetEntity].storage().store(items, check_acl=False)
