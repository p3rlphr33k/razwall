#!/usr/bin/python
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2016 S.p.A. <info@endian.com>                              |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
from endian.data import DataSource
from endian.emi import controllers
from endian.core.i18n import _
from endian.core.zones import getZones
from endian.validators.boolean import to_bool
from endian.job.engine_control import send_cmd_to_engine
from endian.dhcp.web.widgets.settings import DHCPServerSettingsEditor

__all__ = [
    "DHCPServerSettingsController",
]

CUSTOM_FILE = '/var/efw/dhcp/custom.tpl'

class DHCPServerSettingsController(controllers.SettingsController):
    settingsWidget = DHCPServerSettingsEditor

    def actualize_subnets(self):
        send_cmd_to_engine("call dhcp.actualize_subnets")

    def calculate_defaults(self, data):
        # Set default DHCP values only if blank and disabled
        es = DataSource().ethernet.settings
        hs = DataSource().host.settings
        for zone in ['GREEN', 'BLUE', 'ORANGE']:
            if not data.get('ENABLE_%s' % zone):
                if not data.get('GATEWAY_%s' % zone):
                    data['GATEWAY_%s' % zone] = es.get('%s_ADDRESS' % zone)
                if not data.get('DNS1_%s' % zone):
                    data['DNS1_%s' % zone] = es.get('%s_ADDRESS' % zone)
                if not data.get('DOMAIN_NAME_%s' % zone):
                    data['DOMAIN_NAME_%s' % zone] = hs.get('DOMAINNAME')

    def calculate_disabled_zones(self, data):
        zones = getZones()
        disabled_zones = {}
        for zone in ['GREEN', 'BLUE', 'ORANGE']:
            if not zone.lower() in zones:
                disabled_zones[zone] = ''
        try:
            if to_bool(DataSource().hotspot.settings.HOTSPOT_ENABLED):
                disabled_zones['BLUE'] = _('DHCP configuration is managed by hotspot')
        except:
            pass
        data['DISABLED_ZONES'] = disabled_zones

    def onLoad(self, data):
        self.calculate_defaults(data)
        self.calculate_disabled_zones(data)
        try:
            with open(CUSTOM_FILE, 'r') as f:
                data['CUSTOM_GLOBAL'] = f.read()
        except:
            data['CUSTOM_GLOBAL'] = ''
        return data

    def onStore(self, data):
        if 'CUSTOM_GLOBAL' in data:
            try:
                with open(CUSTOM_FILE, 'w') as f:
                    f.write('\n'.join(data['CUSTOM_GLOBAL']))
            except:
                try:
                    os.path.unlink(CUSTOM_FILE)
                except:
                    pass
            del data['CUSTOM_GLOBAL']
        return data

    def onStoreSuccess(self, data):
        self.actualize_subnets()
        return data

    def _apply(self, **args):
        self.storage.changed = False
        send_cmd_to_engine("restart sync dhcp", options=dict(force=True))

