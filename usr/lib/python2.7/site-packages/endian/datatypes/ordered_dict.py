#!/usr/bin/env python
# encoding: utf-8
#
# Based on odict.py
# An Ordered Dictionary object
# Copyright (C) 2005 Nicola Larosa, Michael Foord
# E-mail: nico AT tekNico DOT net, fuzzyman AT voidspace DOT org DOT uk
#
# This software is licensed under the terms of the BSD license.
# http://www.voidspace.org.uk/python/license.shtml
# Basically you're free to copy, modify, distribute and relicense it,
# So long as you keep a copy of the license with it.
# Documentation at http://www.voidspace.org.uk/python/odict.html
#

__all__ = ['OrderedDict']

class OrderedDict(dict):
    """
    ... autoclass::: OrderedDict
        Dictionary that keeps the insertion order of keys
    """

    def __init__(self, init_val=()):
        dict.__init__(self)
        if isinstance(init_val, OrderedDict):
            self._sequence = init_val.keys()
            dict.update(self, init_val)
        elif isinstance(init_val, dict):
            dict.update(self, init_val)
        else:
            self._sequence = []
            self.update(init_val)

    def __setitem__(self, key, val):
        if key not in self:
            self._sequence.append(key)
        dict.__setitem__(self, key, val)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        self._sequence.remove(key)

    def copy(self):
        return OrderedDict(self)

    def items(self):
        return zip(self._sequence, self.values())

    def keys(self):
        return self._sequence[:]

    def values(self):
        return [self[key] for key in self._sequence]

    def iteritems(self):
        def make_iter(self=self):
            keys = self.iterkeys()
            while True:
                key = keys.next()
                yield (key, self[key])
        return make_iter()

    def iterkeys(self):
        return iter(self._sequence)

    __iter__ = iterkeys

    def itervalues(self):
        def make_iter(self=self):
            keys = self.iterkeys()
            while True:
                yield self[keys.next()]
        return make_iter()

    def clear(self):
        dict.clear(self)
        self._sequence = []

    def update(self, from_od):
        """
        Update from another OrderedDict or sequence of (key, value) pairs
        """
        if isinstance(from_od, OrderedDict) or isinstance(from_od, dict):
            for key, val in from_od.items():
                self[key] = val
        else:
            # FIXME: efficiency?
            # sequence of 2-item sequences, or error
            for item in from_od:
                try:
                    key, val = item
                except TypeError:
                    raise TypeError('cannot convert dictionary update'
                        ' sequence element "%s" to a 2-item sequence' % item)
                self[key] = val

    def pop(self, key, *args):
            if len(args) > 1:
                raise TypeError('pop expected at most 2 arguments')
            if key in self:
                val = self[key]
                del self[key]
            else:
                try:
                    val = args[0]
                except IndexError:
                    raise KeyError(key)
            return val

    def popitem(self):
        """
        Delete and return the last item.
        Raise a KeyError if the dictionary is empty.
        """
        if not self._sequence:
            raise KeyError('popitem(): dictionary is empty')
        key = self._sequence[-1]
        return (key, self.pop(key))

    def rename(self, old_key, new_key):
        raise RuntimeError('Insertion-only dictionary')

    def setitems(self, items):
        raise RuntimeError('Insertion-only dictionary')

    def setkeys(self, keys):
        raise RuntimeError('Insertion-only dictionary')

    def setvalues(self, values):
        raise RuntimeError('Insertion-only dictionary')

    def __repr__(self):
        return '%s([%s])' % (self.__class__.__name__, ', '.join(
            ['(%r, %r)' % (key, self[key]) for key in self._sequence]))

    def __str__(self):
        return '{%s}' % (', '.join(['%r: %r' % (key, self[key]) for key in self._sequence]))
