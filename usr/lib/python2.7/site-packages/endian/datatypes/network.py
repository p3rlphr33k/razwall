#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2012 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2009-05-27"
"""
defines special types to be returned by validators using
to_python

Type instances hold only the values and may allow operations.
Instantiation always expect correct values. A corresponding validator
need to check whether values are correct or not.
"""

__all__ = ['InvalidCidrCalculation',
           'InvalidIp',
           'CIDR',
           'IPAddress',
           ]

import iplib
import types

class InvalidCidrCalculation(Exception):
    """Thrown when a calculation returns invalid values"""
    pass
class InvalidSubnet(InvalidCidrCalculation):
    """Thrown when a calculation produces an invalid subnet"""
    pass
class InvalidIp(InvalidCidrCalculation):
    """Thrown when a calculation produces an ip address"""
    pass

MAXIP = int(iplib.CIDR('0/0').get_last_ip().get_dec())


class CIDR(object):
    """

    Type holds an ip/bits representation, allows easy access to
    calculated values and allows some operations on it.

    Examples:

    # Different possibilities to instantiate:
    >>> CIDR('10.1.1.1/24')
    10.1.1.1/24
    >>> CIDR('10.1.1.1', 24)
    10.1.1.1/24
    >>> CIDR('10.1.1.1', '24')
    10.1.1.1/24
    >>> CIDR('10.1.1.1', '255.255.255.0')
    10.1.1.1/24


    # Print out all useful information:
    >>> a = CIDR('10.1.1.1/24')
    >>> a.address
    '10.1.1.1'
    >>> a.netmask
    '255.255.255.0'
    >>> a.bits
    '24'
    >>> a.netaddress
    '10.1.1.0'
    >>> a.broadcast
    '10.1.1.255'
    >>> a.subnet
    '10.1.1.0/24'


    # is in subnet?
    >>> '10.1.1.2' in a
    True
    >>> '10.1.1.2/25' in a
    True
    >>> '10.1.2.2/25' in a

    >>> c = CIDR('10.3.3.3/24')
    >>> c in a
    False
    >>> a in a
    True
    >>> d = CIDR('10.1.1.3/25')
    >>> d in a
    True

    # split the subnet in 2 pieces
    >>> a / 2
    10.1.1.1/26
    # make the subnet 2 times larger
    >>> a * 2
    10.1.1.1/22

    # calculate with ip addresses
    >>> a + 4
    10.1.1.5/24
    >>> a - 1
    10.1.1.0/24

    # calculate next/previous subnet
    >>> (CIDR(a.broadcast, a.bits) + 1).subnet
    '10.1.2.0/24'
    >>> (CIDR(a.netaddress, a.bits) - 1).subnet
    '10.1.0.0/24'

    # iterate through next valid ips
    >>> for i in CIDR('10.1.1.250/24'):
    ...     print i
    ...
    10.1.1.251
    10.1.1.252
    10.1.1.253
    10.1.1.254

    # return first and last ip
    >>> CIDR('10.1.1.1/24').firstIp()
    10.1.1.1
    >>> CIDR('10.1.1.1/24').lastIp()
    10.1.1.254

    # creating custom ip-ranges
    >>> CIDR('10.1.1.1/24').firstIp('10.1.1.25')
    10.1.1.25
    >>> CIDR('10.1.1.1/24').lastIp('10.1.1.80')
    10.1.1.80

    # masking ip addresses in order to fit in subnet
    >>> CIDR('10.1.1.1/24').firstIp('192.168.11.15', calc=True)
    10.1.1.15
    >>> CIDR('10.1.1.1/24').lastIp('192.168.11.20', calc=True)
    10.1.1.20

    """

    # XXX: unittests are missing!

    def __init__(self, value, mask=None):
        if (isinstance(value, types.IntType) or
            isinstance(value, types.LongType)):
            value = str(value)
        if mask and (
            isinstance(mask, types.IntType) or
            isinstance(mask, types.LongType)):
            mask = str(mask)
        self._obj = iplib.CIDR(value, mask)
        self._cache = {}

    @property
    def address(self):
        """
        returns ip address

        >>> CIDR('10.1.1.1/24').address
        '10.1.1.1'
        """
        if 'address' not in self._cache:
            self._cache['address'] = self._obj.get_ip().get()
        return self._cache['address']

    @property
    def bits(self):
        """
        returns bits representation of netmask

        >>> CIDR('10.1.1.1/24').bits
        '24'
        """
        if 'bits' not in self._cache:
            self._cache['bits'] = self._obj.get_netmask().get_bits()
        return self._cache['bits']

    @property
    def netmask(self):
        """
        returns netmask of subnet

        >>> CIDR('10.1.1.1/24').netmask
        '255.255.255.0'
        """
        if 'netmask' not in self._cache:
            self._cache['netmask'] = self._obj.get_netmask().get()
        return self._cache['netmask']

    @property
    def netaddress(self):
        """
        returns network address of subnet

        >>> CIDR('10.1.1.1/24').netaddress
        '10.1.1.0'
        """
        if 'netaddress' not in self._cache:
            ipobj = None
            if self.bits == '32':
                ipobj = self._obj.get_ip()
            else:
                ipobj = self._obj.get_network_ip()
            self._cache['netaddress'] = ipobj.get()
        return self._cache['netaddress']

    @property
    def broadcast(self):
        """
        returns broadcast address of subnet

        >>> CIDR('10.1.1.1/24').broadcast
        '10.1.1.255'
        """
        if 'broadcast' not in self._cache:
            ipobj = None
            if self.bits == '32':
                ipobj = self._obj.get_ip()
            else:
                ipobj = self._obj.get_broadcast_ip()
            self._cache['broadcast'] = ipobj.get()
        return self._cache['broadcast']

    @property
    def subnet(self):
        """
        returns subnet of ip/bits representation

        >>> CIDR('10.1.1.1/24').subnet
        '10.1.1.0/24'
        """
        if 'subnet' not in self._cache:
            self._cache['subnet'] = "%s/%s" % (self.netaddress, self.bits)
        return self._cache['subnet']

    @property
    def ipbits(self):
        """
        returns ip/bits string representation

        >>> CIDR('10.1.1.1/24').ipbits
        '10.1.1.1/24'
        """
        if 'ipbits' not in self._cache:
            self._cache['ipbits'] = "%s/%s" % (self.address, self.bits)
        return self._cache['ipbits']

    def __str__(self):
        return self.ipbits

    def __repr__(self):
        return self.ipbits

    def __contains__(self, ipornet):
        """
        returns True if '''ipornet''' is part of this subnet.
        '''ipornet''' may be a string or CIDR representation of
        an ip or whole subnet.

        >>> '10.1.1.1' in a
        True
        >>> '10.1.1.6/25' in a
        True
        >>> CIDR('10.1.1.2/25') in a
        True
        """
        check = ipornet
        if isinstance(ipornet, CIDR):
            check = ipornet.ipbits
        return self._obj.is_valid_ip(check) == 1

    def __div__(self, value):
        """
        decreases subnet netmask by '''value'''.

        >>> CIDR('10.1.1.1/24') / 2
        10.1.1.1/26

        """
        newbits = int(self.bits) + value
        if newbits > 32:
            raise InvalidSubnet("Resulting IPv4 bitmask cannot be "
                                "greater than 32 bits.")
        return CIDR(self.address, str(newbits))

    def __mul__(self, value):
        """
        increases subnet netmask by '''value'''.

        >>> CIDR('10.1.1.1/24') * 2
        10.1.1.1/22

        """
        newbits = int(self.bits) - value
        if newbits < 0:
            raise InvalidSubnet("Resulting IPv4 bitmask cannot be negative.")
        return CIDR(self.address, str(newbits))

    def __add__(self, value):
        """
        adds '''value''' to ip address.

        >>> CIDR('10.1.1.253/24') + 10
        10.1.2.7/24

        """
        addr = int(self._obj.get_ip().get_dec()) + value
        if addr > MAXIP:
            raise InvalidIp("Resulting IPv4 address too large")
        return CIDR(str(addr), str(self.bits))

    def __sub__(self, value):
        """
        substracts '''value''' from ip address.

        >>> CIDR('10.1.1.1/24') - 10
        10.1.0.247/24

        """
        addr = int(self._obj.get_ip().get_dec()) - value
        if addr < 0:
            raise InvalidIp("Resulting IPv4 address cannot be negative")
        return CIDR(str(addr), str(self.bits))

    def __iter__(self):
        """
        iterates through valid ip addresses of subnet, beginning with
        the ip address of the current CIDR representation.


        >>> for i in CIDR('10.1.1.252/24'):
        ...     print i
        ...
        10.1.1.253
        10.1.1.254

        """
        hadactual = False
        for i in self._obj.get_all_valid_ip():
            if not hadactual:
                if i == self._obj.get_ip():
                    hadactual = True
                continue
            yield i.get()

    def __eq__(self, obj):
        """
        returns True if two instances hold the same
        ip/bits representation.

        >>> CIDR('10.1.1.1/24') == CIDR('10.1.1.1/255.255.255.0')
        True
        """
        if not isinstance(obj, CIDR):
            return False
        return obj.ipbits == self.ipbits

    def __ne__(self, obj):
        """
        returns True if two instances do not hold the same
        ip/bits representation.

        >>> CIDR('10.1.1.1/24') != CIDR('10.2.2.2/255.255.255.0')
        True
        """
        if not isinstance(obj, CIDR):
            return True
        return obj.ipbits != self.ipbits

    def firstIp(self, ip=None, calc=False):
        """
        returns the first ip address of the subnet.

        If 'ip' is set it will be used as a custom first ip address
        if it fits within the subnet, otherwise the first ip will
        be returned

        If 'calc' is True and 'ip' does not fit into the subnet
        it will be masked in order to calculate a valid ip
        address with the least significant bits of 'ip'.

        This is useful for working with ip-ranges.

        # simple cases
        >>> CIDR('10.1.1.1/24').firstIp()
        10.1.1.1
        >>> CIDR('10.1.1.1/24').firstIp('10.1.1.50')
        10.1.1.50
        # case where it does not fit within subnet
        >>> CIDR('10.1.1.1/24').firstIp('192.168.11.80')
        10.1.1.1
        # calculating the ip address
        >>> CIDR('10.1.1.1/24').firstIp('192.168.11.80', True)
        10.1.1.80

        """
        if not ip:
            return self._obj.get_first_ip().get()
        ipobj = CIDR(ip, '32')
        if ipobj in self:
            return ipobj.address
        if not calc:
            return self._obj.get_first_ip().get()

        binmask = long(self._obj.get_netmask().get_dec())
        binip = long(ipobj._obj.get_ip().get_dec())
        binnetaddr = long(self._obj.get_network_ip().get_dec())
        binret = (~binmask & binip) | binnetaddr
        return iplib.CIDR(str(binret), '32').get_ip().get()


    def lastIp(self, ip=None, calc=False):
        """
        returns the last ip address of the subnet.

        If 'ip' is set it will be used as a custom last ip address
        if it fits within the subnet, otherwise the last ip will
        be returned.

        If 'calc' is True and 'ip' does not fit into the subnet
        it will be masked in order to calculate a valid ip
        address with the least significant bits of 'ip'.

        This is useful for working with ip-ranges.

        # simple cases
        >>> CIDR('10.1.1.1/24').lastIp()
        10.1.1.254
        >>> CIDR('10.1.1.1/24').lastIp('10.1.1.50')
        10.1.1.50
        # case where it does not fit within subnet
        >>> CIDR('10.1.1.1/24').lastIp('192.168.11.80')
        10.1.1.254
        # calculating the ip address
        >>> CIDR('10.1.1.1/24').lastIp('192.168.11.80', True)
        10.1.1.80

        """
        if not ip:
            return self._obj.get_last_ip().get()
        ipobj = CIDR(ip, '32')
        if ipobj in self:
            return ipobj.address
        if not calc:
            return self._obj.get_last_ip().get()

        binmask = long(self._obj.get_netmask().get_dec())
        binip = long(ipobj._obj.get_ip().get_dec())
        binnetaddr = long(self._obj.get_network_ip().get_dec())
        binret = (~binmask & binip) | binnetaddr
        return iplib.CIDR(str(binret), '32').get_ip().get()

    def split(self):
        """
        Split the network into 2 subnet
        >>> CIDR('192.168.100.0/24').split()
        (192.168.100.0/25, 192.168.100.126/25)
        """
        bits = int(self.bits) + 1
        if bits > 32:
            return (self, None) # unsplittable
        elif bits == 32:
            base_address = self.address
        else:
            base_address = self.netaddress
        a = CIDR("%s/%s" % (base_address, bits))
        delta = 2 ** (32 - bits)
        b = a + delta
        return (a, b)


class IPAddress(CIDR):
    def __init__(self, value):
        CIDR.__init__(self, value, 32)
