#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2012 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from UserDict import IterableUserDict
import string

#
# This is a fix of deepcopy necessary in python versions prior to 2.5
# Without this fix deepcopy is not able to copy variables which contain
# functions (self.method = string.upper)
import copy
import types
copy._deepcopy_dispatch[types.FunctionType] = copy._deepcopy_atomic
# end of the fix

__all__ = ['CaseInsensitiveDict',
           'ConfigDict']

class CaseInsensitiveDict(IterableUserDict):
    def __init__(self, d=None, caseMethod=string.upper, **kwargs):
        self._attributes = [
            'origkeys',
            'data',
            'method',
            ]
        self.origkeys = {}
        self.data = {}
        self.method=caseMethod
        IterableUserDict.__init__(self, d, **kwargs)
    def __setitem__(self, key, item):
        newkey = self.method(key)
        IterableUserDict.__setitem__(self, newkey, item)
        self.origkeys[newkey] = key
    def set(self, key, value):
        self[key] = value
    def __getitem__(self, key):
        return IterableUserDict.__getitem__(self, self.method(key))
    def get(self, key, failobj=None):
        return IterableUserDict.get(self, self.method(key), failobj)
    def __delitem__(self, key):
        return IterableUserDict.__delitem__(self, self.method(key))
    def __contains__(self, key):
        return IterableUserDict.__contains__(self, self.method(key))
    def has_key(self, key):
        return IterableUserDict.has_key(self, self.method(key))
    def pop(self, key, *args):
        return IterableUserDict.pop(self, self.method(key), *args)
    def update(self, d=None, **kwargs):
        update = IterableUserDict(d, **kwargs)
        for i in update:
            key = self.method(i)
            self.data[key] = update[i]
            self.origkeys[key] = i
    def __str__(self):
        return self.__repr__()


class ConfigDict(CaseInsensitiveDict):
    def __init__(self, d=None, caseMethod=string.lower, **kwargs):
        CaseInsensitiveDict.__init__(self, d, caseMethod, **kwargs)
    def __getattr__(self, key):
        try:
            if key.startswith('_') or key in self._attributes:
                return self.__dict__[key]
            else:
                return CaseInsensitiveDict.__getitem__(self, key)
        except KeyError:
            raise AttributeError("'ConfigDict' object has "
                                 "no attribute '%s'"%key)
    def __setattr__(self, key, value):
        if key.startswith('_') or key in self._attributes:
            self.__dict__[key] = value
        else:
            CaseInsensitiveDict.__setitem__(self, key, value)
