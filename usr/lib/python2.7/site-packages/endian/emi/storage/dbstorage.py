#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import datetime

from endian.core import logger
from endian.core import timetools
from endian.emi import entities
from endian.emi.storage import Storage

# Lazy import turbogears.identity, endian.emi.entities.types.[asc|desc|session], see:
# http://wiki.python.org/moin/PythonSpeed/PerformanceTips#Import_Statement_Overhead
identity = None
asc = None
desc = None
session = None
lookup_entity_register = None

__all__ = [ 'DBStorage' ]

class DBStorage(Storage):
    
    #: define if this storage support ordering by multiple fields
    multi_order_by = True
    
    def __init__(self, entity):
        self._transaction_started = False
        self._transaction_master = None
        self._transaction_children = []
        self.changed = False
        self.entity = entity
        self.schema = entity.schemaClass()
        self.keys = self.schema.fields.keys()
        self.search_keys = self.entity.search_keys
        if not self.search_keys:
            self.search_keys = self.keys
        self.exclude_from_search = self.entity.exclude_from_search
    
    def _userOrIdentity(self, user):
        global identity
        if identity is None: # Lazy import identity
            from turbogears import identity
        if user is not None:
            return user
        else:
            return identity.current.user
    
    def _order_by(self,
            query,
            order_by,
            order_sort):
        global asc, desc, lookup_entity_register
        if asc is None or desc is None or lookup_entity_register is None: # Lazy import
            from endian.emi.entities.types import asc, desc
            from endian.emi.entities.entities_register import lookup_entity_register
        
        if order_by is None:
            order_by = [self.entity.id]
        elif not isinstance(order_by, list):
            order_by = [order_by]
        
        if order_sort == "asc":
            order_sort = asc
        else:
            order_sort = desc
        tmp = []
        for field in order_by:
            if not isinstance(field, basestring):
                tmp.append(order_sort(field))
                continue
            if len(field.split(".")) > 1:
                field = field.split(".")
                # lookup this entity from the registry 
                entity = lookup_entity_register(field[0])
                field = field[1]
            else:
                # use the main entitiy of the storey
                entity = self.entity
            # eval the entity field
            field = getattr(entity, field)
            tmp.append(order_sort(field))
        
        query = query.order_by(*tmp)
        return query
    
    def _load(self,
            id=None,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission="view",
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            load_optional_args=None,
            **args):
        """
        Load a list of objects or a single object based on the id

        :param id:                      object id, if None returns a list of objects
        :type id:                       int, str, etc.
        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param load_optional_args:      optional arguments passed to load function
        :type load_optional_args:       dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        global session
        if session is None: # Lazy import
            from endian.emi.entities.types import session
        
        if id is None: # load a list of object
            query = session.query(self.entity)
            
            if not disable_filter_query and hasattr(self.entity, 'filterQuery'):
                query = self.entity.filterQuery(query, current_identity)
            
            query = self._order_by(query=query, order_by=order_by, order_sort=order_sort)
            return query
        
        # try to convert to int
        try:
            id = int(id)
        except:
            pass
        obj = session.query(self.entity).get(id)
        # Authorization
        if self.entity.acl is not None and obj is not None:
            hasAccess = obj.acl_has_access(current_identity)
            isOwner = obj.acl_is_owner(current_identity)
            self.entity.acl.check_permission(required_permission, current_identity=current_identity, hasAccess=hasAccess, isOwner=isOwner)
        if raw:
            return obj
        else:
            return self._asDict(obj)
    
    def _get_filter(self, this, operator, that):
        if that is None:
            return None
        
        if operator in ["eq", "neq", "lt", "lte", "gt", "gte"]:
            try:
                converted_that = timetools.datetime_from_ISO8601(that)
                converted_that = timetools.utcdatetime_to_datetime(converted_that)
                that = timetools.datetime_to_timestamp(converted_that)
            except (ValueError, TypeError):
                if operator == "timedelta":
                    return None
        elif operator == "timedelta":
            try:
                delta_hours = int(that)
                now = datetime.datetime.now()
                now = now.replace(microsecond=0)
                now = now.replace(second=0)
                now = now.replace(minute=0)
                if delta_hours > 24 and (delta_hours % 24) == 0:
                    now = now.replace(hour=0)
                    now += timetools.ONE_DAY
                else:
                    now += timetools.ONE_HOUR
                that = now - datetime.timedelta(hours=delta_hours)
                that = timetools.datetime_to_timestamp(that)
            except:
                return None
        
        if operator == "eq":
            return this == that
        elif operator == "neq":
            return this != that
        elif operator == "lt":
            return this < that
        elif operator == "lte":
            return this <= that
        elif operator == "gt":
            return this > that
        elif operator == "gte" or operator == "timedelta":
            return this >= that
        elif operator == "startswith":
            return this.ilike("%s%%" % that)
        elif operator == "endswith":
            return this.ilike("%%%s" % that)
        elif operator == "contains":
            return this.ilike("%%%s%%" % that)
        elif operator == "doesnotcontain":
            return entities.not_(this.ilike("%%%s%%" % that))
        else:
            return None
    
    def _get_filters(self, filters, logic=None):
        global lookup_entity_register
        if lookup_entity_register is None: # Lazy import
            from endian.emi.entities.entities_register import lookup_entity_register
        
        if isinstance(filters, dict):
            return self._get_filters(filters.get("filters"), filters.get("logic"))
        queries = []
        if logic == "or":
            joiner = entities.or_
        else:
            joiner = entities.and_
        for filter_ in filters:
            if isinstance(filter_, dict):
                query = self._get_filters(filter_.get("filters"), filter_.get("logic"))
                if query is None:
                    continue
                queries.append(query)
                continue
            field, operator, value = filter_
            if len(field.split(".")) > 1:
                field = field.split(".")
                # lookup this entity from the registry 
                entity = lookup_entity_register(field[0])
                field = field[1]
            else:
                # use the main entitiy of the storey
                entity = self.entity
            field = getattr(entity, field)
            
            query = self._get_filter(field, operator, value)
            if query is None:
                continue
            queries.append(query)
        if len(queries) == 0:
            return None
        if len(queries) == 1:
            return queries[0]
        return joiner(*queries)
   
    def _filter(self,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission="view",
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            filters={},
            search_keys=[],
            filter_optional_args=None,
            **args):
        """
        Return a list of objects according to the filter conditions

        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param filters:                 filters conditions
        :type filters:                  dict
        :param search_keys:             list of keys to be used for searching 
        :type search_keys:              list
        :param filter_optional_args:    optional arguments passed to filter function
        :type filter_optional_args:     dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        global session
        if session is None: # Lazy import
            from endian.emi.entities.types import session
        
        query = session.query(self.entity)
        
        try:
            filters = self._get_filters(filters)
        except:
            import traceback
            traceback.print_exc()
            filters = None
        if not filters is None:
            query = query.filter(filters)
            
        if not disable_filter_query and hasattr(self.entity, 'filterQuery'):
            query = self.entity.filterQuery(query, current_identity)
        
        query = self._order_by(query=query, order_by=order_by, order_sort=order_sort)
        return query
    
    def _store(self, data, id=None, current_identity=None):
        """
        Create/Update the table row with data
        """
        global session
        if session is None: # Lazy import
            from endian.emi.entities.types import session

        try:
            if id is None:
                id = int(data.get("ID"))
        except:
            pass
        
        # Load item for id
        try:
            session.begin()
            if id is None:
                obj = self.entity()
                session.add(obj)
            else:
                obj = session.query(self.entity).get(id)
            
            if self.entity.acl is not None:
                hasAccess = obj.acl_has_access(current_identity)
                isOwner = obj.acl_is_owner(current_identity)
            else:
                hasAccess = True
                isOwner = False
            
            # Authorization
            if self.entity.acl is not None:
                if id is None:
                    self.entity.acl.check_permission('create', current_identity=current_identity, hasAccess=hasAccess, isOwner=isOwner)
                else:
                    self.entity.acl.check_permission('edit', current_identity=current_identity, hasAccess=hasAccess, isOwner=isOwner)
            
            # Update values
            obj = self._updateFromDict(obj, data, current_identity, hasAccess, isOwner)
            # obj["ID"] = id
            
            # Commit the changes to the database.
            session.commit()
            
            asDict = self._asDict(obj)
            return asDict
        
        except Exception, e:
            import traceback
            traceback.print_exc()
            session.rollback()
            raise e
    
    def delete(self, id, current_identity=None):
        """
        Delete an object from the db
        """
        global session
        if session is None: # Lazy import
            from endian.emi.entities.types import session

        try:
            session.begin()
            obj = session.query(self.entity).get(id)
            if obj is not None:
                # Authorization
                if self.entity.acl is not None:
                    hasAccess = obj.acl_has_access(current_identity)
                    isOwner = obj.acl_is_owner(current_identity)
                    self.entity.acl.check_permission('delete', current_identity=current_identity, hasAccess=hasAccess, isOwner=isOwner)
                # Delete
                session.delete(obj)
            session.commit()
        except Exception, e:
            session.rollback()
            raise e
                        
    def _updateFromDict(self, object, data, current_identity, hasAccess, isOwner):
        """Update the object from the values of a dictionary."""
        for key, value in data.iteritems():
            if key != "ID" and hasattr(object, key):
                # Authorization
                #if key == 'activated' and self.entity.acl != None:
                #    self.entity.acl.check_permission('enable', current_identity, hasAccess, isOwner)
                setattr(object, key, value)
        return object
    
    def _asDict(self, obj):
        if obj is None:
            return {}
        else:
            return obj.asDictionary(uppercaseId = True)

