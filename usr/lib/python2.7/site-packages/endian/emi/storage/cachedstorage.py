#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

# Indexes code from PyDbLite.py
# BSD licence
# Author : Pierre Quentel (pierre.quentel@gmail.com)

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-08-01"

import os
import copy
import bisect
import threading
import cPickle
from endian.emi.storage import Storage
from endian.core import logger

__all__ = [
    'CachedStorage',
    'CacheEntry'
]

_cache = {}

INDEX_PREFIX = "_index_"

class CacheEntry(object):

    path = None
    namespace = None
    cache_path = None
    values = None
    modification_time = -1
    storage_indexes = None
    indexes = {}
    verbose = None

    def __init__(self, path, namespace, cache_type="disabled", indexes=None, fields=None, schema=None, verbose=False):
        self._lock = threading.RLock()
        self.path = path
        self.namespace = namespace
        self.cache_type = cache_type
        self.storage_indexes = indexes
        self.fields = fields
        self.schema = schema
        self.verbose = verbose
        if self.cache_type == "file":
            self.cache_path = "/var/cache/%s" % namespace
            try:
                self._restore_from_file_cache()
            except:
                logger.debug("Storage '%s' not already cached, loading" % (self.namespace))
        self.update()

    def update(self, force=False):
        if not self.values:
            self.values = {}

        if self.is_valid() and not force:
            logger.debug("Cached storage '%s' cache is valid (%d items)" % (self.namespace, len(self.values)))
            return
        else:
            logger.debug("Cached storage '%s' cache expired (%d items)" % (self.namespace, len(self.values)))

        self.values = self.get_values()
        if not isinstance(self.values, dict):
            raise Exception("CacheEntry requires a dict return value from the get_values method")

        # Create the indexes
        self.indexes = {}
        for index in self.storage_indexes or []:
            try:
                self.create_index(index)
            except Exception, ex:
                logger.error("Error creating index '%s' on '%s': %s" %
                            (index, self.namespace, str(ex)),
                            exc_info=True)

        if self.cache_type == "memory":
            logger.debug("Cached storage '%s' cache to memory" % self.namespace)
            # Store the cache_entry in the memory cache
            _cache[self.path] = self
        elif self.cache_type == "file":
            logger.debug("Cached storage '%s' cache to file" % self.namespace)
            self._store_to_file_cache()
        else:
            logger.debug("Cached storage '%s' do not cache" % self.namespace)

    def _store_to_file_cache(self, cache_data={}):
        cache_data["indexes"] = self.indexes
        cache_data["values"] = self.values
        cache_data["modification_time"] = self.modification_time
        cache_file = open(self.cache_path, "wb")
        cPickle.dump(cache_data, cache_file)
        cache_file.close()
        del cache_data

    def _restore_from_file_cache(self):
        logger.debug("restore from cache file: %s" % self.cache_path)
        cache_file = open(self.cache_path, "rb")
        cache_data = cPickle.load(cache_file)
        cache_file.close()
        self.indexes = cache_data.get("indexes", {})
        self.values = cache_data.get("values", {})
        self.modification_time = cache_data.get("modification_time", 0)
        return cache_data

    def get_value(self, id):
        """
            Put your code to read the value of an specific id here
            Per default it will read the value from self.values.
        """
        return self.values.get(id, None)

    def get_values(self):
        """
            Put your code to read the values here
            Needs to return a dict
        """
        raise NotImplementedError

    def create_index(self, index):
        """
            Create an index on the specified field names

            An index on a field is a mapping between the values taken by the
            field and the sorted list of the ids of the records whose field
            is equal to this value.

            For each indexed field, an attribute of self is created, an
            instance  of the class CacheEntryIndex. Its name it the field
            name, with the prefix _index_ to avoid name conflicts.
        """
        # Initialize the indexes
        new_indexes = {}
        for id, item in self.values.iteritems():
            # Use bisect to quickly insert the id in the list
            bisect.insort(new_indexes.setdefault(item.get(index, ""), []), id)
        self.indexes[index] = new_indexes
        # Create a new attribute used to find the items by this index
        # setattr(self, INDEX_PREFIX + index, CacheEntryIndex(self, index))

    def update_indexes(self, action, item, old_item=None):
        """ action = insert, update, delete """
        try:
            try:
                self.acquire_lock()
                id = item['ID']
                if action == 'insert':
                    for index in self.indexes.keys():
                        bisect.insort(self.indexes[index].setdefault(item.get(index, ""),[]), id)

                elif action == 'update':
                    for index in set(self.indexes.keys()) & set(item.keys()):
                        if old_item.get(index, "") == item.get(index, ""):
                            continue
                        # Remove id for the old value
                        old_pos = bisect.bisect(self.indexes[index][old_item.get(index, "")], id) - 1
                        del self.indexes[index][old_item[index]][old_pos]
                        if not self.indexes[index][old_item[index]]:
                            del self.indexes[index][old_item[index]]
                        # Insert new value
                        bisect.insort(self.indexes[index].setdefault(item.get(index, ""),[]), id)

                elif action == 'delete':
                    # Remove id from indexes
                    for index in self.indexes.keys():
                        pos = bisect.bisect(self.indexes[index][item.get(index, "")], id) - 1
                        try:
                            del self.indexes[index][item.get(index, "")][pos]
                            if not self.indexes[index][item.get(index, "")]:
                                del self.indexes[index][item.get(index, "")]
                        except:
                            pass
            finally:
                self.release_lock()
        except Exception, ex:
            logger.error("Error updating indexes (action: %s, item: %s): %s",
                    action,
                    item and item.get('ID', "") or "",
                    str(ex))
            raise ex

    def _delete(self, id):
        """
            Put your delete action here
            Needs to return a boolean
        """
        raise NotImplementedError

    def delete(self, id):
        """
            Trigger delete action and update the modification time on success
        """
        ret = self._delete(id)
        if ret is None:
            raise Exception("CacheEntry requires a boolean return value from the _delete method")
        if ret:
            self._update_modification_time()

    def _save(self):
        """
            Put your save action here
            Needs to return a boolean
        """
        raise NotImplementedError

    def save(self):
        """
            Save the values dictionary
        """
        ret = self._save()
        if ret is None:
            raise Exception("CacheEntry requires a boolean return value from the _save method")
        if ret:
            self._update_modification_time()

    def _update_modification_time(self):
        if self.path:
            self.modification_time = self._get_modification_time()

    def is_valid(self):
        valid = self.modification_time >= self._get_modification_time()
        return valid

    def _get_modification_time(self, path=None):
        if path is None:
            path = self.path
        try:
            return os.path.getmtime(path)
        except:
            return 0

    def acquire_lock(self):
        """
            Acquire the CacheEntry-level lock.
            This should be released with _release_lock()
        """
        self._lock.acquire()

    def release_lock(self):
        """
            Release the CacheEntry-level lock acquired by calling _acquire_lock().
        """
        self._lock.release()

class CachedStorage(Storage):
    """
    Load/store dictionaries.

    Each dictionary needs to have an ID key, that is used for its identification.
    """

    cache_entry_class = CacheEntry
    cache_type = "memory" # supported is "disabled", "memory" and "file"

    def __init__(self, entity=None, namespace=None, indexes=None, cache_type=None, verbose=None):
        if namespace is None and entity is None:
            raise("entity or namespace must be not none")
        if not namespace:
            namespace = entity._namespace
        if not cache_type and entity is not None: # use cache type from entity (defined in schema)
            cache_type = entity._cache_type
        if not cache_type: # use default cache type
            cache_type = "memory" # use memory as default value
        if verbose is None and entity is not None:
            verbose = entity._verbose

        self.path = self._get_path(namespace)
        self._file_lock = threading.Lock()
        self.namespace = namespace
        self.cache_type = cache_type
        self.indexes = indexes
        self.verbose = verbose
        self.changed = False
        if entity:
            self.entity = entity
            self.schema = entity.schemaClass()
            self.keys = self.schema.fields.keys()
            self.search_keys = self.entity.search_keys # list of field keys to use for search with search_string (contains)
            if not self.search_keys:
                self.search_keys = self.keys
            self.exclude_from_search = self.entity.exclude_from_search # list of field keys not to be used for search with search_string (contains)
            if not 'ID' in self.keys:
                self.keys.append('ID')
        else:
            self.entity = None
            self.schema = None
            self.keys = None # storage fields (None = any fields can be added)
        # Create the directory if it does not exist
        try:
            os.makedirs(os.path.dirname(self.path))
        except:
            pass
        super(CachedStorage, self).__init__(self.schema)

    def _get_path(self, namespace):
        raise NotImplementedError

    def _load(self,
            id=None,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission='view',
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            load_optional_args=None,
            **args):
        """
        Load a list of objects or a single object based on the id

        :param id:                      object id, if None returns a list of objects
        :type id:                       int, str, etc.
        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param load_optional_args:      optional arguments passed to load function
        :type load_optional_args:       dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        cache_entry = self._get_cache_entry()
        if id is None: # return all entries
            if self.cache_type == "memory":
                values = cache_entry.values.copy() # avoid exception 'dictionary changed size during iteration'
                del cache_entry
            else:
                values = cache_entry.values

            # Authorization
            if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_filter_values'):
                values = self.entity.acl_filter_values(values, required_permission, current_identity=current_identity)

            if order_by: # sort by row value and create a list of tuples
                logger.debug("Cached storage '%s' order values by: %s" % (self.namespace, order_by))
                values = sorted(values.iteritems(), key=lambda (k,v): v.get(order_by), reverse=(order_sort == "desc" and True or False))
            else:
                values = sorted(values.iteritems(), key=lambda (k,v): k)

            if self.entity is not None: # return a list of entities
                values = [self._prepare_entity(value, value_id) for value_id, value in values]
            else: # return a list of dictionaries
                values = [self._prepare_dict(value, value_id) for value_id, value in values]

            if self.cache_type != "memory":
                del cache_entry

            return values

        # return one entry
        try:
            id = int(id)
        except:
            logger.debug("Cached storage '%s' id is not int" % self.namespace)

        try:
            value = cache_entry.get_value(id).copy()
        except AttributeError:
            value = None
        del cache_entry

        if value is None:
            return None
        if self.entity is None:
            return self._prepare_dict(value, id) # return a dict

        # Authorization
        value = self._prepare_entity(value, id)
        if check_acl and self.entity.acl is not None:
            has_access = value.acl_has_access(current_identity)
            is_owner = value.acl_is_owner(current_identity)
            self.entity.acl.check_permission(permission=required_permission,
                                             hasAccess=has_access,
                                             isOwner=is_owner)
        return value # return an entity

    def _filter(self,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission="view",
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            filters={},
            search_keys=[],
            filter_optional_args=None,
            **args):
        """
        Return a list of objects according to the filter conditions

        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param filters:                 filters conditions
        :type filters:                  dict
        :param search_keys:             list of keys to be used for searching 
        :type search_keys:              list
        :param filter_optional_args:    optional arguments passed to filter function
        :type filter_optional_args:     dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """

        cache_entry = self._get_cache_entry()
        if self.cache_type == "memory":
            indexes = cache_entry.indexes.copy()
            values = cache_entry.values.copy() # avoid exception 'dictionary changed size during iteration'
            del cache_entry
        else:
            indexes = cache_entry.indexes
            values = cache_entry.values

        index_keys = search_keys.intersection(indexes.keys())

        res = []
        for value_id in values.keys():
            value = values.get(value_id)
            if self._apply_filters(value=value, filters=filters, value_id=value_id, index_keys=index_keys, indexes=indexes):
                res.append(value_id)
        values = dict([(_id, values[_id]) for _id in res])

        # Authorization
        if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_filter_values'):
            values = self.entity.acl_filter_values(values, required_permission, current_identity=current_identity)

        if order_by: # sort by row value and create a list of tuples
            logger.debug("Cached storage '%s' order values by: %s" % (self.namespace, order_by))
            values = sorted(values.iteritems(), key=lambda (k,v): v.get(order_by), reverse=(order_sort == "desc" and True or False))
        else:
            values = sorted(values.iteritems(), key=lambda (k,v): k)

        if self.entity is not None: # return a list of entities
            values = [self._prepare_entity(value, value_id) for value_id, value in values]
        else: # return a list of dictionaries
            values = [self._prepare_dict(value, value_id) for value_id, value in values]

        if self.cache_type != "memory":
            del cache_entry

        return values

    def _prepare_entity(self, value, id):
        if value is None:
            return None
        value['ID'] = id
        entity = self.entity(**value)
        return entity

    def _prepare_dict(self, value, id):
        value['ID'] = id
        if not self.keys:
            return value
        else:
            result_item = {}
            for key in self.keys:
                result_item[key] = value.get(key, None)
            return value  #this is obviously wrong, but it seems this else is never reached

    def delete(self, id=None, check_acl=True):
        """
            Delete an item from the file
        """
        try:
            # Authorization
            if self.entity is not None and self.entity.acl is not None:
                self.load(id, required_permission='delete', check_acl=check_acl)
            cache_entry = self._get_cache_entry()
            try:
                cache_entry.acquire_lock()                   # ---
                item = cache_entry.values[id]                # /|\
                del cache_entry.values[id]                   #  | locked
                cache_entry.update_indexes('delete', item)   #  | region
            finally:                                         # \|/
                cache_entry.release_lock()                   # ---
            cache_entry.delete(id=id)
            del cache_entry
        except Exception, ex:
            del cache_entry
            logger.error("Could not delete '%s': %s" % (id, str(ex)))
            raise Exception("Could not delete '%s': %s" % (id, str(ex)))

    def _store(self, data, id=None, current_identity=None, check_acl=True):
        """
            Create/update an item with data (or a list of items)
        """
        self.changed = True
        cache_entry = self._get_cache_entry()
        if id is None and hasattr(data, "__iter__") and not hasattr(data, "keys"): # Is a list
            result = True
            for item in data:
                result = self._store_item(cache_entry, item, None, current_identity, check_acl) and result
        else: # Is a single item
            result = self._store_item(cache_entry, data, id, current_identity, check_acl)
        try:
            self._file_lock.acquire()
            cache_entry.save()
        finally:
            self._file_lock.release()
            del cache_entry
        return result

    def _store_item(self, cache_entry, data, id, current_identity=None, check_acl=True):
        """
            Create/update a single item
        """
        if id is None:
            try:
                id = data.get("ID")
            except:
                pass
        if id:
            try:
                id = int(id)
            except:
                return False
            item = cache_entry.values.get(id, {})
            if item:
                required_permission = 'edit'
            else:
                required_permission = 'create'
        else:
            item = {}
            if cache_entry.values:
                id = max(cache_entry.values.keys()) + 1
            else:
                id = 1
            required_permission = 'create'
            # Update the ID in the parameters, so in onStoreSuccessfull the id is available
            try:
                data['ID'] = id
            except:
                pass

        if not 'ID' in item:
            item['ID'] = id

        if self.entity is not None and self.entity.acl is not None and check_acl:
            # Check permission
            obj = self._prepare_entity(item, id)

            if required_permission == 'create':
                has_access = True
                is_owner = False
            else:
                has_access = obj.acl_has_access(current_identity)
                is_owner = obj.acl_is_owner(current_identity)

            self.entity.acl.check_permission(permission=required_permission,
                                             hasAccess=has_access,
                                             isOwner=is_owner)

        old_item = copy.copy(item)
        for key, value in data.iteritems():
            if key != 'ID' and (not self.keys or key in self.keys):
                item[key] = value

        try:
            cache_entry.acquire_lock()                               # ---
            cache_entry.values[id] = item                            # /|\
            if required_permission == 'create':                      #  |
                cache_entry.update_indexes('insert', item)           #  | locked
            else:                                                    #  | region
                cache_entry.update_indexes('update', item, old_item) #  |
        finally:                                                     # \|/
            cache_entry.release_lock()                               # ---
            del cache_entry
        return True

    def _get_modification_time(self):
        """
            Return the file modification time
        """
        try:
            return os.path.getmtime(self.path)
        except:
            return 0

    def _get_cache_entry(self):
        """
            Return a CacheEntry instance from the cache or create e new istance

            :return: a cache entry
            :rtype: CacheEntry
        """
        try:
            self._file_lock.acquire()
            # Try to load the dictionary from the memory cache
            if self.cache_type in ["memory", "file"]:
                try:
                    if self.cache_type == "memory":
                        logger.debug("Cached storage '%s' get memory cache" % self.namespace)
                        cache_entry = _cache[self.path]
                        cache_entry.update()
                        return cache_entry
                    elif self.cache_type == "file":
                        logger.debug("Cached storage '%s' get file cache" % self.namespace)
                        return self.cache_entry_class(path=self.path, namespace=self.namespace, cache_type=self.cache_type, indexes=self.indexes, fields=self.fields, schema=self.schema, verbose=self.verbose)
                except Exception, ex:
                    logger.debug("Storage '%s' not already cached, loading" % (self.namespace))

            # Create a new CacheEntry instance
            return self.cache_entry_class(path=self.path, namespace=self.namespace, cache_type=self.cache_type, indexes=self.indexes, fields=self.fields, schema=self.schema, verbose=self.verbose)
        finally:
            self._file_lock.release()

    def select(self, disable_filter_query=False, current_identity=None, required_permission='view', check_acl=True, **args):
        """
            Select the records in the base that verify a predicate and return
            the specified names. If names is [] or None then all the fields are
            returned

            The predicate can be expressed :
            - by a request string and keyword arguments for the values
            - by field_name = value keywords to test equality of fields to values

            Return an instance of ResultSet

            Examples :
            db.select() # return all the records
            db.select(name='user1', type='user') # return the records with name = 'user1' and type = 'user'
        """
        if not args: # Return all the values
            return self.load(disable_filter_query=disable_filter_query,
                             current_identity=current_identity,
                             required_permission=required_permission,
                             check_acl=check_acl)

        cache_entry = self._get_cache_entry()
        values = cache_entry.values.copy() # avoid exception 'dictionary changed size during iteration'

        # Indexes and non-indexes
        keys = args.keys()
        ixs = set(keys).intersection(cache_entry.indexes.keys())
        no_ix = set(keys) - ixs
        if ixs:
            # Fast selection on indexes
            ix = ixs.pop()
            res = set(cache_entry.indexes[ix].get(args[ix],[]))
            if not res:
                return []
            while ixs:
                ix = ixs.pop()
                res = res & set(cache_entry.indexes[ix].get(args[ix],[]))
        else:
            # If no index, initialize result with test on first field
            field = no_ix.pop()
            res = set([k for k, v in values.iteritems() \
                       if v.get(field) == args[field] ])

        # Selection on non-index fields
        for field in no_ix:
            res = res.intersection([ _id for _id in res
                if values[_id].get(field) == args[field] ])
        values = dict([(_id, values[_id]) for _id in res])

        # Authorization
        if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_filter_values'):
            values = self.entity.acl_filter_values(values, required_permission, current_identity=current_identity)

        if self.entity is not None: # Return a list of entities
            return [self._prepare_entity(value, value_id) for \
                         value_id, value in values.iteritems()]
        else: # Return a list of dictionaries
            result = []
            for key, value in values.iteritems():
                result.append(self._prepare_dict(value, key))
            return result
