#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.core import logger

__all__ = ['Storage']

class Storage(object):

    _abstract_class = True
    
    schema = None
    fields = None
    changed = False
    
    search_keys = []
    exclude_from_search = []
    
    #: define if this storage support ordering by multiple fields
    multi_order_by = False
    
    def __new__(cls, *args, **kwargs):
        if cls.__dict__.get("_abstract_class", False):
            raise RuntimeError(cls.__name__ + " is an abstract class")
        return object.__new__(cls)
    
    def __init__(self, schema, *args, **kws):
        """
        Loads/Stores dictionaries from a storage source.

        Each dictionary needs to have an ID key (integer), that is used for its identification.
        The changed attribute is used to show if data of this storage has been changed, it
        may be used by the GUI for checking if ther are any changes to apply.
        """

        self.schema = schema
        self.fields = self.get_fields_from_schema(schema)
        super(Storage, self).__init__(*args, **kws)

    def get_fields_from_schema(self, schema=None):
        """
        Return a list of fieldnames of given schema
        """
        if not schema:
            schema = self.schema
        
        if not schema:
            return []
        schema = schema()
            
        # sort schema fields with some voodoo
        fields = schema.fields
        meta = map(lambda x: x[0], sorted(fields.iteritems(), lambda x, y: x[1].declarative_count-y[1].declarative_count))
        return meta

    def _load(self, **args):
        raise NotImplementedError

    def load(self,
            id=None,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission='view',
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            load_optional_args=None,
            **args):
        """
        Load a list of objects or a single object based on the id

        :param id:                      object id, if None returns a list of objects
        :type id:                       int, str, etc.
        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param load_optional_args:      optional arguments passed to load function
        :type load_optional_args:       dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        return self._load(id=id,
                          raw=raw,
                          current_identity=current_identity,
                          check_acl=check_acl,
                          required_permission='view',
                          order_by=order_by,
                          order_sort=order_sort,
                          disable_filter_query=disable_filter_query,
                          load_optional_args=load_optional_args)
      
    def _apply_filter(self, this, operator, that):
        logger.debug("apply filter: '%s' with '%s' using '%s'" % (this, operator, that))
        if that is None:
            that = ""
        if this is None:
            this = ""
        if operator == "eq":
            this = unicode(this)
            that = unicode(that)
            return this == that
        elif operator == "neq":
            this = unicode(this)
            that = unicode(that)
            return this != that
        elif operator == "lt":
            return this < that
        elif operator == "lte":
            return this <= that
        elif operator == "gt":
            return this > that
        elif operator == "gte":
            return this >= that
        elif operator == "startswith":
            this = unicode(this).lower()
            that = unicode(that).lower()
            return this.startswith(that)
        elif operator == "endswith":
            this = unicode(this).lower()
            that = unicode(that).lower()
            return this.endswith(that)
        elif operator == "contains":
            this = unicode(this).lower()
            that = unicode(that).lower()
            return that in this
        elif operator == "doesnotcontain":
            this = unicode(this).lower()
            that = unicode(that).lower()
            return that not in this
        else:
            return False
    
    def _apply_filters(self,
            value,
            filters,
            logic=None,
            value_id=None,
            index_keys=[],
            indexes={}):
        if isinstance(filters, dict):
            return self._apply_filters(value=value,
                filters=filters.get("filters"),
                logic=filters.get("logic"),
                value_id=value_id,
                index_keys=index_keys,
                indexes=indexes)
        for filter_ in filters:
            if isinstance(filter_, dict):
                valid = self._apply_filters(value=value,
                    filters=filter_.get("filters"),
                    logic=filter_.get("logic"),
                    value_id=value_id,
                    index_keys=index_keys,
                    indexes=indexes)
                if logic == "or" and valid:
                    return True # if one is true, everything is true
                if logic == "and" and not valid:
                    return False # if one is false, everything is false
                continue
            field, operator, search_value = filter_
            if field in index_keys and operator in ["eq", "neq"]:
                ids = indexes.get(field, {}).get(search_value, [])
                if value_id in ids:
                    valid = True
                else:
                    valid = False
                if operator == "neq":
                    if valid:
                        valid = False
                    else:
                        valid = True
            else:
                valid = self._apply_filter(value.get(field), operator, search_value)
            if logic == "or" and valid:
                return True # if one is true, everything is true
            if logic == "and" and not valid:
                return False # if one is false, everything is false
        if logic == "or":
            return False # if nothing was true, everything is false
        if logic == "and":
            return True # if nothing was false, everything is true
    
    def _filter(self, **args):
        raise NotImplementedError
    
    def _parse_kendo_filters(self, raw_filters={}, logic="and", search_keys=set()):
        filters = {
            'filters': [],
            'logic': logic
        }
        for key, value in raw_filters.iteritems():
            if key == "filters": # this is a filter list
                sub_filters = value
                sub_logic = raw_filters.get("logic", logic)
                return self._parse_kendo_filters(raw_filters=sub_filters, logic=sub_logic, search_keys=search_keys)
            elif key == "logic": # this is a filter list
                sub_filters = raw_filters.get("filters", {})
                sub_logic = value
                return self._parse_kendo_filters(raw_filters=sub_filters, logic=sub_logic, search_keys=search_keys)
            elif value.get('filters'): # this contains a filter list
                sub_filters, search_keys = self._parse_kendo_filters(raw_filters=value.get('filters', {}), logic=value.get('logic', logic), search_keys=search_keys)
                if not sub_filters is None:
                    filters['filters'].append(sub_filters)
                continue
            filters['filters'].append((value.get("field"), value.get("operator"), value.get("value")))
            search_keys.add(value.get("field"))
        if len(filters['filters']) == 0:
            return None, search_keys
        if len(filters['filters']) == 1:
            return filters['filters'][0], search_keys
        return filters, search_keys
    
    def filter(self,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission='view',
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            filters={},
            search_string=False,
            filter_optional_args=None,
            **search_args):
        """
        Return a list of objects according to the filter conditions

        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param filters:                 filters conditions
        :type filters:                  dict
        :param search_string:           returns object with a search field matching the search string
        :type search_string:            str
        :param filter_optional_args:    optional arguments passed to filter function
        :type filter_optional_args:     dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        parsed_filters = {
            'filters': [],
            'logic': "and"
        }
        
        search_keys = set()
        
        if search_string:
            search_filter = {
                'filters': [],
                'logic': "or"
            }
            for key in self.search_keys:
                if key in ["ID"]:
                    continue
                if key in self.exclude_from_search:
                    continue
                search_filter['filters'].append((key, "contains", search_string))
            parsed_filters['filters'].append(search_filter)
        
        # parse select values (using eq operator and AND logic)
        for key, value in search_args.iteritems():
            search_keys.add(key)
            parsed_filters['filters'].append((key, "eq", value))
        
        kendo_filter, search_keys = self._parse_kendo_filters(raw_filters=filters, search_keys=search_keys)
        if not kendo_filter is None:
            parsed_filters['filters'].append(kendo_filter)
        
        if len(parsed_filters['filters']) == 0: # Return all the values
            return self.load(id=None,
                raw=raw,
                current_identity=current_identity,
                check_acl=check_acl,
                required_permission=required_permission,
                order_by=order_by,
                order_sort=order_sort,
                disable_filter_query=disable_filter_query,
                load_optional_args=filter_optional_args)
        
        return self._filter(raw=raw,
            current_identity=current_identity,
            check_acl=check_acl, required_permission=required_permission,
            order_by=order_by, order_sort=order_sort,
            disable_filter_query=disable_filter_query,
            filters=parsed_filters,
            search_keys=search_keys,
            filter_optional_args=filter_optional_args)
    
    def select(self, **args):
        import warnings
        warnings.warn("select has been deprecated: use filter instead.", 
            DeprecationWarning, 2)
        return self.filter(**args)
    
    def _store(self, data, **args):
        """
        Store a single dictionary into the data source.
        
        If ID == None a new entry should be created, else the given entry
        will be modified.
        """
        raise NotImplementedError

    def store(self, data, **args):
        return self._store(data, **args)

    def _asDict(self, obj):
        if obj is None:
            return {}
        else:
            return obj.asDictionary(uppercaseId = True)
