#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import os
from endian.core import logger
from endian.emi.storage.textstorage import TextStorage
from endian.data.ds import DataSource
from endian.data.container.settings import SettingsFile
from endian.data.container.jsonconfig import JsonConfigFile
from endian.data.container.csvconfig import CsvConfigFile
from endian.data.container.fileconfig import PlainFile
from endian.datatypes.config_list import ConfigList


class FileAlreadyRegisteredError(Exception):
    pass

class FileNotRegisteredError(Exception):
    pass

class UnknownFileTypeError(Exception):
    pass

SETTINGS = 0
CSV = 1
TEXT = 2
JSON = 3

FILEHANDLERS = {SETTINGS : [],
                CSV : [],
                TEXT : [],
                JSON : [],
                '__FILES__' : {}}

def registerDataSourceHandler(filename,filetype):
    """
    Registers files to a type. This is needed if a file needs to be created by the
    DataSourceStorage. 
    """
    
    global FILEHANDLERS

    if FILEHANDLERS['__FILES__'].has_key(filename):
        try:
            del FILEHANDLERS['__FILES__'][filename]
        except KeyError:
            pass
        for file_handler in [SETTINGS, CSV, TEXT, JSON]:
            try:
                FILEHANDLERS[file_handler].remove(filename)
            except ValueError:
                pass
        
    if filetype == SETTINGS:
        FILEHANDLERS[SETTINGS].append(filename)
    elif filetype == CSV:
        FILEHANDLERS[CSV].append(filename)
    elif filetype == TEXT:
        FILEHANDLERS[TEXT].append(filename)
    elif filetype == JSON:
        FILEHANDLERS[JSON].append(filename)
    else:
        raise UnknownFileTypeError('The file type you tried to register could not be found.')
    
    FILEHANDLERS['__FILES__'][filename] = filetype
        
def createStorage(filename):
    """
    Creates a previously registered storage if DataSourceStorage can not figure out the storage type.
    """
    
    if not FILEHANDLERS['__FILES__'].has_key(filename):
        raise FileNotRegisteredError('%s has not been registered.' %filename)

    file = '/var/efw/%s' %filename.replace('.','/')
    filetype = FILEHANDLERS['__FILES__'][filename]
    if filetype not in [SETTINGS,CSV,TEXT,JSON]:
        raise UnknownFileTypeError('An unknown file type has been registered.')
    elif filetype == SETTINGS:
        return SettingsFile(file)
    elif filetype == CSV:
        modelfile = '/usr/lib/efw/%s' % filename.replace('.','/')
        return CsvConfigFile(modelfile+'.config', file)
    elif filetype == TEXT:
        return PlainFile(file)
    elif filetype == JSON:
        if not os.path.exists(file):
            f = open(file,'w')
            f.write('[]')
            f.close()
        return JsonConfigFile(file)


class DataSourceStorage(TextStorage):
    """
    Loads/Stores dictionaries from/to the DataSource.
    
    Each dictionary needs to have an ID key, that is used for its identification.
    """
    
    def __init__(self, schema, namespace):
        super(DataSourceStorage, self).__init__(schema)
        self.namespace = namespace

    def _load(self, id=None, **args):
        """
        Load a list of objects or a single object based on the id

        :param id:                      object id, if None returns a list of objects
        :type id:                       int
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        ds = self.getData()
        if ds == None:
            return {}
        
        # try to convert to int
        try:
            id = int(id)
        except:
            pass
        
        if isinstance(ds,ConfigList):
            items = []
            for _id, item in enumerate(ds):
                item = dict(item)
                item = self.dictToPython(item)
                item["ID"] = _id
                items.append(item)
        else:
            items = {}
            for _id, item in ds.iteritems():
                item = self.valueToPython(_id,item)
                items[_id] = item
        if id != None:    
            if type(items) == type({}):
                return items.get(id)
            elif type(items) == type([]):
                items = filter(lambda x: x.get('ID') == id, items)
                if len(items) == 1:
                    return items[0]
            return None
        return items
    
    def getData(self):
        '''
        returns the content of the datasource
        '''
        ds = DataSource()
        
        for key in self.namespace.split("."):
            ds = ds.get(key.upper())
        
        if not ds:
            ds = createStorage(self.namespace)
        return ds 
    
    def delete(self, id=None):
        """
        delete an item from the datasource
        """
        try:
            id = int(id)
            items = self.load()
            del items[id]
            self.store(items)
        except:
            raise Exception("Could not delete '%s'" % id)
    
    def _store(self, items, id=None):
        """
        store a list of objects or a single object based on the id
        """
        self.changed = True

        ds = self.getData()
        
        if isinstance(ds,ConfigList):
            if type(items) == list:
                for i, item in enumerate(items):
                    items[i] = self.dictToText(item)
                    if id != None and items[i].get('ID') == id:
                        ds[id] = items[i]
                        ds.write()
                        return True
            elif type(items) == dict:
                item = items
                id = id or item.get("ID")

                # New entries do not have an ID at this point
                new = False
                if id == None or str(id) == '':
                    new = True
                    items = self.load()
                    item['ID'] = len(items)
                    id = len(items)
                try:
                    id = int(id)
                except:
                    raise Exception("Could not store '%s' invalid id: %s" % (item, id))
                items = self.load()
                if new:
                    items.append(item)
                else:
                    i = 0
                    for x in items:
                        
                        if x.get('ID') == id:
                            items[i] = item
                            break
                        i = i + 1
                items = map(lambda item: self.dictToText(item), items)
                ds.data = items
                ds.write()
                return True
        else:
            _items = {}
            for i, item in items.iteritems():
                _items[i] = self.valueToText(i,item)
            items = _items
        
        if not isinstance(ds,CsvConfigFile):
            ds.update(items)
        else:
            ds.data = items
        ds.write()
        return True
        
