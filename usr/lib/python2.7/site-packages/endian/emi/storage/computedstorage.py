#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.emi.storage import Storage

__all__ = ["ComputedStorage"]

class ComputedStorage(Storage):
    """
    Represents a storage which calculates it's fields. The functions used
    for the calculation can be used either by passing a function dict to
    the constructor or making a subclass and creating member functions.

    Generally is passed to the load function nothing and to the store
    function just the function value. There is one exception the
    functions store_by_id and load_by_id, where store receives the id
    and the value and load the id of the field. Those two function
    can be used to react on changing id's.

    The function lookup works as follow:
    
    * functions dict: As first a lookup in the function dict will be made.
    * member: if no function is found a lookup in the members dict will made,
              and searched for a function corresponding to this pattern
              ID_IN_UPPER_CASE_load (XXXX_load) or ID_IN_UPPER_CASE_store
              (XXXX_store)
    * store_by_id/load_by_id: if still no functions is found those functions
              are used as fallbacks.

    It exists one special id called **ALL** which means that no id(or
    id is None) to the load function or a list is passed to the store function.

    If you pass a dict it should have two keys, namely load and store,
    both should be also dict's which for each field the key in **upper** case
    and the respective function to load or store.

    **Store flow**
    If a list is passed to the store function it will search for the id **ALL**,
    otherwise if the dict contains a key "ID" this will used as id.
    If none of both is the case all the key/value pairs of the dict are taken
    and stored seperatly.
    """

    function_dict = {
        "load":{},
        "store":{}
        }
    
    def __init__(self,
                 function_dict=None,
                 *args,
                 **kws):
        """
        """
        if function_dict is not None:
            self.function_dict = function_dict

        kws["schema"] = None
        super(ComputedStorage, self).__init__(*args, **kws)

    def ALL_LOAD(self):
        fields = self.function_dict["load"].items()
        fields += self.get_all_object_functions("_LOAD", ["ALL_LOAD"])
        ret = {}
        for name, fct in fields:
            ret[name] = fct()
        return ret

    def ALL_STORE(self, data_list):
        ret = True
        for date in data_list:
            ret &= self.store(date)
        return ret

    def get_all_object_functions(self, postfix, exclude=[]):
        """
        Default function if all fields are wanted.
        """
        import inspect
        functions = []
        for key, fct in inspect.getmembers(self):
            if key not in exclude and key.upper() == key and key.endswith(postfix):
                functions.append((key.upper()[:-len(postfix)],
                               fct))
        return functions

    def function_object_lookup(self, id, type):
        id = str(id)
        if id.startswith("_"):
            return None#do not want execute certain functions...
        id = ("%s_%s" % (id, type)).upper()

        if hasattr(self, id) and callable(getattr(self, id)):
            return getattr(self, id)

        return None

    def get_function(self, id, dict_name):
        if id is None:
            id = "ALL"
        
        fct = self.function_dict[dict_name].get(id, None)
        if fct is None:
            fct = self.function_object_lookup(id, dict_name)

        return fct

    def get_load_function(self, id):
        return self.get_function(id, "load")

    def get_store_function(self, id):
        return self.get_function(id, "store")

    def load_by_id(self, id):
        """
        load with variable ids
        """
        raise Exception("Could not load item with id: %s" % id)
    
    def _load(self, id=None, **args):
        """
        Load a list of objects or a single object based on the id

        :param id:                      object id, if None returns a list of objects
        :type id:                       int
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        ret = {}
        
        fct = self.get_load_function(id)
        
        if fct is None:
            ret = self.load_by_id(id)
        else:
            ret = fct()
        return ret

    def store_by_id(self, id, date):
        """
        store with variable ids
        """
        raise Exception("Could not store with id: %s" % id)

    def _store(self, data):
        """
        Store a single dictionary into the data source.
        """
        ret = True

        if isinstance(data, list):
            ids = [None]
        elif "ID" in data:
            ids = [data["ID"]]
        else:
            ids = data.keys()

        for id in ids:
            fct = self.get_store_function(id)

            if isinstance(data, list) or "ID" in data:
                date = data
            else:
                date = data[id]

            if fct is None:
                ret &= self.store_by_id(id, date)
            else:
                ret &= fct(date)

        return ret
