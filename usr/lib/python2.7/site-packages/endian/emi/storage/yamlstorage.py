#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-08-01"

import os
import yaml
import errno
try:
    from yaml import CLoader as Loader, CSafeDumper as SafeDumper 
except ImportError:
    from yaml import Loader, SafeDumper

from endian.core import logger
from endian.data.container.yamlconfig import YamlConfigFile
from endian.emi.storage.cachedstorage import CachedStorage, CacheEntry

__all__ = [
    'YamlStorage'
]

class YamlCacheEntry(CacheEntry):
    modelfile = None
    
    def __init__(self, namespace, **args):
        self.modelfile = '/usr/lib/efw/%s' % namespace.replace('.','/')
        super(YamlCacheEntry, self).__init__(namespace=namespace, **args)
    
    def get_values(self):
        """
            Read the file and load the yaml content
        """
        try:
            yamlconfig = YamlConfigFile(self.modelfile+'.config', self.path)
            
            # Update the modification time before parsing the yaml file
            # to be sure it did not change during reading
            self._update_modification_time()
            
            values = {}
            for entry in yamlconfig.data:
                id = entry['ID']
                entry = dict(entry)
                if 'id' in entry:
                    del entry['id']
                entry['ID'] = id
                values[id] = entry
            if not isinstance(values, dict):
                logger.error("Could not load YAML file '%s': found a %s insted of a dictionary" % (self.path, type(values).__name__))
                values = {}
            elif self.verbose:
                logger.info("YAML storage '%s' loaded (%d items)", self.namespace, len(values))
        except Exception, ex:
            ex_errno = getattr(ex, 'errno', None)
            if ex_errno == errno.ENOENT:
                logger.info("YAML file '%s' not found, there is nothing to be loaded" % self.path)
            else:
                logger.error("Could not load YAML file '%s': %s" % (self.path, str(ex)), exc_info=True)
            values = {}
        return values
    
    def _delete(self, id):
        """
            Save the values dictionary to a yaml file
            This will delete the id from the yaml file
        """
        return self._save()
    
    def _save(self):
        """
            Save the values dictionary to a yaml file
        """
        file_content = yaml.dump(self.values, Dumper=SafeDumper)
        try:
            tmp_path = "%s_%d_%d.tmp" % (self.path, os.getpid(), ord(os.urandom(1)[0])) 
            f = open(tmp_path, 'w')
            try:
                f.write(file_content)
            finally:
                f.close()
            os.rename(tmp_path, self.path)
            return True
        except Exception, ex:
            logger.error("Error saving YAML file '%s': %s" % (self.path, str(ex)), exc_info=True)
            raise Exception("Error saving YAML file '%s': %s" % (self.path, str(ex)))
        return False

class YamlStorage(CachedStorage):
    """
    Load/store dictionaries from/to YAML files.
    
    Each dictionary needs to have an ID key, that is used for its identification.
    """
    
    cache_entry_class = YamlCacheEntry
    
    def _get_path(self, namespace):
        return '/var/efw/%s' % namespace.replace('.','/')

if __name__ == "__main__":
    from endian.access.schema import User

    def printAccount(storage):
        for instance in storage.load(check_acl=False):
            print instance, type(instance)
            print

    st = YamlStorage(User, indexes=['name'])
#    st.store({'name':'user1','password':'password1'}, id=1)    
    st.store({'name':'user2','password':'password2'}, id=99, check_acl=False)
    st.store({'name':'user2x'}, id=99, check_acl=False) 
#    st.store({'name':'user3','password':'password3'}, id=3)
#    st.store({'name':'userx'})
    st.delete(99, check_acl=False)
    print st.load('1', check_acl=False)
    print st.load(check_acl=False)
    c = st._get_cache_entry()
#    print c._index_name.keys()
    print st.select(name='uno', check_acl=False)
    print st.select(type='device', check_acl=False)
#    printAccount(st)

