#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import re
import os
import glob
import datetime
from email.Parser import Parser
import endian.core.i18n
from endian.core import logger
from endian.emi.storage.directorystorage import DirectoryStorage, DirectoryCacheEntry

__all__ = [
    'EmailDirectoryStorage',
]


class EmailDirectoryCacheEntry(DirectoryCacheEntry):
    attachment_regex = re.compile("Content-Disposition:\s+attachment", re.IGNORECASE)

    def get_values(self):
        values = {}
        try:
            # update directory modification time before reading the list
            # to be sure it did not change during reading
            self._update_modification_time()
            filelist = glob.glob(os.path.join(self.path, self.file_filter))

            for filepath in filelist:
                # update file modification time before parsing it
                # to be sure it did not change during reading
                filename = os.path.basename(filepath)
                if filename in self.values:
                    info = self.values[filename]
                else:
                    info = {}
                    info['ID'] = filename
                    info['path'] = filepath
                    modification_time = self._get_modification_time(path=filepath)
                    info['lastmodified'] = datetime.datetime.fromtimestamp(modification_time).strftime('%Y-%m-%d %H:%M:%S')
                    info['name'] = filename
                    info['size'] = float(os.path.getsize(filepath))
                    try:
                        self.parse_file_for_cache(info)
                    except Exception, ex:
                        logger.error("Directory storage '%s' could not parse file '%s' (parse_file_for_cache): %s" % (self.namespace, filename, str(ex)), exc_info=True)

                values[filename] = info
            logger.debug("Directory storage '%s' loaded (%d items)", self.namespace, len(values))
        except Exception, ex:
            logger.error("Directory storage '%s' could not read directory '%s': %s" % (self.namespace, self.path, str(ex)), exc_info=True)
            values = {}
        return values

    def is_valid(self):
        if self.modification_time < self._get_modification_time():
            return False
        filelist = glob.glob(os.path.join(self.path, self.file_filter))
        if len(filelist) != len(self.values):
            return False
        for filepath in filelist:
            filename = os.path.basename(filepath)
            if filename not in self.values:
                return False
        return True

    def reencode(self, filepath, description, string, charset):
        for c in charset:
            if not c:
                continue
            try:
                decoded = string.decode(c)
                return decoded
            except:
                continue
        try:
            string = unicode(string)
        except:
            if self.verbose:
                logger.error("Could not decode '%s' of '%s' with charset '%s' to 'utf-8'" % (description, filepath, str(charset)))
            string = _("Could not decode")
        return string

    def parse_file_for_cache(self, info):
        # get quarantine reason if it is a quarantine mail
        reason = os.path.basename(info['path']).split("-")[0]

        info['reason'] = {
            "virus": _("Malware"),
            "spam": _("Spam"),
            "banned": _("Banned"),
            "badh": _("Bad Header")
        }.get(reason, "")

        content = self.read_binary_file(info['path'])
        message = Parser().parsestr(content, headersonly=True)
        charset = message.get_charsets()

        info['from_'] = self.reencode(info['path'], "from", message.get("from", ""), charset)
        info['to'] = self.reencode(info['path'], "to", message.get("to", ""), charset)
        info['subject'] = self.reencode(info['path'], "subject", message.get("subject", ""), charset)

        info['attachment_count'] = len(self.attachment_regex.findall(message.get_payload()))

    def parse_file(self, info):
        content = self.read_binary_file(info['path'])
        message = Parser().parsestr(content)
        del content
        charset = message.get_charsets()

        tos = message.get_all("to", [])
        info['to'] = map(lambda to: self.reencode(info['path'], "to", to, charset), tos)
        ccs = message.get_all("cc", [])
        info['cc'] = map(lambda cc: self.reencode(info['path'], "cc", cc, charset), ccs)
        info['send_date'] = self.reencode(info['path'], "date", message.get("date", ""), charset)

        info['headers'] = []
        for key in message.keys():
            for value in message.get_all(key):
                header = "%s: %s" % (key, value)
                header = self.reencode(info['path'], "header", header, charset)
                info['headers'].append(header)

        info['payload'] = []
        if message.is_multipart():
            for payload in message.get_payload():
                self.parse_payload(info, payload)
        else:
            self.parse_payload(info, message)

        del message

        return info

    def parse_payload(self, info, message):
        if message.is_multipart():
            for p in message.get_payload():
                self.parse_payload(info, p)

        charset = message.get_charsets()

        filename = message.get_filename()
        if filename:
            payload = ""
        else:
            payload = message.get_payload(decode=True)
            if not payload:
                return
            payload = self.reencode(info['path'], "payload", payload, charset)

        payload_info = {
            "content_type": message.get_content_type(),
            "payload": payload,
            "filename": filename,
            "attachment": filename and True or False
        }
        info['payload'].append(payload_info)


class EmailDirectoryStorage(DirectoryStorage):
    """
    Load/store files from/to directory.

    Each email directory needs to have an ID key, that is used for its identification.
    """
    cache_entry_class = EmailDirectoryCacheEntry
