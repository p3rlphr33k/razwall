#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2014 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2014-02-20"

import re
import warnings
from endian.core import timetools
from endian.core import logger
from endian.emi.storage import Storage

__all__ = [ 'MongoStorage' ]

_connection = None

DEFAULT_HOST = "127.0.0.1"
DEFAULT_PORT = 27017

class MongoStorage(Storage):
    
    def __init__(self, entity=None, namespace=None, indexes=None):
        if namespace is None and entity is None:
            raise("entity or namespace must be not none")
        if not namespace:
            namespace = entity._namespace
        if not namespace or "." not in namespace:
            raise("invalid namespace")
        self.db, self.collection_name = namespace.split(".",1)
        self.collection_name = self.collection_name.replace(".", "_")
        
        self.namespace = namespace
        self.indexes = indexes
        self.changed = False
        if entity:
            self.entity = entity
            self.schema = entity.schemaClass()
            self.keys = self.schema.fields.keys()
            self.search_keys = self.entity.search_keys # list of field keys to use for search with search_string (contains)
            if not self.search_keys:
                self.search_keys = self.keys
            self.exclude_from_search = self.entity.exclude_from_search # list of field keys not to be used for search with search_string (contains)
            if not 'ID' in self.keys:
                self.keys.append('ID')
        else:
            self.entity = None
            self.schema = None
            self.keys = None # storage fields (None = any fields can be added)
        super(MongoStorage, self).__init__(self.schema)
    
    @property
    def _connection(self):
        """ Return a connection to MongoDB """
        global _connection
        if _connection is None:
            import pymongo
            _connection = pymongo.MongoClient(DEFAULT_HOST, DEFAULT_PORT)
        return _connection

    @property
    def collection(self):
        return self._connection[self.db][self.collection_name]

    def _load(self,
            id=None,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission="view",
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            load_optional_args=None,
            **args):
        """
        Load a list of objects or a single object based on the id

        :param id:                      object id, if None returns a list of objects
        :type id:                       int, str, etc.
        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param load_optional_args:      optional arguments passed to load function
        :type load_optional_args:       dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        import pymongo
        from bson.objectid import ObjectId
        if id is None: # return all entries
            # Order
            if not order_by:
                order_by = "_id"
            if order_sort == "desc":
                direction = pymongo.DESCENDING
            else:
                direction = pymongo.ASCENDING
            
            # Authorization
            if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_find_condition'):
                find_condition = self.entity.acl_find_condition(required_permission, current_identity=current_identity)
            else:
                find_condition = {}
            
            # Get the items
            values = list(self.collection.find(find_condition).sort(order_by, direction))
            for value in values:
                value['ID'] = value['_id']

            # Authorization (old style)
            if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_filter_values'):
                warnings.warn("use acl_find_condition instead of acl_filter_values with mongostorage", DeprecationWarning, 2)
                values = self.entity.acl_filter_values(values, required_permission, current_identity=current_identity)
            
            if self.entity is not None: # return a list of entities
                return [self._prepare_entity(value) for value in values]
            else: # return a list of dictionaries
                return [self._prepare_dict(value) for value in values]
        
        # return one entry
        if id == "":
            return None
        elif isinstance(id, basestring):
            value = self.collection.find_one({'_id': ObjectId(id)})
        elif isinstance(id, ObjectId):
            value = self.collection.find_one({'_id': id})
        else:
            raise Exception("Invalid id type")
        if value is None:
            return None
        if self.entity is None:
            return self._prepare_dict(value) # return a dict
        
        # Authorization
        value = self._prepare_entity(value)
        if check_acl and self.entity.acl is not None:
            has_access = value.acl_has_access(current_identity)
            is_owner = value.acl_is_owner(current_identity)
            self.entity.acl.check_permission(permission=required_permission,
                                             hasAccess=has_access,
                                             isOwner=is_owner)
        return value # return an entity
    
    def _get_filter(self, this, operator, that):
        if operator in ["eq", "neq", "lt", "lte", "gt", "gte"]:
            try:
                converted_that = timetools.datetime_from_ISO8601(that)
                converted_that = timetools.utcdatetime_to_datetime(converted_that)
                that = timetools.datetime_to_timestamp(converted_that)
            except (ValueError, TypeError):
                if operator == "timedelta":
                    return None
        elif operator == "timedelta":
            try:
                delta = timetools.timedelta(hours=int(that))
                now = timetools.utcnow()
                now = now.replace(microsecond=0)
                now = now.replace(second=0)
                now = now.replace(minute=0)
                now += timetools.ONE_HOUR
                that = now - delta
                that = timetools.datetime_to_timestamp(that)
            except:
                return None
        
        if operator == "eq":
            return { this: that }
        elif operator == "neq":
            return { this: { "$ne": that }}
        elif operator == "lt":
            return { this: { "$lt": that }}
        elif operator == "lte":
            return { this: { "$lte": that }}
        elif operator == "gt":
            return { this: { "$gt": that }}
        elif operator == "gte" or operator == "timedelta":
            return { this: { "$gte": that }}
        elif that is None: # re.escape does not work with None
            return None
        elif operator == "startswith":
            return { this: re.compile("^" + re.escape(that), re.IGNORECASE) }
        elif operator == "endswith":
            return { this: re.compile(re.escape(that) + "$", re.IGNORECASE) }
        elif operator == "contains":
            return { this: re.compile(re.escape(that), re.IGNORECASE) }
        elif operator == "doesnotcontain":
            return { this: re.compile("^((?!" + re.escape(that) + ").)*$", re.IGNORECASE) }
        else:
            return None
    
    def _get_filters(self, filters, logic=None):
        if isinstance(filters, dict):
            return self._get_filters(filters.get("filters"), filters.get("logic"))
        conditions = []
        if logic == "or":
            logic = "$or"
        else:
            logic = "$and"
        for filter_ in filters:
            if isinstance(filter_, dict):
                condition = self._get_filters(filter_.get("filters"), filter_.get("logic"))
                if condition is not None:
                    conditions.append(condition)
            else:
                field, operator, value = filter_
                condition = self._get_filter(field, operator, value)
                if condition is not None:
                    conditions.append(condition)
        if len(conditions) == 0:
            return {}
        if len(conditions) == 1:
            return conditions[0]
        return { logic : conditions }

    def _filter(self,
            raw=True,
            current_identity=None,
            check_acl=True,
            required_permission="view",
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            filters={},
            search_keys=[],
            filter_optional_args=None,
            **args):
        """
        Return a list of objects according to the filter conditions

        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param current_identity:        user identity used from access permission checking
        :type current_identity:         object
        :param check_acl:               if True, check the permission
        :type check_acl:                bool
        :param required_permission:     peremission requested on the object (default: view)
        :type required_permission:      str
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param filters:                 filters conditions
        :type filters:                  dict
        :param search_keys:             list of keys to be used for searching 
        :type search_keys:              list
        :param filter_optional_args:    optional arguments passed to filter function
        :type filter_optional_args:     dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        import pymongo
        # Order
        if not order_by:
            order_by = "_id"
        if order_sort == "desc":
            direction = pymongo.DESCENDING
        else:
            direction = pymongo.ASCENDING
        
        # Authorization
        if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_find_condition'):
            find_condition = { '$and': [
                self.entity.acl_find_condition(required_permission, current_identity=current_identity),
                self._get_filters(filters)
            ]}
        else:
            find_condition = self._get_filters(filters)

        # Get the items
        values = list(self.collection.find(find_condition).sort(order_by, direction))
        for value in values:
            value['ID'] = value['_id']
        
        # Authorization (old style)
        if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_filter_values'):
            warnings.warn("use acl_find_condition instead of acl_filter_values with mongostorage", DeprecationWarning, 2)
            values = self.entity.acl_filter_values(values, required_permission, current_identity=current_identity)
        
        if self.entity is not None: # return a list of entities
            return [self._prepare_entity(value) for value in values]
        else: # return a list of dictionaries
            return [self._prepare_dict(value) for value in values]
    
    def _prepare_entity(self, value):
        if value is None:
            return None
        try:
            value['ID'] = value['_id']
        except:
            pass
        value = dict([(str(k), v) for k, v in value.iteritems() if k != '_id'])
        entity = self.entity(**value)
        return entity
    
    def _prepare_dict(self, value):
        try:
            value['ID'] = value.get('_id')
        except:
            pass
        if not self.keys:
            value = dict([(str(k), v) for k, v in value.iteritems() if k != '_id'])
            return value
        else:
            result_item = {}
            for key in self.keys:
                result_item[str(key)] = value.get(key, None)
            return value
    
    def delete(self, id=None, check_acl=True):
        """
            Remove an item by its id
        """
        from bson.objectid import ObjectId
        if id is None:
            return
        try:
            # Authorization
            if self.entity is not None and self.entity.acl is not None:
                self.load(id, required_permission='delete', check_acl=check_acl)
            # Remove the item
            if isinstance(id, basestring):
                self.collection.remove({'_id': ObjectId(id)})
            elif isinstance(id, ObjectId):
                self.collection.remove({'_id': id})
            else:
                raise Exception("Invalid id type")
        except Exception, ex:
            logger.error("Could not delete '%s': %s" % (id, str(ex)))
            raise Exception("Could not delete '%s': %s" % (id, str(ex)))
      
    def _store(self, data, id=None, current_identity=None, check_acl=True):
        """
            Create/update an item with data (or a list of items)
        """
        self.changed = True
        if id is None and hasattr(data, "__iter__") and not hasattr(data, "keys"): # list
            result = True
            for item in data:
                result = self._store_item(item, None, current_identity, check_acl) and result
            return result
        else: # single item
            return self._store_item(data, id, current_identity, check_acl)
    
    def _store_item(self, data, id, current_identity=None, check_acl=True):
        """
            Create/update a single item
        """
        from bson.objectid import ObjectId
        if id is None:
            try:
                id = data.get("ID")
            except:
                pass
        if id:
            # return one entry
            if isinstance(id, basestring):
                id = ObjectId(id)
            elif not isinstance(id, ObjectId):
                raise Exception("Invalid ID type - must be ObjectId")
            item = self.collection.find_one({'_id': id})
            if item:
                required_permission = 'edit'
                item['ID'] = item['_id']
            else:
                required_permission = 'create'
        else:
            required_permission = 'create'
            item = {}
        
        if self.entity is not None and self.entity.acl is not None and check_acl:
            # Check permission
            obj = self._prepare_entity(item)
        
            if required_permission == 'create':
                has_access = True
                is_owner = False
            else:
                has_access = obj.acl_has_access(current_identity)
                is_owner = obj.acl_is_owner(current_identity)

            self.entity.acl.check_permission(permission=required_permission,
                                             hasAccess=has_access,
                                             isOwner=is_owner)

        for key, value in data.iteritems():
            if key not in ['ID', '_id'] and (not self.keys or key in self.keys):
                item[key] = value

        if id: # update an existing item
            self.collection.update({'_id': id}, item)
        else: # insert a new item 
            data['ID'] = self.collection.insert(item)

        return True

    def select(self, disable_filter_query=False, current_identity=None, required_permission='view', check_acl=True, **args):
        """
            Select the records in the base that verify a predicate and return
            the specified names. If names is [] or None then all the fields are 
            returned

            The predicate can be expressed :
            - by a request string and keyword arguments for the values
            - by field_name = value keywords to test equality of fields to values

            Examples :
            db.select() # return all the records
            db.select(name='user1', type='user') # return the records with name = 'user1' and type = 'user'
        """
        # Authorization
        if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_find_condition'):
            find_condition = { '$and': [
                self.entity.acl_find_condition(required_permission, current_identity=current_identity),
                args
            ]}
        else:
            find_condition = args

        values = list(self.collection.find(find_condition))
        for value in values:
            value['ID'] = value['_id']

        # Authorization (old style)
        if check_acl and not disable_filter_query and self.entity is not None and hasattr(self.entity, 'acl_filter_values'):
            warnings.warn("use acl_find_condition instead of acl_filter_values with mongostorage", DeprecationWarning, 2)
            values = self.entity.acl_filter_values(values, required_permission, current_identity=current_identity)

        if self.entity is not None: # Return a list of entities
            return [self._prepare_entity(value) for value in values]
        else: # Return a list of dictionaries
            return [self._prepare_dict(value) for value in values]

