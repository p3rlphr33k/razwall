#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import errno
from endian.core import logger
from endian.emi.storage.cachedstorage import CachedStorage, CacheEntry
from endian.data.container.csvconfig import CsvConfigFile

__all__ = [
    "CSVStorage",
]

DEFAULT_MULTIVALUE_SEPARATOR = '&'

class CSVCacheEntry(CacheEntry):
    modelfile = None
    multivalue_separator = DEFAULT_MULTIVALUE_SEPARATOR
    
    def __init__(self, namespace, **args):
        self.modelfile = '/usr/lib/efw/%s' % namespace.replace('.','/')
        super(CSVCacheEntry, self).__init__(namespace=namespace, **args)
    
    def fieldToPython(self, ftype, value):
        """
        Parse the field value and transform into python value.
        """
        try:
            if ftype in ["Multiline"]:
                return value.replace(self.multivalue_separator, "\n")
            elif ftype == "Multichoice":
                if value:
                    return value.split(self.multivalue_separator)
                else:
                    return []
            elif ftype == "Int":
                if value == None:
                    return None
                value = int(value)
            elif ftype == "Bool":
                return value == "on"
        except Exception, e:
            logger.error("mapFieldLoad: could not convert %s->%s [%s]" % (ftype, value, str(e)))
        return value

    def fieldToText(self, ftype, value):
        """
        Parse the field value and transform into string value.        
        """
        if ftype in ["Multiline", "Multichoice"]:
            if type(value) == list:
                value = map(lambda i: str(i), value)
                return self.multivalue_separator.join(value)
            else:
                return value.replace("\n", self.multivalue_separator)
        elif ftype == "Bool":
            if value or value == "on":
                value = "on"
            else:
                value = "off"
        return value        

    def dictToPython(self, data):
        data = data.copy()
        for key in self.fields:
            ftype = self.schema.fields[key].__class__.__name__
            data[key] = self.fieldToPython(ftype, data.get(key, ""))
        return data

    def dictToText(self, data):
        data = data.copy()
        for key in self.fields:
            ftype = self.schema.fields[key].__class__.__name__
            data[key] = self.fieldToText(ftype, data.get(key, ""))
        return data
    
    def get_values(self):
        """
            Read the file and load the csv content
        """

        try:
            csv = CsvConfigFile(self.modelfile+'.config', self.path)
            try:
                self.multivalue_separator = csv._config.get('config', 'multivalue_separator')
            except:
                pass

            # Update the modification time before parsing the csv file
            # to be sure it did not change during reading
            self._update_modification_time()
            
            values = {}
            for id_, item in enumerate(csv):
                id_ += 1
                item = dict(item)
                item = self.dictToPython(item)
                item["ID"] = id_
                values[id_] = item
            if self.verbose:
                logger.info("csv storage '%s' loaded (%d items)", self.namespace, len(values))
        except Exception, ex:
            ex_errno = getattr(ex, 'errno', None)
            if ex_errno == errno.ENOENT:
                logger.info("CSV file '%s' not found, there is nothing to be loaded" % self.path)
            else:
                logger.error("Could not load CSV file '%s': %s" % (self.path, str(ex)), exc_info=True)
            values = {}
        return values

    def _delete(self, id):
        """
            Save the values dictionary to a csv file
            This will delete the id from the csv file
        """
        return self._save()

    def _save(self):
        """
            Save the values dictionary to a csv file
        """
        try:
            csv = CsvConfigFile(self.modelfile+'.config', self.path)
            items = []
            ids = self.values.keys()
            ids.sort()
            for id_ in ids:
                value = self.values.get(id_)
                items.append(self.dictToText(value))
            csv.data = items
            csv.write()
            return True
        except Exception, ex:
            logger.error("Error saving csv file '%s': %s" % (self.path, str(ex)), exc_info=True)
            raise Exception("Error saving csv file '%s': %s" % (self.path, str(ex)))
        return False

class CSVStorage(CachedStorage):
    """
    Load/store dictionaries from/to csv files.

    Each dictionary needs to have an ID key, that is used for its identification.
    """

    cache_entry_class = CSVCacheEntry

    def _get_path(self, namespace):
        return '/var/efw/%s' % namespace.replace('.','/')
