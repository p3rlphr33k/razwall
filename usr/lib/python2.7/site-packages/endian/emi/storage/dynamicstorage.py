#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.emi.storage import Storage
from endian.core import logger


__all__ = [ 'DynamicStorage' ]

class DynamicStorage(Storage):
    """
    Loads dictionaries from the DataSource.
    
    Each dictionary needs to have an ID key, that is used for its identification.
    """
    
    def __init__(self, entity):
        self.changed = False
        self.entity = entity
        self.schema = entity.schemaClass()
        super(DynamicStorage, self).__init__(self.schema)
    
    def _load(self,
            id=None,
            raw=True,
            order_by=None,
            order_sort="asc",
            disable_filter_query=False,
            load_optional_args=None,
            **args):
        """
        Load a list of objects or a single object based on the id

        :param id:                      object id, if None returns a list of objects
        :type id:                       int, str, etc.
        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :type disable_filter_query:     bool
        :param load_optional_args:      optional arguments passed to load function (used if values is callable)
        :type load_optional_args:       dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        value = None
        if hasattr(self.entity.values, '__call__'):
            if load_optional_args:
                values = self.entity.values(**load_optional_args)
            else:
                values = self.entity.values()

            for i, element in enumerate(values):
                element['ID']=element['id']=element.get('ID', element.get('id', i))
                element['displayOrder'] = 'id'
                if id is not None and element['ID'] == id:
                    value = element
                    break
        else:
            values = self.entity.values
            if id is not None:
                for item in values:
                    if item.get('ID', item.get('id')) == id:
                        value = item
                        break
        
        if id is not None:
            if value is None:
                return None
            elif raw: # entity instances
                self.entity(**dict(value))
            else: # dictionary instances
                return value
        
        if order_by: # sort by row value and create a list of tuples
            logger.debug("Dynamic storage order values by: %s" % order_by)
            values = sorted(values, key=lambda (value): value.get(order_by), reverse=(order_sort == "desc" and True or False))
        
        if raw: # entity instances
            return [self.entity(**dict(value)) for value in values]
        else: # dictionary instances
            return values
        return None
    
    def _filter(self,
            raw=True,
            filters={},
            search_keys=[],
            filter_optional_args=None,
            **args):
        """
        Return a list of objects according to the filter conditions

        :param raw:                     if True, returns dict, otherwise returns Entity instances
        :type raw:                      bool
        :param filters:                 filters conditions
        :type filters:                  dict
        :param search_keys:             list of keys to be used for searching 
        :type search_keys:              list
        :param filter_optional_args:    optional arguments passed to filter function
        :type filter_optional_args:     dict
        :return:                        a single object, None, or a list of objects
        :rtype:                         object or list
        """
        values = []
        for value in self._load(id=None, raw=False, load_optional_args=filter_optional_args, **args):
            if self._apply_filters(value=value, filters=filters):
                values.append(value)
        
        if raw: # entity instances
            return [self.entity(**dict(value)) for value in values]
        return values
    
