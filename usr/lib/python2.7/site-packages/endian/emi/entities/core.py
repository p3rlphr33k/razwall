#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import endian.core.i18n
from endian.core.lazylist import LazyList

from endian import datatypes
from endian.emi.entities.entity import Entity
from endian.emi.entities.fields import Field
from endian.core.niclist import getUplinks
from uplinksdaemon.uplinks import UplinksPool, ACTIVE
from endian.emi.entities.setup_entities import setup_entities
from endian.emi.entities.types import using_options, Unicode

__all__ = [
    'NetworkProtocol',
    'NetworkZone',
    'UplinkInterface',
    'UplinkIPAddress',
    'Country',
    'CPUCoreCount',
]

class NetworkProtocol(Entity):
    using_options(type='const')
    
    id = Field(Unicode, primary_key=True, nullable=False)
    name = Field(Unicode, nullable=False)
    
    values = [
        {'ID': 'any', 'name': "<%s>" % _("ANY")},
        {'ID': 'udp', 'name': "UDP"},
        {'ID': 'tcp', 'name': "TCP"},
        {'ID': 'tcp&udp', 'name': "TCP + UDP"},
        {'ID': 'esp', 'name': "ESP"},
        {'ID': 'gre', 'name': "GRE"},
        {'ID': 'icmp', 'name': "ICMP"}
    ]
    
    @classmethod
    def all(cls):
        return cls.storage().load()
    
    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

def get_zones():
    from endian.core.zones import getZones
    zones = [{'ID': zone.upper(), 'name': _(zone.upper())} for zone in getZones().keys()]
    return sorted(zones, key=lambda zone: zone['name']) 

class NetworkZone(Entity):
    using_options(type='dynamic')
    
    id = Field(Unicode, primary_key=True, nullable=False)
    name = Field(Unicode, nullable=False)
    
    values = LazyList(get_zones)
    
    @classmethod
    def all(cls):
        return cls.storage().load()
    
    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

def get_uplink_interfaces():
    interfaces = getUplinks().values()
    interfaces.sort(cmp=lambda x,y: cmp(x.sortorder, y.sortorder))
    return [{'ID': x.get("logical"), 'name': x.get("description", x.get("logical"))} for x in interfaces]

class UplinkInterface(Entity):
    using_options(type='dynamic')
    
    ID = Field(Unicode, primary_key=True, nullable=False)
    name = Field(Unicode, nullable=False)
    
    values = LazyList(get_uplink_interfaces)
    
    @classmethod
    def all(cls):
        return cls.storage().load()
    
    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)


def uplink_ips(uplink='UPLINK:ANY'):
    """Return a list of IPs associated to an uplink.

    :param uplink: uplink name
    :param type: :py:class:`str`

    :return: list of IPs.
    :rtype: :py:class:`list`
    """
    if not uplink.startswith('UPLINK:'):
        # An uplink can also be represented in the IP:UPLINK:uplink_name notation,
        # as used by the firewall GUI.
        try:
            return [datatypes.network.IPAddress(uplink.split(':')[0]).address]
        except:
            return []
    uplink = uplink.split(':')[1]
    uplinks = []
    if uplink == '':
        return []
    if uplink == 'ANY':
        uplinks = UplinksPool().getActiveUplinks()
    else:
        try:
            uplinks = [UplinksPool().get(uplink)]
        except Exception:
            return []
    ip_list = []
    for ul in uplinks:
        if ul.getSettings()['RED_TYPE'] == 'NONE':
            continue
        if ul.getStatus() != ACTIVE:
            continue
        data = ul.getData()
        ips = data.get('IPS')
        if not ips:
            ip = data.get('IP_ADDRESS')
            if not ip:
                continue
            ip_list.append(ip)
            continue
        for ip in ips.split():
            try:
                ip_list.append(datatypes.network.CIDR(ip).address)
            except Exception:
                pass
    return ip_list


def get_uplinks_ips():
    """Return a list of interfaces and associated IPs suitable for an EMI widget.

    :return: list of dictionaries with '[ip:]uplink:name' as ID key and a description as name key.
    :rtype: :py:class:`list`
    """
    interfaces = getUplinks().values()
    interfaces.sort(cmp=lambda x,y: cmp(x.sortorder, y.sortorder))
    uplinks = []
    for interface in interfaces:
        id_ = interface.get("logical")
        name = interface.get("description") or interface.get("logical")
        ips = uplink_ips(id_)
        uplinks.append({'ID': id_, 'name': '%s (%s)' % (name, _('All known'))})
        for ip in ips:
            sub_id_ = '%s:%s' % (ip, id_)
            sub_name = '%s (IP: %s)' % (name, ip)
            uplinks.append({'ID': sub_id_, 'name': sub_name})
    return uplinks


class UplinkIPAddress(Entity):
    using_options(type='dynamic')
    
    ID = Field(Unicode, primary_key=True, nullable=False)
    name = Field(Unicode, nullable=False)
    
    values = LazyList(get_uplinks_ips)
    
    @classmethod
    def all(cls):
        return cls.storage().load()
    
    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)


def get_countries():
    from endian.core.countries import COUNTRIES
    return [{'ID': key, 'name': value} for key, value in COUNTRIES.iteritems()]

class Country(Entity):
    using_options(type='const')
    
    id = Field(Unicode, primary_key=True, nullable=False)
    values = get_countries()
    
    @classmethod
    def all(cls):
        return cls.storage().load()
    
    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

def get_number_of_cores():
    from endian.core.cpu import number_of_cores
    values = []
    for i in range(1, number_of_cores()+1):
        # if i == 1:
        #     name = _("1 core")
        # else:
        #     name = _("%s cores") % i
        values.append({'ID': i, 'name': i})
    return values

class CPUCoreCount(Entity):
    using_options(type='const')
    
    id = Field(Unicode, primary_key=True, nullable=False)
    values = get_number_of_cores()
    
    @classmethod
    def all(cls):
        return cls.storage().load()
    
    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)

# register core entities
setup_entities(prefix="core",
    entities=[
        NetworkProtocol,
        NetworkZone,
        UplinkInterface,
        UplinkIPAddress,
        Country,
        CPUCoreCount
    ])
