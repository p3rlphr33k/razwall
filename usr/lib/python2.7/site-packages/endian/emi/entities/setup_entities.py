#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.datatypes.ordered_dict import OrderedDict
from endian.emi.entities.types import ElixirField, ElixirOneToMany, ElixirManyToOne, ElixirManyToMany, Property, elixir_setup_entities, session, metadata, elixir_entities, elixir_create_all
from endian.emi.entities.entity import Entity, DEFAULT_ENTITY_TYPE, ENTITY_TYPES
from endian.emi.entities.entities_register import register_entity, lookup_entity_register, register_prefix

def setup_entities(entities=None, prefix=None, bind=None):
    """
    ... autofunction::: setup_entities
        Setup the table and mapper of all entities in the default entity collection.
        The optional prefix is used to avoid the names clash
        
        :param entities: the classes to be registered
        :type entities: list of sub-classes of Entity
        :param prefix: an option prefix added before the names of the classes - (e.g. entity = Antivirus, prefix = av, registered name = av:Antivirus)
        :type prefix: string
        :param bind: database bind, (e.g. "sqlite:///xyz.sqlite") - required for database-persistent classees
        :type bind: string
    """
    if bind:
        metadata.bind = bind

    if entities:
        __setup_entities(entities, prefix)
        for entity in entities:
            elixir_entities.remove(entity)
    else:
        __setup_entities(elixir_entities, prefix)


def __setup_entities(entities, prefix=None):
    """
    ... autofunction::: __setup_entities
        Setup all entities in the list passed as argument
    """

    entityBaseFields = ['table', 'mapper'] + dir(Entity) 
    manyToMany = list()
    register_prefix(prefix)
    
    # Setup entities
    for entity in entities:
        __entity_setup(entity, entityBaseFields, manyToMany, prefix)
                
    # Remove the not db-persitance entities
    for entity in list(entities):
        if entity._descriptor.type and entity._descriptor.type != 'db':
            # delete all Elixir properties so that it doesn't interfer
            for name, attr in entity.__dict__.items():
                if isinstance(attr, ElixirField):
                    # Set the default value
                    if 'default' in attr.info:
                        setattr(entity, name, attr.info['default'])
                    else:
                        setattr(entity, name, None)
                elif isinstance(attr, Property):
                    setattr(entity, name, None)
            
            # remove the entity from entities, so elixir does not process the entity
            entities.remove(entity)
            
    # Entities setup
    elixir_setup_entities(entities)

    # ManyToMany setup
    for entity in entities:
        for field_name, field in entity.get_db_fields_map().iteritems():
            if field in manyToMany:
                # Add a property to the entity for getting and setting id
                __many_to_many_setup(entity, field_name, field)

 
def __entity_setup(entity, entityBaseFields, manyToMany, prefix):
    # Keep the fields order
    entity._db_fields = OrderedDict()  

    # Set the entity type
    entity._type = entity._descriptor.type or DEFAULT_ENTITY_TYPE
    if not entity._type in ENTITY_TYPES:
        raise ValueError("Invalid entity type '%s'. Valid types are: %s" % (entity._type, ",".join(ENTITY_TYPES)))
    if entity._descriptor.namespace:
        entity._namespace = entity._descriptor.namespace
    elif entity._type in ('csv', 'settings'):
        raise ValueError("Options 'namespace' must be not null for 'csv' and 'settings' types")
    if hasattr(entity._descriptor, 'cache_type'):
        entity._cache_type = entity._descriptor.cache_type
    else:
        entity._cache_type = None
    if hasattr(entity._descriptor, 'register_datasource'):
        entity._register_datasource = entity._descriptor.register_datasource
    else:
        entity._register_datasource = True
    if hasattr(entity._descriptor, 'storage_args'):
        entity._storage_args = entity._descriptor.register_datasource
    else:
        entity._storage_args = {}
        
    # Label
    if hasattr(entity._descriptor, 'label_field'):
        entity.label_field = entity._descriptor.label_field

    if entity._descriptor.type == None:
        entity._descriptor.type = 'db'
        
    elif entity._descriptor.type == 'const':
        # Setup the individuals
        if not getattr(entity, 'values', None):
            entity.values = []
        else:
            # The value of 'ID' and 'id' is set to:
            # ID (if exists) or id (if exists) or position (else)
            if hasattr(entity.values, '__call__'):
                values = entity.values()
            else:
                values = entity.values
            for i, element in enumerate(values):
                element['ID']=element['id']=element.get('ID', element.get('id', i))
                element['displayOrder'] = 'id'

    if hasattr(entity._descriptor, 'verbose'):
        entity._verbose = entity._descriptor.verbose
    else:
        entity._verbose = False

    # Properties setup
    entity._keys = list()
    for field_name in filter(lambda x: not x.startswith("_") and not x in entityBaseFields, dir(entity)):
        value = getattr(entity, field_name)
        
        if isinstance(value, ElixirField) or \
                isinstance(value, ElixirManyToOne) or \
                isinstance(value, ElixirManyToMany) or \
                isinstance(value, ElixirOneToMany):
            entity._db_fields[field_name] = value
            if field_name == 'id' and entity._descriptor.type != 'db':
                entity._keys.append('ID')
            else:
                entity._keys.append(field_name)
            if isinstance(value, ElixirManyToMany):
                manyToMany.append(value)

    # Register the entity    
    register_entity(entity, prefix)


def __many_to_many_setup(entity, field_name, field):
    field_name = field_name + "_id"
    get = lambda instance: __many_to_many_getter(instance, field_name)
    set = lambda instance, value: __many_to_many_setter(instance, field_name, field, value)
    setattr(entity, field_name, property(get, set))


def __many_to_many_getter(entity_instance, field_name):
    """
    ... autofunction::: __many_to_many_getter
        Getter functions for the many-to-may properties.
        Used for retriving the id of a many-to-many relations.
        e.g.
        print user.roles
        root, shop-account, ...
        print user.roles_id
        1, 2, ...
        :return: list of id
        :rtype: list 
    """
    field_name = field_name[0:-3] # Remove the ending '_id'    
    return [x.id for x in getattr(entity_instance, field_name)] # Retuns a list of id


def __many_to_many_setter(entity_instance, field_name, field, values):
    """
    ... autofunction::: __many_to_many_setter
        Setter functions for the many-to-may properties.
        Used for setting the id of a many-to-many relations.
        e.g.
        user.roles_id = [1, 2, ...]
        print user.roles
        root, shop-account, ...
    """
    
    if values == None:
        setattr(entity_instance, field_name[0:-3], None) # set to None the value of the attribute
        return
    if not isinstance(values, list):
        values = [values]
        
    # Determinate the target entity
    target = field.info["target"]
    entity = lookup_entity_register(target)
    
    # Converts the id int objs
    converted_items = []
    for value in values:
        try:
            converted_items.append(session.query(entity).filter_by(id=value).first())
        except:
            pass
    setattr(entity_instance, field_name[0:-3], converted_items)

        
def create_tables(tables=None):
    """
    ... autofunction::: create_tables
    
    Create all tables (or a subset).
    The method will not attempt to recreate tables already present in the target database.
    """
    elixir_create_all(tables=tables)


__all__ = ['setup_entities', 'create_tables']
