#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import warnings

from endian.emi.entities.datatypes import lookup_datatype_by_db_column
from endian.emi.entities.types import ElixirField

__all__ = [
    'parse_field_options',
    'Field'
]

OPTIONS = [
    'suppress_label',
    'expands',  # expand to full width?
    'separator',  # show separator line
    'selected',
    'disabled',
    'read_only',  # make field read only
    'readonly_if_not_empty',
    'read_only_post',
    'read_only_markupsafe',
    'format_function',
    'private',  # Private field are not added to the schema
    'widget',  # read custom widget
    'widget_validator',  # deprecated?
    'validator',  # read custom validator
    'help_text',  # help text
    'hover_help',  # show help as hover field?

    'proxy_fields',  # ???

    # toggle options START
    'toggle_name',
    'toggle_option',
    'toggle_function',
    # toggle options END

    # customize how the target entity is read START
    'target',
    'target_key',
    'target_label',
    'target_key_prefix',
    'target_label_prefix',
    'target_key_prefix_key',
    'target_label_prefix_match',
    'target_filter_key',
    'target_filter_value',
    # customize how the target entity is read END

    'text_area',  # use a textarea
    'label_field',  # which entitiy field should be used for select
                    # option label
    'add_empty_option',  # add empty option to select box
    'empty_option_label',

    # customize autocomplete
    'autocomplete',
    'autocomplete_max_results',
    'autocomplete_min_length',
    'autocomplete_tree',

    # customize singleselect, multiselect, multicheck widgets START
    'singleselect_type',
    'multi_type',

    'multiselect_title',
    'multiselect_searchable',
    'multiselect_sortable',
    'multiselect_draggable',
    'multiselect_double_clickable',
    'multiselect_animated',
    'multiselect_show_effect',
    'multiselect_hide_effect',
    'multiselect_divider_location',
    'multiselect_url',
    'multiselect_data',
    'multiselect_data_fields',
    'multiselect_connect_with',

    'multicheck_hide_label',
    'mulitcheck_collapse_class',
    'multicheck_expand_class',
    'multicheck_not_selected',
    'multicheck_selected',
    'multicheck_partial',
    'multicheck_not_selected_link',
    'multicheck_selected_link',
    'multicheck_partial_link',
    'multicheck_group_target',
    'multicheck_group_target_name',
    'multicheck_group_target_list',
    'multicheck_text',
    # customize multiselect, multicheck widgets END

    # customize slider START
    'slider',
    'slider_min_title',
    'slider_max_title',
    'slider_min_image',
    'slider_max_image',
    'slider_min',
    'slider_max',
    'slider_step_size',
    # customize slider END
]


def parse_field_options(include_required=False, **kwargs):
    """
        :param label_text: label text used by the field label
        :type label_text: string
        :param suppress_label: do not show field label text
        :type suppress_label: bool
        :param expands: expand field to use the whole row (expand
            over all columns)
        :type expands: boolean
        :param hidden: do not show field (uses a hidden input field)
        :type hidden: bool
        :param separator: show a separator line after the field
        :type separator: bool
        :param default: default value of the field
        :type default: string or bool
        :param length: allowed length of the field
        :type length: int
        :param selected: ???
        :type selected: ???
        :param nullable: may the value of the field be empty (overrides
            required)
        :type nullable: bool
        :param required: is this field required
        :type required: bool
        :param disabled: is this field disabled (value can not be changed)
        :type disabled: bool
        :param read_only: is this field read only
        :type read_only: bool
        :param readonly_if_not_empty: this field will get read only
            after first save
        :type readonly_if_not_empty: bool
        :param read_only_post: add hidden input so the value is posted
        :type read_only_post: bool
        :param read_only_markup: is the content markup safe
        :type read_only_markup: bool
        :param format_function: function to format content (gets value as
            attribute and returns the formated value)
        :type format_function: function
        :param private: is this field part of the entity
        :type private: bool
        :param widget: custom widget (replaces the default widget, which is
            choosen by field type)
        :type widget: endian.emi.widgets.*
        :param validator: custom validator (replaces the default validator,
            which is choosen by field type)
        :type validator: endian.validators.*
        :param help_text: help text of the field
        :type help_text: string
        :param hover_help: show help text on hover or always
        :type hover_help: bool
        :param proxy_fields: ???
        :type proxy_fields: ???
        :param toggle_name: name of the entity field which is responsible for
            toggling this field
        :type toggle_name: string
        :param toggle_option: when to toggle the field (e.g. "on", "off" with
            checkboxes or the option name(s) of a selectbox)
        :type toggle_option: string or list of strings
        :param toggle_function: js functio used as toggle callback. defaults to
            fieldTogglerChange or fieldTogglerClick
        :type toggle_function: string

        :param target: defines which entity to use for the options of a
            selectbox (e.g. "foo:Baa"), it also supports usage of multiple
            entities (e.g. ["foo:Baa", "baa:Foo"]).
        :type target: string or list of strings
        :param target_key: defines which field values to use as option names
            for the select widget. if it is a list it will mapped to the list
            of targets by index.
        :type target_key: string or list of strings
        :param target_label: defines which field to use as option labels for
            the select widget. if it is a list it will mapped to the list of
            targets by index.
        :type target_label: string or list of strings

        the following target_* params are used to have multiple target values
            in a single select box or filter the values of a target

        :param target_key_prefix: add this as prefix to the option names of
            the select widget. if it is a list it will mapped to the list
            of targets by index.
        :type target_key_prefix: string or list of strings
        :param target_label_prefix: add this as prefix to the option labels
            of the select widget. if it is a list it will mapped to the list
            of targets by index.
        :type target_label_prefix: string or list of strings
        :param target_key_prefix_key: add this field value as prefix to the
            option names of the select widget.
            if target_key_prefix is set <field value of target_key_prefix_key
            <target_key_prefix> will be used as prefix.
            if it is a list it will mapped to the list of targets by index.
        :type target_key_prefix_key: string or list of strings
        :param target_label_prefix_match: add this field value as prefix to the
            option labels of the select widget. if target_label_prefix_match
            is set <field value of target_label_prefix_match>
            <target_label_prefix> will be used as prefix.
        :type target_label_prefix_match: string
        :param target_filter_key: filter this field value by comparing with
            target_filter_value. Use ',' to map filter key(s) to a target
            (if only one is present use it for all targets).
        :type target_filter_key: string
        :param target_filter_value: use target_filter_value to filter the value
            of target_filter_key field values (user * to filter by all keys)
            use ',' to map filter value(s) to a target (if only one is present
            use it for all targets).
            use '|' to map filter values to the same target and key with OR.
            target_filter_key and target_filter_value are split by | to allow
            to check for multiple values on the same key
            e.g. name <-> foo|baa -> if name == foo OR name == baa
        :type target_filter_value: string or list of strings
        :param text_area: use a textarea as widget
        :type text_area: bool
        :param autocomplete: use autocomplete widget
        :type autocomplete: bool
        :param autocomplete_max_results: show max x results
        :type autocomplete_max_results: int
        :param autocomplete_min_length: min lenght for searching
        :type autocomplete_min_length: int
        :param autocomplete_tree:
        :type autocomplete_tree: bool
        :param add_empty_option: adds an empty option to a selectbox widget
        :type add_empty_option: bool
        :param empty_option_label: empty option label
        :type empty_option_label: string
        :param singleselect_type: type of the singleselect widget
            (traditional|chosen) defaults to traditional
        :type singleselect_type: string
        :param multi_type: type of the multiselect widget
            (multiselect|traditional|small|check|chosen)
        :type multi_type: string
        :param multiselect_title: use custom title for
            multiselect -> label_text will be used for count text
        :type multiselect_title: string
        :param multiselect_searchable: make multiselect searchable
        :type multiselect_searchable: bool
        :param multiselect_sortable: make selected options of multiselect
            sortable
        :type multiselect_sortable: bool
        :param multiselect_draggable: make options draggable from available to
            selected and vice versa
        :type multiselect_draggable: bool
        :param multiselect_double_clickable: move items also with double click
        :type multiselect_double_clickable: bool
        :param multiselect_animated: animate selection/deselction
        :type multiselect_animated: bool
        :param multiselect_show_effect: define jquery show effect
        :type multiselect_show_effect: string
        :param multiselect_hide_effect: define jquery hide effect
        :type multiselect_hide_effect: string
        :param multiselect_divider_location: how to devide selected and
            unselected side
        :type multiselect_divider_location: string
        :param multicheck_hide_label: show label for multicheck widget
        :type multicheck_hide_label: bool
        :param mulitcheck_collapse_class: css class name for collapse
        :type mulitcheck_collapse_class: string
        :param multicheck_expand_class: css class name for expand
        :type multicheck_expand_class: string
        :param multicheck_not_selected: use available img for not selected
            status
        :type multicheck_not_selected: string
        :param multicheck_selected: use available image for selected status
        :type multicheck_selected: string
        :param multicheck_partial: use available image for partial selected
            status
        :type multicheck_partial: string
        :param multicheck_not_selected_link: link to img for not selected
            status
        :type multicheck_not_selected_link: string
        :param multicheck_selected_link: link to img for selected status
        :type multicheck_selected_link: string
        :param multicheck_partial_link: link to img for partial selected status
        :type multicheck_partial_link: string
        :param multicheck_group_target: defines which entity to use for group
            categories
        :type multicheck_group_target: string
        :param multicheck_group_target_name: which entity field to use for name
        :type multicheck_group_target_name: string
        :param multicheck_group_target_list: which entity field to use for the
            item list (holding items from the target entity)
        :type multicheck_group_target_list: string
        :param multicheck_text: dictionary containing custom gettext strings
        :type multicheck_text: dict
        :param slider: use slider widget
        :type slider: bool
        :param slider_min_title: title for the minimum position
        :type slider_min_title: string
        :param slider_max_title: title for the maximum position
        :type slider_max_title: string
        :param slider_min_image: img to use for minimum position
        :type slider_min_image: string
        :param slider_max_image: img to use for maximum position
        :type slider_max_image: string
        :param slider_min: value for the minimum position
        :type slider_min: string
        :param slider_max: value for the maximum position
        :type slider_max: string
        :param slider_step_size: step size to use for the slider
        :type slider_step_size: string
    """

    info = {}

    def arg(name, remove=True):
        # Copy the argument in the 'info' dict and, if 'remove' is true,
        # delete the argument
        if name in kwargs:
            info[name] = kwargs[name]
            if remove:
                del kwargs[name]

    arg('hidden')  # is field hidden?

    # customize how the target entity is read
    if 'options' in kwargs:
        warnings.warn(
            "options has been deprecated: use target instead.",
            DeprecationWarning, 2)
        info['target'] = kwargs['options']
        del kwargs['options']
    if 'options_key' in kwargs:
        warnings.warn(
            "options_key has been deprecated: use target_key instead.",
            DeprecationWarning, 2)
        info['target_key'] = kwargs['options_key']
        del kwargs['options_key']

    # Copy the options from kwargs to info
    arg('default', remove=False)
    arg('length', remove=False)  # length parameter
    for key in OPTIONS:
        arg(key)

    if not info.get('type') and info.get('target'):
        info['type'] = info['target']

    # set if field is nullable or required START
    if include_required:
        if 'nullable' in kwargs:
            info['nullable'] = kwargs['nullable']
            kwargs['required'] = info['required'] = not kwargs['nullable']
            del kwargs['nullable']
        elif 'required' in kwargs:
            info['required'] = kwargs['required']
            info['nullable'] = not kwargs['required']
        else:
            info['nullable'] = True
            info['required'] = kwargs['required'] = False
    # set if field is nullable or required END

    # get label text from kwargs START
    if 'label_text' in kwargs:
        label_text = kwargs['label_text']
        try:
            info['label'] = label_text.decode('utf-8')
        except:
            info['label'] = u"%s" % label_text
        del kwargs['label_text']
    # get label text from kwargs END

    # hover help per default
    if 'hover_help' not in kwargs:
        info['hover_help'] = True

    return kwargs, info


class Field(ElixirField):
    """
        Represents the definition of a 'field' on an entity.
        This class represents a column on the table where the entity is stored.
    """

    def __init__(self, type, *args, **kwargs):
        """
            look at the parse_field_options documentation for additional params

            :param type: type used by the field
            :type type: endian.emi.entities.types.*
        """
        kwargs, info = parse_field_options(include_required=True, **kwargs)
        self._validator = None

        def arg(name, remove=True):
            # Copy the argument in the 'info' dict and, if 'remove' is true,
            # delete the argument
            if name in kwargs:
                info[name] = kwargs[name]
                if remove:
                    del kwargs[name]

        # override type to be sure its the field type
        info['type'] = type

        # options used by the switch widget
        arg('switch_storage')
        if 'storage' in kwargs:
            warnings.warn(
                "storage has been deprecated: use switch_storage instead.",
                DeprecationWarning, 2)
            arg('storage')
            info['switch_storage'] = info['storage']
        arg('switch_key')
        if 'key' in kwargs:
            warnings.warn(
                "key has been deprecated: use switch_key instead.",
                DeprecationWarning, 2)
            arg('key')
            info['switch_key'] = info['key']
        arg('switch_action')
        if 'action' in kwargs:
            warnings.warn(
                "action has been deprecated: use switch_action instead.",
                DeprecationWarning, 2)
            arg('action')
            info['switch_action'] = info['action']
        arg('switch_check')
        if 'check' in kwargs:
            warnings.warn(
                "storage has been deprecated: use switch_storage instead.",
                DeprecationWarning, 2)
            arg('check')
            info['switch_check'] = info['check']
        # COPY args to info END

        # Lookup the validator to be used for this field
        if not info.get('validator', None):
            info['validator'] = lookup_datatype_by_db_column(type).validator

        # is not a OneToMany, ManyToOne or ManyToMany relationship
        info['multi_value'] = False

        self.info = info

        ElixirField.__init__(self, type, *args, **kwargs)

__all__ = ['Field']
