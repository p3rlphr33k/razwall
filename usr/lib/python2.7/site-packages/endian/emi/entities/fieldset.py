#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import time
import warnings

from endian.core import logger
from endian.core.lazylist import LazyList, CachedList
from endian.validators.core import NotEmpty
from endian.datatypes.ordered_dict import OrderedDict
from endian.emi import widgets

from endian.emi.entities.schema import remove_id_from_field_name
from endian.emi.entities.entities_register import lookup_entity_register
from endian.emi.entities.datatypes import lookup_datatype_by_db_column

__all__ = [
    'create_fields_class',
    'create_field'
]

def widget_lookup(info):
    """Lookup the widget to be used for a field.

    :param info: entity arguments
    :type info: :py:class:`dict`

    :return: widget class
    :rtype: :py:class:`~tw.forms.MultipleSelectField`
    """
    if info.get("hidden", False) == True: # Render the property as an hidden field
        return widgets.HiddenField
    elif info.get("read_only", False) == True: # Render the property as an read_only field
        return widgets.ReadonlyField
    elif info.get("text_area", False): # Render the property as a text-area
        return widgets.HugeTextField
    elif info.get("autocomplete", False):
        return widgets.AutocompleteField
    elif info.get("slider", False): # Render the property as a slider
        return widgets.Slider
    elif not info.get("target", None): # Is a basic type, render as a TextField of CheckBox
        return lookup_datatype_by_db_column(info.get('type', None)).widget
    elif info.get("multi_value", False):
        multi_type = info.get("multi_type")
        if multi_type == "traditional":
            return widgets.TraditionalMultipleSelectField
        elif multi_type == "small":
            return widgets.SmallMultipleSelectField
        elif multi_type == "uplinks":
            return widgets.MultipleSelectUplinks
        elif multi_type == "check":
            return widgets.MultipleCheckField
        elif multi_type == "chosen":
            return widgets.ChosenMultipleSelectField
        else:
            return widgets.MultipleSelectField
    else:
        singleselect_type = info.get("singleselect_type")
        if singleselect_type == "chosen":
            return widgets.ChosenSingleSelectField
        else:
            return widgets.SingleSelectField

def multicheck_groups(field):
    """ Return the groups for grouping a MultipleCheckField """
    
    target = field.info.get("multicheck_group_target")
    result = list()
    
    try:
        # Entity lookup
        entity = lookup_entity_register(target)
        
        target_name = field.info.get("multicheck_group_target_name", "name")
        target_list = field.info.get("multicheck_group_target_list", "itemlist")
        
        # List the items
        try:
            data = entity.storage().load()
            for row in data:
                name = row[target_name]
                list_ = row[target_list]
                result.append((name, list_))
        
        except KeyError:
            warnings.warn("missing attribute %s or %s in entity %s" % (value_field, label_field, target))
    
    except KeyError:
        warnings.warn("options widget target class %s not found" % target)
    
    return result

def range_options(field=None, info=None, include_empty_option=False, empty_option_label=""):
    """
        Return the element to fill up the select options as lazy list
        
        :param field: entity field holding the info needed to get the options (if available field.info will replace info)
        :type field: endian.emi.entities.fields.*|endian.emi.entities.relationships.*
        :param info: dictionary holding the info needed to get the options (will be replaced by field.info if available)
        :type info: dict
        :param include_empty_option: add first option with empty value
        :type include_empty_option: bool
        :param empty_option_label: label for empty value option
        :type empty_option_label: string
    """
    return LazyList(get_range_options, field=field, info=info, include_empty_option=include_empty_option, empty_option_label=empty_option_label)

def get_range_options(field=None, info=None, include_empty_option=False, empty_option_label=""):
    """
        Return the element to fill up the select options
        
        :param field: entity field holding the info needed to get the options (if available field.info will replace info)
        :type field: endian.emi.entities.fields.*|endian.emi.entities.relationships.*
        :param info: dictionary holding the info needed to get the options (will be replaced by field.info if available)
        :type info: dict
        :param include_empty_option: add first option with empty value
        :type include_empty_option: bool
        :param empty_option_label: label for empty value option
        :type empty_option_label: string
    """
    if field and not info:
        info = field.info
    
    target = info.get("target", None)
    result = list()
    
    if not target:
        warnings.warn("options widget without target class")
    else:
        targets = target.split(",")
        target_keys = info.get("target_key", "").split(",")
        target_labels = info.get("target_label", "").split(",")
        target_key_prefixes = info.get("target_key_prefix", "").split(",")
        target_key_prefix_keys = info.get("target_key_prefix_key", "").split(",")
        target_label_prefixes = info.get("target_label_prefix", "").split(",")
        target_label_prefix_match = info.get("target_label_prefix_match", None)
        
        target_filter_keys = info.get("target_filter_key")
        if target_filter_keys:
            # split to get value for each target
            target_filter_keys = target_filter_keys.split(",")
        else:
            # default is to match to all values
            target_filter_keys = ["*"]
        
        target_filter_values = info.get("target_filter_value")
        if target_filter_values is not None:
            # split to get value for each target
            target_filter_values = target_filter_values.split(",")
        else:
            # default is to match to all values
            target_filter_values = ["*"]
        
        for i, target in enumerate(targets):
            if not target_keys:
                target_key = None
            elif len(target_keys) >= i+1:
                target_key = target_keys[i]
            else:
                target_key = target_keys[0]
            
            if not target_labels:
                target_label = entity.label_field
            elif len(target_labels) >= i+1:
                target_label = target_labels[i]
            else:
                target_label = target_labels[0]
            
            if not target_key_prefixes:
                target_key_prefix = ""
            elif len(target_key_prefixes) >= i+1:
                target_key_prefix = target_key_prefixes[i]
            else:
                target_key_prefix = target_key_prefixes[0]
            
            if not target_key_prefix_keys:
                target_key_prefix_key = None
            elif len(target_key_prefix_keys) >= i+1:
                target_key_prefix_key = target_key_prefix_keys[i]
            else:
                target_key_prefix_key = target_key_prefix_keys[0]
            
            if not target_label_prefixes:
                target_label_prefix = ""
            elif len(target_label_prefixes) >= i+1:
                target_label_prefix = target_label_prefixes[i]
            else:
                target_label_prefix = target_label_prefixes[0]
            
            if target_label_prefix_match:
                try:
                    target_label_prefix_match = eval(target_label_prefix_match)
                except:
                    target_label_prefix_match = None
            
            # this applies to target_filter_key, target_filter_value matching
            # target_filter_key and target_filter_value are split by | to allow to check for multiple values on multiple keys
            # e.g. name <-> foo|baa -> if name == foo OR name == baa
            
            # if available use the key mapped to the current target
            if len(target_filter_keys) >= i+1:
                target_filter_key = target_filter_keys[i].split("&")
            # default to the first key, if there is none left or only one is given
            else:
                target_filter_key = target_filter_keys[0].split("&")
            
            # if available use the value mapped to the current target
            if len(target_filter_values) >= i+1:
                target_filter_value = target_filter_values[i].split("&")
            # default to the first value, if there is none left or only one is given
            else:
                target_filter_value = target_filter_values[0].split("&")
            
            try:
                # Entity lookup
                entity = lookup_entity_register(target)
                
                # Value
                value_field = 'id'
                if target_key:
                    value_field = target_key 
                if value_field == 'id':
                    value_field = 'ID'
                
                # Label
                label_field = target_label
                if not label_field:
                    label_field = 'name'
                if label_field == 'id':
                    label_field = 'ID'
                
                # List the items
                try:
                    data = entity.storage().load()
                    
                    for row in data:
                        label_prefix = None
                        and_matched = True # if it stays true the field is added to the list
                        for j, filter_key in enumerate(target_filter_key):
                            # if available use the OR filter values for the current field
                            if len(target_filter_value) >= j+1:
                                filter_values = target_filter_value[j].split("|")
                            else: # use default filter (filter from first target)
                                filter_values = target_filter_value[0].split("|")
                            for filter_value in filter_values:
                                or_matched = False # if it gets true one field met the criteria
                                # convert boolean key words into boolean
                                if filter_value in ["on", "True"]: 
                                    filter_value = True
                                elif filter_value in ["off", "False"]:
                                    filter_value = False
                                if filter_value == "*":
                                    # strange case, because it would mean that every row is valid
                                    or_matched = True
                                elif filter_key == "*":
                                    # match all fields and combine results with OR
                                    for key, value in row.iteritems():
                                        # some fields have multiple values others not
                                        if not isinstance(value, list):
                                            value = [value]
                                        # match all values of a field with OR
                                        for v in value:
                                            if v == filter_value:
                                                # one field met the criteria
                                                or_matched = True # if one value match returns TRUE all are TRUE (OR)
                                                break # no need to go on with OR matching on values...
                                        if value == filter_value:
                                            # one field met the criteria
                                            or_matched = True
                                            break # no need to go on with OR matching...
                                else:
                                    value = row.get(filter_key)
                                    # some fields have multiple values others not
                                    if not isinstance(value, list):
                                        value = [value]
                                    # match all values of a field with OR
                                    for v in value:
                                        if v == filter_value:
                                            # one value met the criteria
                                            or_matched = True # if one value match returns TRUE all are TRUE (OR)
                                            break # no need to go on with OR matching on values...
                                if or_matched: # if one field is TRUE all are TRUE (OR)
                                    break # no need to go on with OR matching...
                            if not or_matched:
                                # if one returns FALSE all are FALSE (AND)
                                and_matched = False
                                break # no need to go on with AND matching...
                        
                        if not and_matched:
                            # row does not meet criteria
                            # do not add it to result
                            continue
                        
                        if target_key_prefix_key:
                            key_prefix_match = row.get(target_key_prefix_key, "")
                            key_prefix = "%s%s" % (key_prefix_match, target_key_prefix)
                        else:
                            key_prefix_match = None
                            key_prefix = target_key_prefix
                        if key_prefix_match and target_label_prefix_match:
                            label_prefix = "%s%s" % (target_label_prefix_match.get(key_prefix_match, ""), target_label_prefix)
                        else:
                            label_prefix = target_label_prefix
                        if not label_prefix:
                            label_prefix = key_prefix
                        key = "%s%s" % (key_prefix, row[value_field])
                        label = "%s%s" % (label_prefix, row[label_field])
                        result.append((key, label))
                except KeyError:
                    warnings.warn("missing attribute %s or %s in entity %s" % (value_field, label_field, target))
            except KeyError:
                warnings.warn("options widget target class %s not found" % target)
    
    # Sort the values
    # result.sort(lambda p1, p2: cmp(p1.displayOrder,p2.displayOrder))
    
    # Create the empty options as first option
    if info.get("add_empty_option", include_empty_option):
        # Add an empty option
        empty_option_label = info.get("empty_option_label", empty_option_label)
        if not empty_option_label:
            empty_option_label = ""
        result.insert(0, ('', empty_option_label))
    
    return result

def create_field(field_name, field, set_id=False, read_only=False, hidden=False):
    """ Create a single field (widget) """
    if field.info.get("private", False): # Private field are not added to the schema
        return {}
    
    # prepare the widget arguments
    widget_args = {}
    
    if set_id:
        widget_args['id'] = field_name
    try:
        widget_args['label_text'] = _(field.info.get("label", field_name))
    except:
        pass
    
    widget_args['suppress_label'] = field.info.get("suppress_label", False)
    
    widget_args['is_required'] = field.info.get("required", False)
    if widget_args['is_required']:
        widget_args['validator'] = NotEmpty
    
    widget_args['expands'] = field.info.get("expands", False)
    
    if 'length' in field.info:
        widget_args['maxlength'] = field.info["length"]
    
    if 'default' in field.info:
        widget_args['default'] = field.info['default']
    
    if 'help_text' in field.info:
        if 'hover_help' in field.info and field.info['hover_help']:
            if "attrs" not in field.info:
                widget_args['attrs'] = {}
            widget_args['attrs']['title'] = field.info["help_text"]
        else:
            widget_args['help_text'] = field.info["help_text"]
    
    if 'toggle_name' in field.info:
        widget_args['toggle_name'] = field.info["toggle_name"]
        
        if 'toggle_option' in field.info:
            widget_args['toggle_option'] = field.info["toggle_option"]
        else:
            widget_args['toggle_option'] = "on"
        
        widget_args['toggle_function'] = field.info.get("toggle_function", None)
    
    if 'hidden' in field.info:
        widget_args['hidden'] = field.info["hidden"]
    if 'readonly_if_not_empty' in field.info:
        widget_args['readonly_if_not_empty'] = field.info["readonly_if_not_empty"]
    if 'read_only_post' in field.info:
        widget_args['post'] = field.info["read_only_post"]
    if 'read_only_markupsafe' in field.info:
        widget_args['markupsave'] = field.info["read_only_markupsave"]
    if 'format_function' in field.info:
        widget_args['format_function'] = field.info["format_function"]
    if 'disabled' in field.info:
        widget_args['disabled'] = field.info['disabled']
    
    # switch widget action and check functions
    if 'switch_key' in field.info:
        widget_args['key'] = field.info["switch_key"]
    if 'switch_storage' in field.info:
        widget_args['storage'] = lookup_entity_register(field.info["switch_storage"]).storage()
    if 'switch_action' in field.info:
        widget_args['action'] = field.info["switch_action"]
    if 'switch_check' in field.info:
        widget_args['check'] = field.info["switch_check"]
    
    # Autocomplete options7
    if 'autocomplete_max_results' in field.info:
        widget_args['max_results'] = field.info["autocomplete_max_results"]
    if 'autocomplete_min_length' in field.info:
        widget_args['autocomplete_min_length'] = field.info["autocomplete_min_length"]
    if 'autocomplete_tree' in field.info:
        widget_args['tree'] = field.info["autocomplete_tree"]
    
    # MultipleSelectField options
    if 'multiselect_title' in field.info:
        widget_args['title'] = field.info["multiselect_title"]
    if 'multiselect_searchable' in field.info:
        widget_args['searchable'] = field.info["multiselect_searchable"]
    if 'multiselect_sortable' in field.info:
        widget_args['sortable'] = field.info["multiselect_sortable"]
    if 'multiselect_draggable' in field.info:
        widget_args['draggable'] = field.info["multiselect_draggable"]
    if 'multiselect_double_clickable"' in field.info:
        widget_args['doubleClickable"'] = field.info["multiselect_double_clickable"]
    if 'multiselect_animated' in field.info:
        widget_args['animated'] = field.info["multiselect_animated"]
    if 'multiselect_show_effect' in field.info:
        widget_args['showEffect'] = field.info["multiselect_show_effect"]
    if 'multiselect_hide_effect' in field.info:
        widget_args['hideEffect'] = field.info["multiselect_hide_effect"]
    if 'multiselect_divider_location' in field.info:
        widget_args['dividerLocation'] = field.info["multiselect_divider_location"]
    if 'multiselect_url' in field.info:
        widget_args['url'] = field.info["multiselect_url"]
    if 'multiselect_data' in field.info:
        widget_args['data'] = field.info["multiselect_data"]
    if 'multiselect_data_fields' in field.info:
        widget_args['data_fields'] = field.info["multiselect_data_fields"]
    if 'multiselect_connect_with' in field.info:
        widget_args['connectWith'] = field.info["multiselect_connect_with"]
    
    # MultipleCheckField options
    if 'multicheck_hide_label' in field.info:
        widget_args['hide_label'] = field.info["multicheck_hide_label"]
    if 'multicheck_collapse_class' in field.info:
        widget_args['collapse_class'] = field.info["multicheck_collapse_class"]
    if 'multicheck_expand_class' in field.info:
        widget_args['expand_class'] = field.info["multicheck_expand_class"]
    if 'multicheck_not_selected' in field.info:
        widget_args['not_selected'] = field.info["multicheck_not_selected"]
    elif 'multicheck_not_selected_link' in field.info:
        widget_args['not_selected'] = widgets.Link(link=field.info["multicheck_not_selected_link"]).link
    if 'multicheck_selected' in field.info:
        widget_args['selected'] = field.info["multicheck_selected"]
    elif 'multicheck_selected_link' in field.info:
        widget_args['selected'] = widgets.Link(link=field.info["multicheck_selected_link"]).link
    if 'multicheck_partial' in field.info:
        widget_args['partial'] = field.info["multicheck_partial"]
    elif 'multicheck_partial_link' in field.info:
        widget_args['partial'] = widgets.Link(link=field.info["multicheck_partial_link"]).link
    if 'multicheck_group_target' in field.info:
        widget_args['groups'] = LazyList(multicheck_groups, field)
    if 'multicheck_text' in field.info:
        widget_args['text'] = field.info["multicheck_text"]
    
    # Slider options (user target if you want to use an Entity for the steps)
    if 'slider_min_title' in field.info:
        widget_args['min_title'] = field.info['slider_min_title']
    if 'slider_max_title' in field.info:
        widget_args['max_title'] = field.info['slider_max_title']
    if 'slider_min_image' in field.info:
        widget_args['min_image'] = field.info['slider_min_image']
    if 'slider_max_image' in field.info:
        widget_args['max_image'] = field.info['slider_max_image']
    if 'slider_min' in field.info:
        widget_args['min'] = field.info['slider_min']
    if 'slider_max' in field.info:
        widget_args['max'] = field.info['slider_max']
    if 'slider_step_size' in field.info:
        widget_args['step_size'] = field.info['slider_step_size']
    
    if field.info.get("target", None):
        widget_args['options'] = range_options(field=field)
    
    if hidden == True:
        widget = HiddenField
    elif read_only == True:
        widget = ReadonlyField
    else:
        widget = field.info.get("widget", None)
        if not widget:
            widget = widget_lookup(field.info)
            field.info["widget"] = widget
    
    widget_validator = field.info.get("widget_validator", None)
    if widget_validator:
        widget_args["validator"] = widget_validator
    
    # Create the widget instance
    result = { field_name: widget(**widget_args) }

    # Add a separator after the widget if required    
    if field.info.get("separator", False):
        result[field_name + 'Separator'] = widgets.Separator()
        
    return result


def create_fields_class(entity, exclude = None, read_only = None, fields = None):
    """
    ... autofunction::: create_fields_class
        Create a subclass of FieldSet with the field for editing the entity instances.
        The generated fieldset can be customized is several ways:
        1) excluding some fields
        2) rendering as read_only some fields
        3) generating a fieldset from a custom list of fields, containing both field ids or FormField instances
        :param entity: entity class
        :type entity: sub-class of Entity
        :param exclude: list of field name to be excluded
        :type exclude: list of strings
        :param read_only: list of field name to be rendered a read-only
        :type read_only: list of strings
        :param fields: custom list of fields
        :type fields: list of strings and/or FormField instance
        :return: Return a FieldSet class for the entity
        :rtype: FieldSet class
    """
    if exclude == None:
        exclude = []
    if read_only == None:
        read_only = []
    
    # Class field
    class_dict = OrderedDict()
    sort_list = []
    
    if fields:
        if not isinstance(fields, widgets.FieldsGroup):
            fields = widgets.FieldsGroup(fields=fields)
        # Fields from the 'fields' parameters
        for element in fields.fields: # use fields.fields to not get all fields recursevly
            if isinstance(element, widgets.FieldsGroup): # is a FieldsGroup
                class_dict[element.id] = element
                sort_list.append(element.id)
            elif hasattr(element, 'update_params'): # is a FormField
                if not element.id in exclude:
                    class_dict[element.id] = element
                    sort_list.append(element.id)
            elif isinstance(element, basestring): # String
                try:
                    field = entity.get_db_field(element)
                    field_name = remove_id_from_field_name(element)
                    if not field_name in exclude:
                        for key, value in create_field(field_name, field, read_only=(field_name in read_only)).iteritems():
                            class_dict[key] = value
                            sort_list.append(key)
                except KeyError:
                    # field not found...
                    pass
            else:
                raise ValueError("fields elements must be strings or FormField instances")
    else:
        # Validators from the entity list of fields
        for field_name, field in entity.get_db_fields_map().iteritems():
            field_name = remove_id_from_field_name(field_name)
            if not field_name in exclude:
                for key, value in create_field(field_name, field, read_only=(field_name in read_only)).iteritems():
                    class_dict[key] = value
                    sort_list.append(key)
    
    # Create the new class
    class_name = str(entity.__name__ + 'Fields')
    if exclude or read_only or fields:
        class_name += "%d" % int(time.time() * 1000) # ~unique class name
    OptionsClass = type(class_name, (widgets.FieldSet,), class_dict)
    setattr(OptionsClass, "_sort", sort_list)
    return OptionsClass
