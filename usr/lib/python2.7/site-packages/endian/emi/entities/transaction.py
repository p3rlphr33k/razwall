#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.core.logger import debug
from endian.emi.entities.types import sessionmaker #,scoped_session

class TransactionException(Exception):
    pass

class TransactionWrapper:

#   Session = scoped_session(sessionmaker(autoflush=True, autocommit=False))
    Session = sessionmaker(autoflush=True, autocommit=False)

    _trans = None
    _lastconn = None
    _commited = False
    _msg = ""
    _intransaction = False
    _debug_mode = False
    
    def __init__(self, msg = ""):
        self._msg = msg
        self.startTrans()
        
    def endTrans(self, success = True):
        if self._trans == None:
            raise TransactionException("You can't call endTrans when not being in a Transaction.")

    def enableDebug(self):
        self._debug_mode = True

    def startTrans(self):
        self._debug("[TRANSACTION] START")
        
    def commit(self):
        if self._trans == None:
            raise TransactionException("You can't call endTrans when not being in a Transaction.")
        self._debug("[TRANSACTION] COMMIT")
        self._commited = True
        
    def rollback(self):
        if self._trans == None:
            raise TransactionException("You can't call endTrans when not being in a Transaction.")
        self._debug("[TRANSACTION] ROLLBACK")
        self._commited = True
        
    def begin(self):
        if not self._commited:
            raise TransactionException("You can't call begin before issueing rollback or commit")
        self._commited = False
        
    def t(self):
        if self._commited:
            self.begin() 
        return self._trans
    
    def _debug(self, string):
        if not self._debug_mode: return
        if self._msg != "":
            debug("%s: %s" % (self._msg, string))
            
    def isCommited(self):
        return self._commited

  
class Transaction(TransactionWrapper):
    
    def __init__(self, msg = ""):
        TransactionWrapper.__init__(self, msg)
        
    def endTrans(self, success = True):
        TransactionWrapper.endTrans(self, success)
        if not success:
            self.rollback()
        
        if success:
            if not self._commited:
                self.commit()
        self._trans.flush()
        self._trans.close()
        self._intransaction = False
        return True

    def startTrans(self):
        TransactionWrapper.startTrans(self)
        self.begin()
        
    def commit(self):
        TransactionWrapper.commit(self)
        self._trans.commit()
        self._commited = True
    
    def rollback(self):
        TransactionWrapper.rollback(self)
        self._trans.rollback()
        self._commited = True
        
    def begin(self):
        if not self._trans:
            self._trans = self.Session()
        if not self._trans.is_active:
            self._trans.begin()
        self._intransaction = True
        self._commited = False
    
    def add(self, *argv):
        return self._trans.add(*argv)

    def delete(self, *argv):
        return self._trans.delete(*argv)
    
    def query(self, *argv):
        return self._trans.query(*argv)
