#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import copy
from UserDict import DictMixin
from endian.emi.entities import types
from endian.emi.entities.schema import create_schema_class

# Default entity type
DEFAULT_ENTITY_TYPE = 'db'

# Valid entity types
ENTITY_TYPES = frozenset([
        'db',
        'dynamic',
        'computed',
        'const',
        'csv',
        'proxy',
        'settings',
        'yaml',
        'directory',
        'emaildirectory',
        'mongo'])


class EntityMeta(types.EntityMeta):

    def __call__(cls, *args, **kwargs):
        if cls._descriptor.autosetup and not hasattr(cls, '_setup_done'):
            return types.EntityMeta.__call__(cls, *args, **kwargs)
        
        result = object.__new__(cls)
        result.__init__(**kwargs)
        return result


class Entity(types.EntityBase, DictMixin):
    __metaclass__ = EntityMeta

    _fieldsClass = None
    _schemaClass = None
    _storage = None
    _keys = None
    _type = None # valid types are ENTITY_TYPES
    _cache_type = None # valid types are "disabled", "memory", "file" (is only supported with CachedStorages like YAML, directory...)
    _namespace = None # storage namespace 
    _register_datasource = True # if true, register the namespace
    _storage_args = None # a dict of args to be passed to the storage costructor
    _db_fields = None # maps field name to field
    _verbose = False # enable verbose output for storage ...
    ACTION = None
    acl = None
    label_field = None
    chained_validators = None
    property_keys = None # dlist of property names, the value of the properties will be added when the entity is converted to a dict
    json_keys = None # define a list with keys here if you do not want to return all key/value pairs with json
    
    # XXX: currently only supported by CachedStorage (like YamlStorage and DirectoryStorage)
    search_keys = [] # list of field keys to use for search with search_string (contains)
    exclude_from_search = [] # list of field keys not to be used for search with search_string (contains)
    # XXX
    
    def __init__(self, **kwargs):
        if self._type == 'db':
            types.EntityBase.__init__(self, **kwargs)
        else:
            for key, value in kwargs.iteritems():
                setattr(self, key, value)
        if self.property_keys:
            keys = copy.copy(self._keys)
            keys += self.property_keys
            self._keys = keys
    
    def get(self, *args, **kwargs):
        """
        Return the value for key if key is in the dictionary, else default.
        If default is not given, it defaults to None, so that this method never raises a KeyError
        """
        #if args[0] != None and isinstance(args[0], int):
        #    return self.query.get(args[0]);
        return DictMixin.get(self, *args, **kwargs)
        
    @classmethod
    def fieldsClass(cls, exclude = None, readOnly = None, fields = None):   
        """
        ... autofunction::: fieldsClass
            Create a subclass of FieldSet with the field for editing this entity.
            The generated fieldset can be customized is several ways:
            1) excluding some fields
            2) rendering as readonly some fields
            3) generating a fieldset from a custom list of fields, containing both field ids or FormField instances
            :param exclude: list of field name to be excluded
            :type exclude: list of strings
            :param readOnly: list of field name to be rendered a read-only
            :type readOnly: list of strings
            :param fields: list of field name to be rendered a read-only
            :type fields: list of strings and/or FormField instance      
            :return: Return a FieldSet class for this Entity
            :rtype: FieldSet class
        """
        from fieldset import create_fields_class
        if exclude or readOnly or fields: # don't use cls._fieldsClass with customized field class
            return create_fields_class(cls, exclude=exclude, read_only=readOnly, fields=fields)

        if not cls._fieldsClass:
            cls._fieldsClass = create_fields_class(cls)
        return cls._fieldsClass

    @classmethod
    def fields(cls, exclude = None, readOnly = None, fields = None):
        """
        ... autofunction::: fields
            Return a FieldSet instance for this Entity
        """
        return (cls.fieldsClass(exclude=exclude, readOnly=readOnly, fields=fields))()
    
    @classmethod
    def fieldsDict(cls, exclude=None, readOnly=None, fields=None):
        """
        ... autofunction::: fieldsDict
            Return a FieldSet instance for this Entity within a dictionary (id is used as key)
        """
        fields = cls.fields(exclude=exclude, readOnly=readOnly, fields=fields)
        fieldsdict = {}
        for field in fields:
            fieldsdict[field.id] = field
        return fieldsdict
    
    @classmethod
    def schemaClass(cls, exclude = None, fields = None, allow_extra_fields = None):
        """
        ... autofunction::: schemaClass
            Create a subclass of Schema with the validators for this Entity
            The generated fieldset can be customized is several ways:
            1) excluding some fields
            3) generating a schema from a custom list of fields, containing both field ids or Validator instances
            :param exclude: list of field name to be excluded
            :type exclude: list of strings
            :param fields: custom list of fields
            :type fields: list of strings and/or "(id, Validator)" tuples
            :param allow_extra_fields: if the parameter is present, it is added to the schema class
            :type allow_extra_fields: boolean
            :return: Return a Schema class for this entity
            :rtype: Schema class
        """
        if exclude or fields or allow_extra_fields: # don't use cls._schemaClass with customized schema class
            return create_schema_class(cls, exclude=exclude, fields=fields, allow_extra_fields=allow_extra_fields)
        
        if not cls._schemaClass:
            cls._schemaClass = create_schema_class(cls)         
        return cls._schemaClass
 
    @classmethod
    def storage(cls):   
        """
        ... autofunction::: storage
            Return a Storage for this Entity
        """
        if cls._storage:
            return cls._storage

        storage_args = cls._storage_args
        storage_args = cls._descriptor.storage_args
        if type(storage_args) != dict:
            storage_args = {}
              
        if cls._type == 'db':
            from endian.emi.storage.dbstorage import DBStorage
            cls._storage = DBStorage(entity=cls, **storage_args)
            
        elif cls._type == 'dynamic' or cls._type == 'const':
            from endian.emi.storage.dynamicstorage import DynamicStorage
            cls._storage = DynamicStorage(entity=cls, **storage_args)
            
        elif cls._type == 'settings':
            from endian.emi.storage.datasourcestorage import DataSourceStorage, FileAlreadyRegisteredError, registerDataSourceHandler, SETTINGS
            if cls._register_datasource:
                try:
                    # Registed the datasource handler
                    registerDataSourceHandler(cls._namespace, SETTINGS)
                except FileAlreadyRegisteredError:
                    pass
            cls._storage = DataSourceStorage(cls.schemaClass(), cls._namespace, **storage_args) 
        
        elif cls._type == 'csv':
            from endian.emi.storage.csvstorage import CSVStorage
            cls._storage = CSVStorage(entity=cls, **storage_args)
        
        elif cls._type == 'yaml':
            from endian.emi.storage.yamlstorage import YamlStorage
            cls._storage = YamlStorage(entity=cls, **storage_args)

        elif cls._type == 'mongo':
            from endian.emi.storage.mongostorage import MongoStorage
            cls._storage = MongoStorage(entity=cls, **storage_args)

        elif cls._type == 'computed':
            from endian.emi.storage.computedstorage import ComputedStorage
            cls._storage = ComputedStorage(**storage_args)

        elif cls._type == 'directory':
            from endian.emi.storage.directorystorage import DirectoryStorage
            cls._storage = DirectoryStorage(entity=cls, **storage_args)

        elif cls._type == 'emaildirectory':
            from endian.emi.storage.emaildirectorystorage import EmailDirectoryStorage
            cls._storage = EmailDirectoryStorage(entity=cls, **storage_args)

        return cls._storage
 
    def __getitem__(self, key):
        """
        ... autofunction::: __getitem__
            Return the value of a property
            :param key: the property's name
            :type key: string
            :return: the property's value
            :rtype: any
        """
        try:
            return getattr(self, self._convert_id_case(key))
        except AttributeError:
            raise KeyError(key)
                
    def __setitem__(self, key, value):        
        """
        ... autofunction::: __setitem__
            Set the value of a property
            :param key: the property's name
            :type key: string
            :param value: the property's value
            :type value: any
        """
        try:
            return setattr(self, self._convert_id_case(key), value)
        except AttributeError:
            raise KeyError(key)

    def keys(self):
        """
        ... autofunction::: keys
            Return the list of keys
            :return: list of keys
            :rtype: list 
        """
        return self._keys
    
    def to_dict(self, exclude=[], include=[]):
        """
        ... autofunction::: to_dict
            Generate a JSON-style dict structure from this entity
        """
        return self.asDictionary(exclude=exclude, include=include)
    
    def __nonzero__(self):
        """
        .. autofunction::: __nonzero__
           Called to implement truth value testing.
           Always return 'True' for Entity instances.
        """
        return True
    
    def acl_has_access(self, current_identity=None):
        """
        .. autofunction::: acl_has_access
           Returns 'True' if the current user has access to this entity
        """
        return self.hasAccess(current_identity) # use the old implementation if it exist
        
    def hasAccess(self, current_identity=None):
        """
        .. autofunction::: hasAccess
           DEPRECATED: use 'has_access' instead
           Returns 'True' if the current user has access to this entity
        """
        return True

    def acl_is_owner(self, current_identity=None):
        """
        .. autofunction::: acl_is_owner
           Returns 'True' if the current user is the owner of this entity
        """
        return self.isOwner(current_identity) # use the old implementation if it exist
            
    def isOwner(self, current_identity=None):
        """
        .. autofunction::: isOwner
           DEPRECATED: use 'is_owner' instead
           Returns 'True' if the current user is the owner of this entity
        """
        return False
            
    def __str__(self):
        r = [u"%s : %s" % (i[0], i[1]) for i in self.items()]
        return "{" + ", ".join(r) + "}"

    def asDictionary(self, uppercaseId=False, exclude=[], include=[]):
        """
        ... autofunction::: asDictionary
            Return the individual as a dictionary
            :param uppercaseId: if true, convert 'id' (if lowercase) into 'ID'
            :type uppercaseId: bool
            :return: a dictionary
            :rtype: dict 
        """
        if not include:
            include = self._keys
        col_prop_names = self._keys
        data = {}
        for name in col_prop_names:
            if name in exclude and name not in include:
                continue
            if hasattr(self, self._convert_id_case(name)):
                data[name] = getattr(self, self._convert_id_case(name))
        if uppercaseId:
            if 'id' in data:
                data['ID'] = data['id']
                del data['id']
        # else:
        #     if 'ID' in data:
        #         data['id'] = data['ID']
        #         del data['ID']
        return data


    @property
    def _is_id_uppercase(self):
        """ True if the entity id is uppercase (i.e. True if it is 'ID', False if it is 'id') """
        # Determinate in the id is uppercase or lowercase
        result = 'ID' in self._keys
        self.__class__._is_id_uppercase = result # Set the result as class level
        return result
        
    def _convert_id_case(self, key):
        if self._is_id_uppercase:
            return key == 'id' and "ID" or key
        else:
            return key == 'ID' and 'id' or key

    @classmethod
    def get_db_field(cls, fieldName):
        """
        ... autofunction::: get_db_field
            Returns a db field by its name
        """
        return cls._db_fields[fieldName]

    @classmethod    
    def get_db_fields_map(cls):
        """
        ... autofunction::: get_db_field
            Returns the dict what associates fields name with fields
        """
        return cls._db_fields
    
    @classmethod
    def filterQueryByKeyword(cls, values, keyword):
       tmp = values
       values = []
       for item in tmp:
           for key, value in item.iteritems():
               if type(value) == bool:
                   continue
               if unicode(value).lower().find(keyword.lower()) != -1:
                   values.append(item)
                   break
       return values
    
    def __json__(self, include=[]):
        if not include:
            include = self.json_keys
        return self.asDictionary(uppercaseId=True, include=include)
