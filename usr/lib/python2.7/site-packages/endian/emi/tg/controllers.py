# Classes and methods for TurboGears controllers
#
# Copyright (c) 2005 Kevin Dangoor
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 

from endian.core import logger

import logging
import urllib
import urlparse
import time
import types
import simplejson
import cherrypy
from cherrypy import request, response

from turbogears import database, config
from endian.emi.tg.decorator import weak_signature_decorator
from endian.emi.tg import util
from endian.emi.tg import view
from endian.emi.tg import errorhandling

__all__ = [
    "TgController",
    "expose",
    "flash",
    "url",
    "redirect",
    "register_expose_hook",
]

_expose_hooks = []

def register_expose_hook(fn):
    """
        Register an hook to be executed before an exposed method
    """
    _expose_hooks.append(fn)

def _process_output(output, template, format, content_type, fragment=False,
                    **options):
    """
       Produce final output form from data returned from a controller method
    """
    if isinstance(output, dict):
        if template == None and format == None:
            output = simplejson.dumps(output)
        else:
            headers = {'Content-Type': content_type}
            output = view.render(output, template=template, format=format,
                                 headers=headers, fragment=fragment, **options)
            content_type = headers['Content-Type']

    if content_type:
        response.headers['Content-Type'] = content_type
    else:
        content_type = response.headers.get('Content-Type', 'text/plain')

    if content_type.startswith('text/'):
        if isinstance(output, unicode):
            output = output.encode(util.get_template_encoding_default())

    return output


def expose(template=None, allow_json=None, format=None, content_type=None,
           fragment=False, as_format="default", accept_format=None, **options):
    """
        Exposes a method to the web.

        By putting the expose decorator on a method, you tell TurboGears that
        the method should be accessible via URL traversal. Additionally, expose
        handles the output processing (turning a dictionary into finished
        output) and is also responsible for ensuring that the request is
        wrapped in a database transaction.

        When as_format is set, passing the same value in the tg_format
        parameter in a request will choose the options for that expose
        decorator. Similarly, accept_format will watch for matching
        Accept headers. You can also use both. expose("json", as_format="json",
        accept_format="application/json") will choose JSON output for either
        case: tg_format=json as a parameter or Accept: application/json as a
        request header.

        Passing allow_json=True to an expose decorator
        is equivalent to adding the decorator just mentioned.

        Each expose decorator has its own set of options, and each one
        can choose a different template or even template engine (you can
        use Kid for HTML output and Cheetah for plain text, for example).
        See the other expose parameters below to learn about the options
        you can pass to the template engine.

        All additional keyword arguments are passed as keyword args to the render
        method of the template engine.
    """
    if not template:
        template = format
    if template == "json" or format == "json" or content_type == "application/json":
        content_type = "application/json"
        format = "json"
        template = "json"
        fragment = False
    if content_type is None:
        content_type = config.get("tg.content_type", None)
    if config.get("tg.session.automatic_lock", None):
        cherrypy.session.acquire_lock()

    def entangle(func):
        logger.debug("Exposing %s", func)
        logger.debug("template: %s, format: %s, allow_json: %s, content-type: %s", template, format, allow_json, content_type)
        if not getattr(func, "exposed", False):
            def expose(func, *args, **kw):
                
                # Executed the hooks
                if _expose_hooks:
                    for hook in _expose_hooks:
                        hook()

                request.tg_template_enginename = view.choose_engine(template)[2]
                accept = request.headers.get('Accept', "").lower()
                accept = util.simplify_http_accept_header(accept)
                _expose = lambda _func, accept, allow_json, *args, **kw: \
                        _execute_func(_func, template, format, content_type, fragment, options, args, kw)

                if hasattr(request, "in_transaction"):
                    output = _expose(func, accept, func._allow_json, *args, **kw)
                else:
                    request.in_transaction = True
                    # Check if there is an active SQLAlchemy configuration
                    if database._use_sa():
                        database.session.expire_all()
                    output = database.run_with_transaction(
                            _expose, func, accept, func._allow_json, *args, **kw)
                return output
            func.exposed = True
            func._allow_json = template == "json"
        else:
            expose = lambda func, *args, **kw: func(*args, **kw)

        return expose
    return weak_signature_decorator(entangle)


def _execute_func(func, template, format, content_type, fragment, options,
                  args, kw):
    """
       Call controller method and process it's output.
    """
    # get special parameters used by upstream decorators like paginate
    try:
        tg_kw = dict([(k, v) for k, v in kw.items() if k in func._tg_args])
    except AttributeError:
        tg_kw = {}
    # remove excessive parameters
    args, kw = util.adapt_call(func, args, kw)
    # add special parameters again
    kw.update(tg_kw)

    if config.get('server.environment', 'development') == 'development':
        # Only output this in development mode: If it's a field storage object,
        # this means big memory usage, and we don't want that in production
        logger.debug("Calling %s with *(%s), **(%s)", func, args, kw)

    output = errorhandling.try_call(func, *args, **kw)
    if response.headers.get('Content-Type') == 'application/json':
       content_type = 'application/json'

    if str(getattr(response, 'status', '')).startswith('204'):
        # HTTP status 204 indicates a response with no body
        # so there should be no content type header
        try:
            del response.headers['Content-Type']
        except (AttributeError, KeyError):
            pass
        return

    else:
        assert isinstance(output,
            (basestring, dict, list, types.GeneratorType)), (
            "Method %s.%s() returned unexpected output. Output should "
            "be of type basestring, dict, list or generator." % (
             args[0].__class__.__name__, func.__name__))

        if isinstance(output, dict):
            template = output.pop("tg_template", template)
            format = output.pop("tg_format", format)

        if template and template.startswith("."):
            template = func.__module__[:func.__module__.rfind('.')] + template

        return _process_output(output, template, format, content_type,
                               fragment, **options)


def flash(message):
    """ Obsolete - Set a message to be displayed in the browser on next page display."""
    pass


class TgController(object):
    """Base class for a web application's controller.

    It is important that your controllers inherit from this class, otherwise
    ``identity.SecureResource`` and ``identity.SecureObject`` will not work
    correctly.

    """

    @classmethod
    def _cp_log_message(cls, msg, context = 'nocontext', severity = 0):
        """Default method for logging messages (errors and app-specific info)"""
        text = ''.join((context, ': ', msg))
        if severity == 0:
            logger.info(text)
        elif severity == 1:
            logger.warn(text)
        else:
            logger.error(text)

    accesslog = logging.getLogger('turbogears.access')

    @classmethod
    def _cp_log_access(cls):
        """Default method for logging access"""
        # Conforms to Combined Log Format
        # http://httpd.apache.org/docs/2.2/logs.html#combined
        tmpl = ('%(host)s %(ident)s %(authuser)s [%(date)s] "%(request)s"'
            ' %(status)s %(bytes)s "%(referrer)s" "%(useragent)s"')
        try:
            username = request.user_name
            if username and isinstance(username, unicode):
                # might get concatenated to non-ascii byte strings
                username = username.encode('utf-8')
            else:
                username = '-'
        except AttributeError:
            username = '-'
        request_date = time.strftime('%d/%b/%Y:%H:%M:%S +0000',time.gmtime())
        request_info = {
            'host': request.headers.get('X-Forwarded-For')
                or request.remote_host or request.remote_addr,
            'ident': '-',
            'authuser': username,
            'date': request_date,
            'request': request.requestLine,
            'status': response.status.split(None, 1)[0],
            'bytes': response.headers.get('Content-Length') or '-',
            'referrer': request.headers.get('referer', ''),
            'useragent': request.headers.get('user-agent', ''),
        }
        cls.accesslog.info(tmpl, request_info)


def url(tgpath, tgparams=None, **kw):
    """
       Computes relocatable URLs.

       tgpath can be a list or a string. If the path is absolute (starts with a
       "/"), the server.webpath, SCRIPT_NAME and the approot of the application
       are prepended to the path. In order for the approot to be detected
       properly, the root object must extend controllers.RootController.

       Query parameters for the URL can be passed in as a dictionary in
       the second argument and/or as keyword parameters where keyword args
       overwrite entries in the dictionary.

       Values which are a list or a tuple are used to create multiple
       key-value pairs.

       tgpath may also already contain a (properly escaped) query string seperated
       by a question mark ('?'), in which case additional query params are
       appended.
    """
    if not isinstance(tgpath, basestring):
        tgpath = '/'.join(list(tgpath))
    if tgpath.startswith('/'):
        webpath = (config.get('server.webpath') or '').rstrip('/')
        if util.request_available():
            tgpath = tgpath
            try:
                webpath += request.wsgi_environ['SCRIPT_NAME'].rstrip('/')
            except (AttributeError, KeyError):
                pass
        tgpath = webpath + tgpath
    if tgparams is None:
        tgparams = kw
    else:
        try:
            tgparams = tgparams.copy()
            tgparams.update(kw)
        except AttributeError:
            raise TypeError('url() expects a dictionary for query parameters')
    args = []
    for key, value in tgparams.iteritems():
        if value is None:
            continue
        if isinstance(value, (list, tuple)):
            pairs = [(key, v) for v in value]
        else:
            pairs = [(key, value)]
        for k, v in pairs:
            if v is None:
                continue
            if isinstance(v, unicode):
                v = v.encode('utf8')
            args.append((k, str(v)))
    if args:
        query_string = urllib.urlencode(args, True)
        if '?' in tgpath:
            tgpath += '&' + query_string
        else:
            tgpath += '?' + query_string
    return tgpath

def redirect(redirect_path, redirect_params=None, **kw):
    """
       Redirect (via cherrypy.HTTPRedirect).
       Raises the exception instead of returning it, this to allow
       users to both call it as a function or to raise it as an exception.
    """
    if not isinstance(redirect_path, basestring):
        redirect_path = '/'.join(list(redirect_path))
    if not redirect_path.startswith('/'):
        path = request.path_info
        redirect_path = urlparse.urljoin(path, redirect_path)
    # set redirect_path in request object, otherwhise auth decorators on properties wrapping controllers will not work
    # because cherrypy will loop until the worker thread handling this request exits
    request.redirect_path = url(tgpath=redirect_path, tgparams=redirect_params, **kw)
    raise cherrypy.HTTPRedirect(request.redirect_path)
