# Classes and methods for TurboGears view
#
# Copyright (c) 2005 Kevin Dangoor
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
#
# Template processing for TurboGears view layer.
# 
# The template engines are configured and loaded here and this module provides
# the generic template rendering function "render", which selects the template
# engine to use and the appropriate output format, headers and encoding based
# on the given arguments and the application configuration.
# 
# Also defines the functions and variables that will be available in the
# template scope and provides a hook for adding additional template variables.
#

import endian.core.i18n
from endian.core import logger
from itertools import chain
from itertools import cycle as icycle
from urllib import quote_plus
import cherrypy
import pkg_resources
from endian.emi.tg.jsonsupport import JsonSupport
import turbogears
from turbogears import identity, config


# the gettext imported here can be whatever function returned
# by the i18n module depending on the user's configuration
# all the functions will implement the same interface so we don't care
from turbogears.i18n import get_locale, gettext

from endian.emi.tg.util import Bunch, \
    adapt_call, \
    get_template_encoding_default, \
    get_mime_type_for_format, \
    mime_type_has_charset


__all__ = ['load_engines',
           'loadBaseTemplates']

engines = dict()

ENGINE_DEFAULTS = {
    "json.assume_encoding": "utf-8",
    "json.check_circular": True,
    "json.descent_bases": True,
    "json.encoding": "utf-8",
    "json.ensure_ascii": False,
    "json.sort_keys": False,
    "mako.directories": [''],
    "mako.output_encoding": "utf-8"
}

def choose_engine(template):
    """
    Return template engine for given template name.
    """
    if isinstance(template, basestring):
        engine = engines.get(template, None)
        if engine:
            return engine, None, template

    enginename = "mako"
    engine = engines.get(enginename, None)

    if not engine:
        raise KeyError("Template engine %s is not installed" % enginename)

    return engine, template, enginename


def render(info, template=None, format=None, headers=None, fragment=False,
           **options):
    """
    Renders data in the desired format.
    All additional keyword arguments are passed as keyword args to the render
    method of the template engine.

    :param info:     the data itself
    :type info:      dict
    :param template: name of the template to use
    :type template:  string
    :param format:   "html", "xml", "text" or "json"
    :type format:    string
    :param headers:  for response headers, primarily the content type
    :type headers:   dict
    :param fragment: passed through to tell the template if only a
                     fragment of a page is desired. This is a way to allow
                     xml template engines to generate non valid html/xml
                     because you warn them to not bother about it.
    :type fragment:  bool
    """
    environ = getattr(cherrypy.request, 'wsgi_environ', {})
    if environ.get('paste.testing', False):
        cherrypy.request.wsgi_environ['paste.testing_variables']['raw'] = info

    if format == 'json':
        template = 'json'
    else:
        template = info.pop("tg_template", template)

    engine, template, enginename = choose_engine(template)

    if not format:
        if enginename == 'json':
            format = 'json'
        else:
            format = config.get("%s.outputformat" % enginename,
                config.get("%s.default_format" % enginename, 'html'))
    elif format == 'plain':
        format = 'text'

    if isinstance(headers, dict):
        # Determine the proper content type and charset for the response.
        # We simply derive the content type from the format here
        # and use the charset specified in the configuration setting.
        # This could be improved by also examining the engine and the output.
        content_type = headers.get('Content-Type')
        if not content_type:
            if not format:
                content_format = 'html'
            else:
                content_format = format
                if isinstance(content_format, (tuple, list)):
                    content_format = content_format[0]
                if isinstance(content_format, str):
                    content_format = content_format.split()[0].split('-' , 1)[0].lower()
                else:
                    content_format = 'html'

            content_type = get_mime_type_for_format(content_format)

        if mime_type_has_charset(content_type) and '; charset=' not in content_type:
            charset = options.get('encoding', get_template_encoding_default(enginename))
            if charset:
                content_type += '; charset=' + charset

        headers['Content-Type'] = content_type

    args, kw = adapt_call(engine.render, args=[], kw=dict(
        info=info, format=format, fragment=fragment, template=template,
        **options), start=1)

    return engine.render(**kw)


class cycle:
    """Loops forever over an iterator.

    Wraps the itertools.cycle method, but provides a way to get the current
    value via the 'value' attribute.

    """
    value = None

    def __init__(self, iterable):
        self._cycle = icycle(iterable)

    def __str__(self):
        return self.value.__str__()

    def __repr__(self):
        return self.value.__repr__()

    def next(self):
        self.value = self._cycle.next()
        return self.value


def selector(expression):
    """If the expression is true, return the string 'selected'.

    Useful for HTML <option>s.

    """
    if expression:
        return "selected"
    else:
        return None


def checker(expression):
    """If the expression is true, return the string "checked".

    This is useful for checkbox inputs.

    """
    if expression:
        return "checked"
    else:
        return None


def ipeek(iterable):
    """Lets you look at the first item in an iterator.

    This is a good way to verify that the iterator actually contains something.
    This is useful for cases where you will choose not to display a list or
    table if there is no data present.

    """
    iterable = iter(iterable)
    try:
        item = iterable.next()
        return chain([item], iterable)
    except StopIteration:
        return None



def stdvars():
    """Create a Bunch of variables that should be available in all templates.

    These variables are:

    checker
        the checker function
    config
        the cherrypy config get function
    cycle
        cycle through a set of values
    errors
        validation errors
    identity
        the current visitor's identity information
    inputs
        input values from a form
    ipeek
        the ipeek function
    locale
        the default locale
    quote_plus
        the urllib quote_plus function
    request
        the cherrypy request
    selector
        the selector function
    session
        the current cherrypy.session if the session_filter.on it set
        in the app.cfg configuration file. If it is not set then session
        will be None.
    tg_js
        the url path to the JavaScript libraries
    url
        the turbogears.url function for creating flexible URLs

    Additionally, you can add a callable to turbogears.view.variable_providers
    that can add more variables to this list. The callable will be called with
    the vars Bunch after these standard variables have been set up.

    """
    if config.get('session_filter.on', None):
        session = cherrypy.session
    else:
        session = None

    webpath = turbogears.startup.webpath or ''
    tg_vars = Bunch(
        checker = checker,
        config = config.get,
        cycle = cycle,
        errors = getattr(cherrypy.request, 'validation_errors', {}),
        identity = identity.current,
        inputs = getattr(cherrypy.request, 'input_values', {}),
        ipeek = ipeek,
        locale = get_locale(),
        quote_plus = quote_plus,
        request = cherrypy.request,
        selector = selector,
        session = session,
        tg_js = '/' + webpath + 'tg_js',
        url = turbogears.url,
        widgets = '/' + webpath + 'tg_widgets',
    )
    root_vars = dict()
    root_vars['_'] = gettext
    root_vars['tg'] = tg_vars
    return root_vars


def loadBaseTemplates():
    """
       do nothing. keep for compatibility with TurgoGears API
    """
    pass


def _get_plugin_options(plugin_name):
    """
       Return all options from global config where the first part of the config
       setting name matches the start of plugin_name.
    """
    options = dict((k, v) for k, v in ENGINE_DEFAULTS.items() if plugin_name.startswith(k.split('.', 1)[0]))
    for k, v in config.config.configMap["global"].items():
        if plugin_name.startswith(k.split('.', 1)[0]):
            options[k] = v
    return options


def load_engines():
    """
       Load and initialize all templating engines.
    """
    for entrypoint in pkg_resources.iter_entry_points("python.templating.engines"):
        logger.error(str(entrypoint))
        # Avoid loading genshi & kid
        plugin_name = entrypoint.name
        if plugin_name in ['genshi', 'genshi-text', 'genshi-markup', 'kid', 'cheetah', 'json']:
            continue
        engine = entrypoint.load()
        logger.error(str(engine))
        engine_options = _get_plugin_options(plugin_name)
        logger.error(str(engine_options))
        engines[plugin_name] = engine(stdvars, engine_options)
    # Initialize the JSON template engin
    engines['json'] = JsonSupport(stdvars)

