#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from tw.forms import FormField

import endian.core.i18n
from endian.core.classtools import classproperty
from endian.validators.core import FancyValidator, Invalid
from endian.emi.widgets.static import *

class AutocompleteValidator(FancyValidator):
    
    autocomplete_field_cls = None
            
    def __init__(self, autocomplete_field_cls, *args, **kw):
        self.autocomplete_field_cls = autocomplete_field_cls
        FancyValidator.__init__(self, *args, **kw)

    def _to_python(self, value, state):
        try:
            result = self.autocomplete_field_cls.value_to_python(value)
            if result == None:
                raise ValueError
            return result
        except:
            raise Invalid(self.autocomplete_field_cls.invalid_msg, value, state)

    def _from_python(self, value, state):
        if getattr(self.autocomplete_field_cls, "python_to_value", None):
            return self.autocomplete_field_cls.python_to_value(value)
        else:
            return value


class AutocompleteField(FormField):
    template = "endian.emi.templates.autocomplete"
    engine_name = "mako"
    
    css = [jquery_ui_autocomplete_css]
    javascript = [JSLink(link='/toscawidgets/resources/endian.emi/static/js/fieldselector.js', javascript=[jquery_ui_autocomplete])]
    
    params = {
        'entity': 'A callable that returns the Entity to use.',
        'ajaxurl': 'URL of ajax responder; you must define this explicitly in your controller.',
        'values': 'A callable that returns the values list (to be used instead of entity/ajaxurl)',
        'max_results': 'Maximum number of results to return',
        'value_to_python': 'A function converting the displayed value into a python object',
        'python_to_value': 'A function converting the python object into the displayed value',
        'invalid_msg': 'Message to be displayed for invalid value',
        'condition': 'Display condition function',
        'readonly_if_not_empty': 'If true, the field is editable only if the value is empty',
        'autocomplete_min_length': 'The minimum number of characters a user has to type before the Autocomplete activates',
        'tree': 'Enable multi-level tree style completition',
    }
    
    max_results = None
    autocomplete_min_length = None
    tree = None

    entity = None
    values = None
    invalid_msg = "You have to select an existing element"
    _validator = None
    
    def __init__(self,
            id=None,
            max_results=40,
            autocomplete_min_length=0,
            tree=True,
            values=None,
            options=None,
            **args):
        if self.max_results is None:
            self.max_results = max_results
        if self.autocomplete_min_length is None:
            self.autocomplete_min_length = autocomplete_min_length
        if self.tree is None:
            self.tree = tree
        if self.values is None:
            self.values = values
        if self.values is None:
            if options:
                self.values = map(lambda (value, label): {'value': value, 'label': label}, options)
        super(AutocompleteField, self).__init__(id=id, **args)
    
    @classmethod
    def text_search(cls, search=None):
        return {'data': cls.entity.text_search(search)[:cls.max_results]}
    
    @classmethod
    def value_to_python(cls, value):
        """overwrite this method if the value needs to get converted"""
        return value
    
    @classproperty
    def validator(cls):
        if not cls._validator:
            cls._validator = AutocompleteValidator(cls)
        return cls._validator

    def update_params(self,d):
        super(AutocompleteField, self).update_params(d)
        if d.get("readonly_if_not_empty") and d.get('value', None):
            d.attrs['readonly'] = True
                 
__all__ = ['AutocompleteField']
