#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from tw.forms import InputWidget
from endian.validators.core import Invalid

class __DeepForwarding__(InputWidget):
    """
    but allows to pass errors and values to more than three levels
    """

    def prepare_dict(self, value, kw, adapt=True):
        """
        Prepares the dict sent to the template with functions to access the
        children's errors if any.
        """
        if isinstance(value, dict):
            if hasattr(self, "value_at_request") and\
                    self.value_at_request == None:
                self.value_at_request = {}

        kw = super(__DeepForwarding__, self).prepare_dict(value, kw, adapt)

        for c in self.children:
            if getattr(c, 'strip_name', False):
                def get_all_subc(c):
                    ret = []
                    ret += c.children_deep
                    for x in c.children_deep:
                        ret += get_all_subc(x)
                    return ret
                # get all subnodes not just the one in the 
                # first level
                for subc in get_all_subc(c):
                #for subc in c.children_deep:
                    if hasattr(subc, '_name'):
                        try:
                            v = value.pop(subc._name)
                        except :
                            pass
                        else:
                            value.setdefault(c._name, {})[subc._name] = v

        return kw

    def propagate_errors(self, parent_kw, parent_error):
        child_args = parent_kw.setdefault('child_args',{})
        if parent_error.error_dict:
            if self.strip_name:
                for c in self.children:
                    def get_all_subc(c):
                        ret = []
                        ret += c.children
                        for x in c.children:
                            ret += get_all_subc(x)
                        return ret
                    # get all subnodes not just the one in the 
                    # first level
                    for subc in get_all_subc(c):
                    #for subc in c.children:
                        if hasattr(subc, '_name'):
                            try:
                                e = parent_error.error_dict.pop(subc._name)
                            except KeyError:
                                continue
                            if c._name not in parent_error.error_dict:
                                if isinstance(e, str):
                                    inv = Invalid(e, {}, None, error_dict={})
                                else:
                                    inv = Invalid("some error", {}, e.state, error_dict={})
                                parent_error.error_dict[c._name] = inv
                            child_errors = parent_error.error_dict[c._name].error_dict
                            child_errors[subc._name] = e
            for k,v in parent_error.error_dict.iteritems():
                child_args.setdefault(k, {})['error'] = v

