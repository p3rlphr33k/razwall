#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#
from tw.forms import SingleSelectField, MultipleSelectField

class RelationField(SingleSelectField):
    css_class = "singleselectfield"
    selected_verb = 'selected'
    template = "endian.emi.templates.relationfield"
    engine_name = "mako"
    
    relation = None
    key = "id"
    value = "name|comment|description"
    immutable = False
    multiple = False
    filter = None
    params = ["relation", "key", "value", "immutable", "multiple", "options"]
    
    def update_params(self, d):
        data = []
        if hasattr(self.relation, "load"):
            data = self.relation.load()
        elif callable(self.relation):
            data = self.relation()
            
        if self.filter:
            if callable(self.filter):
                filterlist = self.filter()
            else:
                filterlist = self.filter
        else:
            filterlist = []
            
        options = self.options
        if options is None:
            options = []
        if not options:
            keys = self.key.split("|")
            values = self.value.split("|")
            for item in data:
                key = None
                for k in keys:
                    key = item.get(k)
                    if key: break

                value = None
                for v in values:
                    value = item.get(v)
                    if value: break
                
                options.append([key,value])
        d["options"] = options or []
        
        super(RelationField, self).update_params(d)

        immutable = d.get("immutable") and d.get("value")
        d["immutable"] = immutable
        
        if not immutable and filterlist:            
            d["options"] = filter(lambda i: i[0] not in filterlist, d["options"])
            # call super again to build the new option list
            super(RelationField, self).update_params(d)
        return d

class MultipleRelationField(MultipleSelectField):
    css_class = "multipleselectfield"
    selected_verb = 'selected'
    template = "endian.emi.templates.relationfield"

    relation = None
    key = "id"
    value = "name|comment|description"
    immutable = False
    multiple = True
    filter = None
    params = ["relation", "key", "value", "immutable", "multiple", "options"]
    
    def update_params(self, d):
        data = []
        if hasattr(self.relation, "loadAll"):
            data = self.relation.loadAll()
        elif hasattr(self.relation, "load"):
            data = self.relation.load()
        elif callable(self.relation):
            data = self.relation()

        if self.filter:
            if callable(self.filter):
                filterlist = self.filter()
            else:
                filterlist = self.filter
        else:
            filterlist = []

        options = self.options
        if not options:            
            keys = self.key.split("|")
            values = self.value.split("|")
            for item in data:
                key = None
                for k in keys:
                    key = item.get(k)
                    if key: break

                value = None
                for v in values:
                    value = item.get(v)
                    if value: break

                options.append([key,value])
        d["options"] = options

        super(MultipleRelationField, self).update_params(d)

        immutable = d.get("immutable") and d.get("value")
        d["immutable"] = immutable

        if not immutable and filterlist:            
            d["options"] = filter(lambda i: i[0] not in filterlist, d["options"])
            # call super again to build the new option list
            super(MultipleRelationField, self).update_params(d)

        return d

if __name__ == "__main__":
    r = RelationField()
    print r.display()

__all__ = [
    'RelationField',
    'MultipleRelationField'
]
