#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from tw.forms.datagrid import Column as BaseColumn
from tw.api import Widget
from endian.core.i18n import _
from endian.core import logger
from endian.core.lazylist import CachedList
from gridaction import (
    Action, EnableAction, DisableAction, DeleteAction, MoveUpAction, MoveDownAction,
    DeleteConfirmAction, EditAction, EditInOverlayerAction, EditInOverlayerIFrameAction,
    ActiveAction, SaveAction, DownloadAction
)

_columnCounter = 0


class Column(BaseColumn):
    """
    Column class.

    name: column name
    getter: optional custom getter function
    title: column title
    empty_value: value to be used if the item vlue is null or empty
    format_function: optional function used for values formatting
    max_length: max length of strings
    width: column width in px
    field: the field used to get the value (default is equal to name)
    line_through_condition:
    param kendo_header_template: custom kendo header template
    type kendo_header_template: string
    param kendo_column_template: custom kendo column template
    type kendo_column_template: string
    """

    entity = None  # database entity
    empty_value = None  # empty value (this value will be displayed instead of 'None')
    max_length = None  # max length of strings
    width = None  # width in px
    css_class = None
    css_style = None
    line_through_condition = None
    #: custom kendo header template
    kendo_header_template = None
    #: custom kendo column template
    kendo_column_template = None
    kendo_excel_template = None
    #: custom kendo filter operators
    kendo_filterable_operators = None
    #: If set to true the filter menu allows the user to input a second criterion.
    kendo_filterable_extra = None
    #: hide this column
    hide = False

    def __init__(self,
                 name=None,
                 getter=None,
                 title=False,
                 options={},
                 coalesce=[],
                 empty_value=None,
                 format_function=None,
                 max_length=None,
                 width="",
                 css_class="",
                 css_style="",
                 field=None,
                 line_through_condition=None,
                 kendo_header_template="",
                 kendo_column_template="",
                 kendo_excel_template="",
                 kendo_filterable_operators={
                     'contains': _('Contains'),
                     'doesnotcontain': _('Does not contain')
                 },
                 kendo_filterable_extra=True,
                 hide=False,
                 sortable=True,
                 order_by=None,
                 search_keys=None,
                 entities=None):
        BaseColumn.__init__(self, name=name, title=title, options=options)
        if self.empty_value is None:
            self.empty_value = empty_value
        if self.empty_value is None:
            self.empty_value = "&lt;ANY&gt;"
        if format_function is not None:
            self.format_function = format_function
        if self.max_length is None:
            self.max_length = max_length
        if self.width is None:
            self.width = width
        if self.css_class is None:
            self.css_class = css_class
        if self.css_style is None:
            self.css_style = css_style
        if hide:
            self.hide = hide
        self.options["css_class"] = self.css_class
        self.options["css_style"] = self.css_style
        self.options['width'] = self.width
        global _columnCounter
        self.columnCount = _columnCounter
        _columnCounter = _columnCounter + 1
        # reference to the parent grid
        self.parent = None
        #: entities needed to join for ordering
        self.entities = entities
        self.coalesce = coalesce
        self.sortable = sortable
        # set the default getter
        if not getter:
            self.getter = self._getter
        else:
            self.getter = getter
        #: this can be a field name or a string with a comma seperated list of field names
        self.field = field or name
        if search_keys:
            #: we have a custom search_keys list
            self.search_keys = search_keys
        else:
            #: we use field as search_keys argument
            self.search_keys = self.field
        if order_by:
            #: if we do not want to order by the field, use this to define what should be used for sorting
            self.order_by = order_by
        else:
            #: we use field as order by argument
            self.order_by = self.field
        if self.line_through_condition is None:
            self.line_through_condition = line_through_condition
        if self.kendo_header_template is None:
            self.kendo_header_template = kendo_header_template
        if self.kendo_column_template is None:
            self.kendo_column_template = kendo_column_template
        if self.kendo_excel_template is None:
            self.kendo_excel_template = kendo_excel_template
        if self.kendo_filterable_operators is None:
            self.kendo_filterable_operators = kendo_filterable_operators
        if self.kendo_filterable_extra is None:
            self.kendo_filterable_extra = kendo_filterable_extra

    def _eval(self, field, row):
        if isinstance(row, dict):  # if row is a dictionary, retrieve the field
            result = row.get(field)
        else:  # if row is an entity, eval the field expression, so more complex expression are possibile
            try:
                result = eval('row.' + field, {'__builtins__': []}, {'row': row})
            except Exception, e:
                logger.debug("Column: _eval of field '%s' failed with: %s" % (field, str(e)))
                result = None
        # if isinstance(result, list):
        #     result = [isinstance(x, basestring) and unicode(markupsafe.escape(x)) or x for x in result]
        # elif isinstance(result, basestring):
        #     result = unicode(markupsafe.escape(result))
        return result

    def format_function(self, value):
        """Default format_function."""
        return value

    def _getter(self, row, data=list(), index=None, is_first_row=False, is_last_row=False):
        # retrieve the value(s)
        empty = True
        if self.coalesce:
            for name in self.coalesce:
                result = self._eval(name, row)
                if result:
                    break
            if self.format_function:
                result = self.format_function(result)

            if result or result == 0:
                empty = False
        else:
            fields = self.field
            if isinstance(fields, basestring):
                fields = fields.split(',')
            # elif not isinstance(self.field, list):
            #     fields = [self.field]

            result = {}
            for field in fields:

                name = field.strip()
                value = self._eval(name, row)
                # make sure no empty values are added
                if value or value == 0:
                    empty = False
                    if self.format_function:
                        value = self.format_function(value)
                elif self.kendo_column_template:
                    value = self.empty_value
                else:
                    continue
                if len(fields) == 1:
                    result = value
                    break
                result[name] = value

        if self.kendo_column_template:
            return result

        if empty:
            return self.empty_value

        if isinstance(result, dict):
            result = result.values()
        elif not isinstance(result, list):
            result = [result]

        try:
            result = u" ".join([unicode(x) for x in result])
        except:
            return self.empty_value

        try:
            if self.max_length and len(result) > self.max_length:
                result = result[0:self.max_length] + "..."
            return result
        except TypeError:
            return result

    def get_field(self, row, data=list(), displays_on=None, index=None, is_first_row=False, is_last_row=False):
        if isinstance(self.getter, Widget):
            row = row.get(self.getter.name)
            return self.getter(row, displays_on=displays_on)
        return self.getter(row, data, index, is_first_row, is_last_row)

    def is_line_through(self, row):
        """Return true if the line is disabled, according to the evaluation of the 'line_through_condition' condition."""
        if not self.line_through_condition:
            return False
        else:
            return eval('row.' + self.line_through_condition,
                        {'__builtins__': {'True': True, 'False': False, 'None': None}},
                        {'row': row})


class RuleColumn(Column):
    """@deprecated: RuleColumn has been deprecated: use Column instead."""

    def __init__(self, *args, **kargs):
        import warnings
        warnings.warn("RuleColumn has been deprecated: use Column instead.",
                      DeprecationWarning, 2)
        Column.__init__(self, *args, **kargs)


class RelationColumn(Column):

    def __init__(self, name=None, getter=None, title=None, options={}, coalesce=[], format_function=None, relation=None, key=None, value="name|comment|description", relation_cache_timeout=10):
        self.key = key
        self.value = value
        # If relation is a function or has load/loaddAll methods, create a CacheList instances.
        # The first time the CacheList is iterated, the method is called and is not called again
        # until cache's timeout (relation_cache_timeout is the timeout in seconds)
        if type(relation) == CachedList:
            self.relation = relation
        elif hasattr(relation, "load"):
            self.relation = CachedList(relation.load, timeout=relation_cache_timeout)
        elif callable(relation):
            self.relation = CachedList(relation, timeout=relation_cache_timeout)
        elif type(relation) == list:
            self.relation = relation
        else:
            self.relation = []
        if format_function is not None:
            self.custom_format_function = format_function
        Column.__init__(self, name, getter, title, options, coalesce)

    def _getValue(self, key, data):
        value = key
        for item in data:
            # if it's a dict try to get get value
            if hasattr(item, "get"):
                if item.get(self.key) == value:
                    values = self.value.split("|")

                    value = None
                    for v in values:
                        value = item.get(v)
                        if value:
                            break
                    break
            # if it's a list of items pick 0 as key an 1 as value
            elif type(item) in [list, tuple] and len(item) >= 2:
                k, v = item[0], item[1]
                if k == value:
                    value = v
                    break
        return value

    def custom_format_function(self, value):
        return value

    def format_function(self, value):
        value = self._getValue(value, self.relation)
        return self.custom_format_function(value)


class HiddenColumn(Column):
    """
    Checkbox element for row selection.

    name: column name
    getter: optional custom getter function
    disabled_function: optional function used to evaluate if the item is disabled
    field: the field used to get the value (default is equal to name)
    """

    hide = True
    disabled_function = None  # function (that accepts the row as single argument) for determinate if the checkbox is disabled

    def __init__(self, name='ID', getter=None, options={}, disabled_function=None, field=None, line_through_condition=None):
        title = ''
        if disabled_function:
            self.disabled_function = disabled_function
        Column.__init__(self, name=name, getter=getter, title=title, options=options, field=field, line_through_condition=line_through_condition)

    def _getter(self, row, data=list(), index=None, is_first_row=False, is_last_row=False):
        value = self._eval(self.field, row)
        if self.disabled_function:
            disabled = self.disabled_function(row) and u' disabled="disabled"' or u''
        else:
            disabled = u''
        result = u'<input type="hidden" name="%s" value="%s" %s />' % (self.name, value, disabled)
        return result


class CheckBoxColumn(Column):
    """
    Checkbox element for row selection.

    name: column name
    getter: optional custom getter function
    disabled_function: optional function used to evaluate if the item is disabled
    title: column title
    field: the field used to get the value (default is equal to name)
    """

    css_class = "checkbox"
    disabled_function = None  # function (that accepts the row as single argument) for determinate if the checkbox is disabled
    bool_values = False  # handle all values as bool

    def __init__(self, name='ID', getter=None, options={}, disabled_function=None, title=False, field=None, line_through_condition=None, bool_values=None, sortable=False):
        if title is False:
            title = u'<input type="checkbox" onclick="selectAll(this, \'%s\')" />' % name
            self.kendo_header_template = u'<input type=\\"checkbox\\" onclick=\\"$(this).parents(\'.k-grid\').find(\'.k-grid-content\').find(\'input[type=checkbox][name=%s]\').prop(\'checked\', $(this).prop(\'checked\'));\\" />' % name
        if disabled_function:
            self.disabled_function = disabled_function
        if bool_values is not None:
            self.bool_values = bool_values
        Column.__init__(self, name=name, getter=getter, title=title, options=options, field=field, line_through_condition=line_through_condition, sortable=sortable)

    def _getter(self, row, data=list(), index=None, is_first_row=False, is_last_row=False):
        value = self._eval(self.field, row)
        attrs = u''
        if self.bool_values:
            value = bool(value)
        if isinstance(value, bool):
            if value:
                attrs = u' checked="checked"'
        else:
            attrs = u' value="%s"' % value
        name = self.name
        hidden_field = u''
        if self.disabled_function and self.disabled_function(row):
            attrs = u'%s disabled="disabled"' % attrs
        elif self.name.upper() != "ID":
            hidden_field = u'<input type="hidden" name="%s" value="%s" class="%s" />' % (self.name, value or '', name)
            attrs = u'%s onclick="checkboxChanged(this)"' % attrs

        result = u'<input type="checkbox" name="%s" %s />%s' % (name, attrs, hidden_field)
        return result


class ActionsColumn(Column):
    css_class = "actions"

    idField = "ID"
    commonsActions = {
        'delete': DeleteAction,
        'deleteConfirm': DeleteConfirmAction,
        'delete_confirm': DeleteConfirmAction,
        'edit': EditAction,
        'edit_in_overlayer': EditInOverlayerAction,
        'edit_in_overlayer_iframe': EditInOverlayerIFrameAction,
        'moveUp': MoveUpAction,
        'moveDown': MoveDownAction,
        'enable': EnableAction,
        'disable': DisableAction,
        'active': ActiveAction,
        'save': SaveAction,
        'download': DownloadAction
    }
    actions = None
    dropdown = None
    multi_items_actions = None
    all_items_actions = None

    _imgClear = "/toscawidgets/resources/endian.emi/static/images/action_clear.gif"

    def __init__(self, actions=[], name="actions", title=_("Actions"), options={}, id_field="ID", dropdown=False, **kargs):
        Column.__init__(self, name=name, title=title, options=options, sortable=False, **kargs)

        self.idField = id_field
        self.actions = []
        self.multi_items_actions = []
        self.all_items_actions = []

        if self.dropdown is None:
            self.dropdown = dropdown

        for action in actions:
            if isinstance(action, basestring) and action in self.commonsActions.keys():
                action = self.commonsActions[action]()
                action.idField = self.idField
                action.actions = self
                if getattr(action, 'single_item_action', True):
                    self.actions.append(action)
                if getattr(action, 'multi_items_action', False):
                    if not action.name == "enable":
                        self.multi_items_actions.append(action)
                    else:
                        enableaction = EnableAction()
                        enableaction.idField = self.idField
                        enableaction.actions = self
                        self.multi_items_actions.append(enableaction)
                        disableaction = DisableAction()
                        disableaction.idField = self.idField
                        disableaction.actions = self
                        self.multi_items_actions.append(disableaction)
                if getattr(action, 'all_items_action', False):
                    if not action.name == "enable":
                        self.all_items_actions.append(action)
                    else:
                        enableaction = EnableAction()
                        enableaction.idField = self.idField
                        enableaction.actions = self
                        self.all_items_actions.append(enableaction)
                        disableaction = DisableAction()
                        disableaction.idField = self.idField
                        disableaction.actions = self
                        self.all_items_actions.append(disableaction)
            elif issubclass(action, Action):
                action = action()
                action.idField = self.idField
                action.actions = self
                if getattr(action, 'single_item_action', True):
                    self.actions.append(action)
                if getattr(action, 'multi_items_action', False):
                    self.multi_items_actions.append(action)
                if getattr(action, 'all_items_action', False):
                    self.all_items_actions.append(action)
            else:
                raise Exception("Invalid action: %s" % action)

    def _getter(self, row, data=list(), index=None, is_first_row=False, is_last_row=False, gridid="", controllername="", ajax=False):
        actions = []
        for action in self.actions:
            if (is_first_row and action.skipFirst) or (is_last_row and action.skipLast):
                out = '<img class="" width="16" height="16" src="%s" border="0" />' % self._imgClear
            else:
                if not controllername and hasattr(self.parent, "controllername"):
                    controllername = self.parent.controllername
                out = action.render(row, gridid=gridid, controllername=controllername, ajax=ajax, dropdown=self.dropdown)
            actions.append(out)

        if self.dropdown:
            actions.insert(0, '<option>%s</option>' % _("Choose an action"))
            res = '<select class="%s_singleaction" onChange="%sSingleAction(this);">%s</select>' % (
                gridid,
                gridid,
                "\n".join(actions)
            )
        else:
            res = "<span>%s</span>" % "\n".join(actions)
        return res

    def get_field(self, row, data=list(), displays_on=None, index=None, is_first_row=False, is_last_row=False, gridid="", controllername="", ajax=False):
        if isinstance(self.getter, Widget):
            row = row.get(self.getter.name)
            return self.getter(row, displays_on=displays_on)
        return self.getter(row, data, index, is_first_row, is_last_row, gridid=gridid, controllername=controllername, ajax=ajax)


class Actions(ActionsColumn):
    """@deprecated: Actions has been deprecated: use ActionsColumn instead."""

    def __init__(self, *args, **kargs):
        import warnings
        warnings.warn("Actions has been deprecated: use ActionsColumn instead.",
                      DeprecationWarning, 2)
        ActionsColumn.__init__(self, *args, **kargs)

__all__ = [
    'Column',
    'RuleColumn',
    'RelationColumn',
    'HiddenColumn',
    'CheckBoxColumn',
    'ActionsColumn',
    'Actions'
]
