#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#
import warnings
import copy

from tw.forms import TableForm, HiddenField
from tw.forms.core import DefaultValidator
from tw.api import CSSLink, Widget, WidgetType

from endian.data import DataSource
from endian.validators.core import NotEmpty
from endian.core import logger
from endian.core.classtools import classproperty
from endian.emi.fieldset import FieldsGroup
from endian.emi.widgets import FileField
from endian.emi.widgets.uploadfield import UpLoadField
from endian.emi.widgets.static import *
from endian.emi.widgets.container import Container

__all__ = [
    'SettingsEditor'
]

class SettingsEditorWidgetType(WidgetType):
    """
    EntitiesSettingsEditorWidgetType metaclass for EntitiesSettingsEditor
    WidgetType removes the 'children' attribute from the 'Widget' subclasses.
    This metaclass re-adds the 'children' to the EntitiesSettingsEditor subclasses.
    """
    def __new__(meta,name,bases,dct):

        entity = dct.get('entity', None)
        children = dct.get('children', None)
        new = WidgetType.__new__(meta,name,bases,dct)
        if isinstance(children, FieldsGroup):
            new.fields_group = children
        if entity:
            new.entity = entity
        if children:
            new.children = children
        elif entity:
            new.children = entity.fields()
        return new

class SettingsEditor(Container, TableForm):
    __metaclass__ = SettingsEditorWidgetType
    
    css_classes = [
        "settingseditor"
    ]
    css = [
        kendo_custom_css
    ] + Container.css
    javascript = [
        kendo_tooltip
    ] + Container.javascript
    template = ""
    engine_name = "mako"
    
    action = "store"
    controllername = ""
    
    container_id = None
    title = None
    columns = 2
    expands = False
    strip_name = True
    show_labels = True
    show_control = True
    within_box = False
    save_text = None
    submit_text = None
    
    entity = None
    children = []
    children_list = None
    chained_validators = None
    _schema = None
    _prepared_children = None
    
    fields_group = None
    
    params = ["container_id",
              "title",
              "expands",
              "show_labels",
              "show_control",
              "columns",
              "save_text",
              "chained_validators",
              "fields_group"]
    
    def __init__(self, id=None, parent=None, controllername="", **kw):
        self.controllername = controllername
        self.css.append(CSSLink(link='/toscawidgets/resources/endian.emi/static/css/settingseditor.css'))
        if self.within_box:
            self.css_classes.remove("settingseditor")
            self.css_classes.append("grideditor")
            self.css.append(CSSLink(link='/toscawidgets/resources/endian.emi/static/css/grideditor.css'))
        if self.fields_group:
            self.javascript.append(jquery_ui_accordion_endian)
            self.javascript.append(kendo_tabstrip)
            self.css.append(jquery_ui_accordion_endian_css)
        self.template = self.template or "endian.emi.templates.settingseditor"
        # Prepare the children
        self._prepared_children = self.prepare_children()
        self.children = self._prepared_children
        super(SettingsEditor, self).__init__(id=id, parent=parent, children=self.children, **kw)
        self.container_id = "%s_container" % self.id
        
        # make sure enctype is not multipart/form-data on the demo machine
        if DataSource("demo").settings.get("demo_enabled", "off") == 'on':
            if self.enctype == "multipart/form-data":
                self.enctype = "application/x-www-form-urlencoded"
        else:
            for child in self.children:
                if isinstance(child, FileField) or isinstance(child, UpLoadField):
                    self.enctype = "multipart/form-data"
        
    
    def adapt_value(self, value):
        value["ACTION"] = self.action
        value["CONTROLLERNAME"] = self.controllername
        return value
    
    def update_params(self, d):
        super(SettingsEditor, self).update_params(d)
        if not 'child_args' in d:
            d['child_args'] = {}
        
        for field in self.children:
            # If a field has a  'readonly_condition' method, call the method ad set the results in 'child_args', e.g.:
            if hasattr(field, "readonly_condition") and callable(field.readonly_condition):
                if not field._id in d['child_args']:
                    d['child_args'][field._id] = {}
                element = d['child_args'][field._id]
                if not 'attrs' in element:
                    element['attrs'] = {}
                # If the its readonly, set d['child_args']['attrs']['readonly'] to True, else remove the 'readonly' attribute if exists
                if field.readonly_condition(d):
                    element['attrs']['readonly'] = True
                elif 'readonly' in element['attrs']:
                    del element['attrs']['readonly']
            # If a field has a  'hidden_condition' method, call the method ad set the results in 'child_args'
            if hasattr(field, "hidden_condition") and callable(field.hidden_condition):
                if not field._id in d['child_args']:
                    d['child_args'][field._id] = {}
                element = d['child_args'][field._id]
                if not 'attrs' in element:
                    element['attrs'] = {}
                # If the its hidden, set d['child_args']['attrs']['hidden'] to True, else remove the 'hidden' attribute if exists
                if field.hidden_condition(d):
                    element['attrs']['hidden'] = True
                elif 'hidden' in element['attrs']:
                    del element['attrs']['hidden']
            if not field._id in d['child_args']:
                d['child_args'][field._id] = {}
            element = d['child_args'][field._id]
        
        # Filter the fields according to the evaluation of 'field.condition'
        d["fields"] = [field for field in self.children \
                       if not hasattr(field, "condition") or not callable(field.condition) or field.condition(d)]

    @classmethod
    def prepare_children(cls):
        """
        Prepare the children, optionally using the children_list
        """
        if cls._prepared_children == None:
            if cls.entity:
                if isinstance(cls.children_list, FieldsGroup):
                    cls.children = cls.children_list
                elif cls.children_list:
                    cls.children = cls.entity.fields(fields=cls.children_list or [])
                elif not cls.children:
                    cls.children = cls.entity.fields()
            # Add the ACTION and CONTROLLERNAME fields
            cls.children.append(HiddenField("ACTION"))
            cls.children.append(HiddenField("CONTROLLERNAME"))
            cls._prepared_children = cls.children
        return cls._prepared_children
    
    @classproperty
    def schema(cls):
        """
        Generate the schema according to the fields EntitiesSettingsEditor fields
        The custom 'chained_validators' are added to the schema 
        This property can be override in order to define a custom schema
        """
        if cls._schema:
            return cls._schema
        
        # Prepare the children
        cls.prepare_children()
        
        fields = []
        for child in cls.children:
            if not getattr('child', 'name', None):
                if not child.id:
                    logger.error("could not add child because name is None (%s)" % child.id)
                    continue
                name = child.id
            else:
                name = child.name
            
            #filter non used fields
            try:
                validator = child.validator
                default_validator = validator == None or \
                                    validator == DefaultValidator or \
                                    validator == NotEmpty
            except AttributeError:
                validator = None
                default_validator = True
            
            if validator == False:
                continue
            if default_validator:
                fields.append(name)
            else:
                fields.append((name, validator))
        
        if cls.chained_validators:
            fields.append(('chained_validators', cls.chained_validators))
        
        cls._schema = cls.entity.schemaClass(fields=fields, allow_extra_fields=True) # allow_extra_fields
        return cls._schema
