#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

# INFO: http://toscawidgets.org/trac/tw.forms/browser/tw/forms/samples.py
# DataGrid: http://toscawidgets.org/trac/tw.forms/browser/tw/forms/datagrid.py
# DataGrid Template: http://toscawidgets.org/trac/tw.forms/browser/tw/forms/templates/datagrid.html

import urllib
from math import ceil

from tw.forms.datagrid import DataGrid as BaseDataGrid

from endian.emi.cookies import getCookie, setCookie
from endian.emi.framework import url
from endian.core.logger import error
from endian.core.i18n import _
from endian.emi.widgets.static import (
    style_css,
    jquery_jqgrid_endian,
    jquery_emi_gridaction,
    jquery_jqgrid_endian_css,
    jquery_datatables_css,
    jquery_datatables
)
from endian.emi.widgets.gridcolumn import Column, ActionsColumn
from endian.emi.framework import request

__all__ = [
    'DataGrid',
    'RulesGrid'
]


class DataGrid(BaseDataGrid):
    template = "endian.emi.templates.datagrid"
    engine_name = "mako"
    css_class = "datagrid"

    css = [
        style_css
    ]
    javascript = [
        jquery_emi_gridaction
    ]

    type_ = "dataTables"  # jqGrid or dataTables

    ajax = True  # get data via an ajax request
    ajax_on_load_complete = None  # define name of js trigger method, returns data gets jqgrid object and data
    ajax_on_load_error = None  # define name of js trigger method, returns an errormessage and gets the jqgrid object
    ajax_on_subgrid_load_complete = None  # define name of js trigger method, returns data gets jqgrid object and data
    ajax_on_subgrid_load_error = None  # define name of js trigger method, returns an errormessage and gets the jqgrid object
    subgrid = False  # set to the property name of the entity or the key of the dict
    subgrid_columns = None  # use GridColumn list to define which columns to show
    subgrid_sortable = False  # is the grid sortable?
    subgrid_unsortable_cols = None  # this columns are not sortable -> see unsortable_cols
    subgrid_order_by = None  # sort usding this column per default

    entity = None
    fields = None  # Fields list
    controllername = ""

    search = False
    client_side_search = True
    clientSearch = None  # deprecated, use client_side_search instead

    filter_widget = None
    disable_storage_filter_query = False
    order_by = None

    paginate = True  # If true, enable pagination done by jquery datatable widget
    oldpaginate = False  # If true, enable pagination in template
    items = 25  # Items per page
    max_number_of_pages = 12  # Max number of pages in the page selector
    add_button_enabled_in_pagination = False  # Display the add button in the pagination template

    sortable = False  # if True, use the DataTables widget.
    unsortable_cols = None  # List of column ids which are not sortable. e.g. [0, -1]
    sort_by_cols = [[0, "desc"]]  # List of columns nr and order.  E.g.: [[0, "desc"]]
    sortByCols = None  # deprecated, use sort_by_cols instead

    refresh_period = 0  # if set and greater than zero, refresh the whole page every X ms.
    refreshPeriod = None  # deprecated, use refresh_period instead

    # If True, /naked, /naked_grid and /standalone
    # portion of the URL are removed from the form's action.
    action_on_main_controller = None
    actionOnMainController = None  # deprecated, use action_on_main_controller instead

    line_through_condition = None

    description = None
    new_label = _("Create new item")  # Label for new item creation. If None, hide the new item link

    no_entries_label = _("No entries to display")

    multi_items_actions = []  # Multi-row actions list

    legend_enabled = True
    legend_fields = []

    params = [
        "type_",
        "ajax",
        "ajax_on_load_complete",
        "ajax_on_load_error",
        "ajax_on_subgrid_load_complete",
        "ajax_on_subgrid_load_error",
        "subgrid",
        "subgrid_columns",
        "subgrid_sortable",
        "subgrid_unsortable_cols",
        "subgrid_order_by",
        "fields",
        "paginate",
        "oldpaginate",
        "items",
        "search",
        "client_side_search",
        "max_number_of_pages",
        "description",
        "sortable",
        "unsortable_cols",
        "sort_by_cols",
        "refresh_period",
        "action_on_main_controller",
        "multi_items_actions",
        "filter_widget",
        "controllername",
        "no_entries_label",
        "add_button_enabled_in_pagination",
        "legend_enabled",
        "legend_fields"
    ]

    def __init__(self, id=None, parent=None, children=[], controllername=None, **kw):
        if controllername:
            self.controllername = controllername
        if self.clientSearch is not None:
            import warnings
            warnings.warn("clientSearch has been deprecated: use client_side_search instead.",
                          DeprecationWarning, 2)
            self.client_side_search = True
        if self.sortByCols is not None:
            import warnings
            warnings.warn("sortByCols has been deprecated: use sort_by_cols instead.",
                          DeprecationWarning, 2)
            self.sort_by_cols = self.sortByCols
        if self.refreshPeriod is not None:
            import warnings
            warnings.warn("refreshPeriod has been deprecated: use refresh_period instead.",
                          DeprecationWarning, 2)
            self.refresh_period = self.refreshPeriod
        if self.actionOnMainController is not None:
            import warnings
            warnings.warn("actionOnMainController has been deprecated: use action_on_main_controller instead.",
                          DeprecationWarning, 2)
            self.action_on_main_controller = self.actionOnMainController
        if self.search:  # disable client search if server side search is enabled
            self.client_side_search = False
        if self.oldpaginate:  # disable jquery datatable pagination if pagination template is enabled
            self.paginate = False

        if self.type_ == "dataTables":
            self.ajax = False  # not supported with this grid type
            self.css.append(jquery_datatables_css)
            self.javascript.append(jquery_datatables)
        else:
            self.css_class = "jqgrid"
            if self.client_side_search:
                self.search = True
            self.css.append(jquery_jqgrid_endian_css)
            self.javascript.append(jquery_jqgrid_endian)

        # Adds the fields
        fields = []
        field_names = [x for x in dir(self) if not x.startswith("_")]
        for field_name in field_names:
            field = getattr(self, field_name)
            if not hasattr(field, "__class__") and issubclass(field, Column):
                field = field()
            # Adds the the grid all the multi-row actions
            if isinstance(field, ActionsColumn):
                self.multi_items_actions.extend(field.multi_items_actions)

                if not field.actions:
                    continue

                for action in field.actions:
                    self.legend_fields.extend(action._get_legend())

            if isinstance(field, Column):
                # Add the name if it is not set
                if not field.name:
                    field.name = field_name
                # Set the field entity
                field.entity = self.entity
                # Set the field label if it is not set
                if not field.title:
                    try:
                        field.title = self.entity.get_db_field(field_name).info.get('label', None) or field.name
                    except:
                        field.title = field.name
                fields.append(field)

        # Sort the fields
        if fields:
            fields.sort(lambda x, y: x.columnCount - y.columnCount)
            self.fields = fields
        BaseDataGrid.__init__(self, id=id, parent=parent, children=children, **kw)

    def update_params(self, d):
        """Update the template parameters."""
        BaseDataGrid.update_params(self, d)

        # create a reference to the parent grid
        for column in d["columns"]:
            column.parent = self

        d['datagrid'] = self

        # Filters
        filters = dict(filter(lambda (k, v): k.startswith('filter_'), request.params.items()))
        d.update(filters)
        d['filters'] = filters
        d['filters_args'] = urllib.urlencode(filters)

        new_search = self.update_search_params(d)
        self.update_pagination_params(d, new_search)

        if callable(self.add_button_enabled_in_pagination):
            d['add_button_enabled_in_pagination'] = self.add_button_enabled_in_pagination()
        else:
            d['add_button_enabled_in_pagination'] = self.add_button_enabled_in_pagination

    def update_search_params(self, d):
        """Update the template parameters filtering the data."""
        if not self.search:
            return False

        # Search by an entity ID, include only an enity with a given ID in the result
        if self.entity:
            if self.id:
                try:
                    search_id = request.params.get(self.id, {}).get("search_id")
                except:
                    search_id = request.params.get("search_id")
            else:
                search_id = request.params.get("search_id")
            if search_id:
                try:
                    search_id = int(search_id)
                except:
                    search_id = -1
                d["key_search"] = ""
                d["keyword"] = ""
                d["value"] = d["value"].filter_by(id=search_id)
                return True

        key_search = (self.id and "%s_search" % self.id or "search") + \
            request.path_info.replace('/', '_').rstrip('_')
        new_search = False
        if self.ajax:
            keyword = getCookie(key_search)
        else:
            try:
                keyword = request.params[key_search]
                new_search = True
            except:
                # check if we have a cookie
                keyword = getCookie(key_search)
                if keyword is None:
                    new_search = True
                    keyword = ""
            setCookie(key_search, keyword)

        d["key_search"] = key_search
        d["keyword"] = keyword
        d["value"] = self.filter_values(keyword, d)

        return new_search

    def filter_values(self, keyword, d):
        """Search implementation."""
        if not keyword:
            return d["value"]
        if hasattr(self.entity, 'filterQueryByKeyword'):
            keyword = keyword.strip()
            return self.entity.filterQueryByKeyword(d["value"], keyword)
        results = []
        lkey = keyword.lower()
        for item in d["value"]:
            for key in item.keys():
                try:
                    if unicode(item[key]).lower().find(lkey) > -1:
                        results.append(item)
                        break
                except Exception, e:
                    error("Rule %s: %s" % (item[key], e))
        return results

    def update_pagination_params(self, d, new_search):
        """Update the template parameters related to the pagination."""
        if not self.oldpaginate:
            return

        params = request.params
        path = request.path_info
        key_offset = self.id and "%s.offset" % self.id or "offset"

        # check if we have some params related to this grid
        try:
            count = len(d["value"])
        except TypeError:
            count = d["value"].count()
        items = self.items

        try:
            if self.id:
                offset = int(params[self.id]["offset"])
            else:
                offset = int(params["offset"])
        except:
            offset = getCookie(key_offset)

            if offset is None:
                offset = 0
            else:
                offset = int(offset)

        if new_search or count == 0 or offset > count:
            offset = 0

        setCookie(key_offset, offset)

        p = dict()
        prev_offset = offset - items
        if prev_offset >= 0:
            p[key_offset] = prev_offset
            d["url_prev"] = url(path, p)
        elif offset != 0:
            p[key_offset] = 0
            d["url_prev"] = url(path, p)
        else:
            d["url_prev"] = ""

        next_offset = offset + items
        if next_offset < count:
            p[key_offset] = next_offset
            d["url_next"] = url(path, p)
        else:
            d["url_next"] = ""

        offset_last = next_offset
        if offset_last > count:
            offset_last = count

        d["key_offset"] = key_offset

        d["url"] = path
        d["offset"] = offset
        d["offset_last"] = offset_last
        d["count"] = count
        d["value"] = d["value"][offset:offset + items]

        number_of_pages = int(ceil((count / float(items))))
        if self.max_number_of_pages != 0 and number_of_pages > self.max_number_of_pages:
            current_page = int(ceil(offset / items))
            range_start = current_page - self.max_number_of_pages / 2
            if range_start < 0:
                range_start = 0
            range_end = range_start + self.max_number_of_pages
            if range_end > number_of_pages:
                range_end = number_of_pages
                range_start = range_end - self.max_number_of_pages
            if range_start < 0:
                range_start = 0
            pages_range = range(range_start, range_end)
            if range_start != 0:
                pages_range[0] = 0
            if range_end != number_of_pages:
                pages_range[-1] = number_of_pages - 1
        else:
            pages_range = range(number_of_pages)
        d["pages_range"] = pages_range

    def custom_style(self, row):
        """Return the custom css style for a row."""
        return ""

    def custom_css_class(self, row):
        """Return the custom css class for a row."""
        return ""

    def is_line_through(self, row):
        """Return true if the line is disabled, according to the evaluation of the 'line_through_condition' condition."""
        if not self.line_through_condition:
            return False
        else:
            return eval('row.' + self.line_through_condition,
                        {'__builtins__': {'True': True, 'False': False, 'None': None}},
                        {'row': row})


class RulesGrid(DataGrid):
    """@deprecated: RulesEditor has been deprecated: use DataGrid instead."""

    def __init__(self, *args, **kargs):
        import warnings
        warnings.warn("RulesGrid has been deprecated: use DataGrid instead.",
                      DeprecationWarning, 2)
        DataGrid.__init__(self, *args, **kargs)
