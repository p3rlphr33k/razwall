#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from tw.core import meta
from endian.core.magicset import MagicSet
import inspect

class FieldsGroup(object):
    """
        This class is a group of widgets (fields) to be rendered inside a div.
        The groups can be neasted.
        
        Usage Example:
        
        class MySettings(SettingsEditor):
                                    
            children = FieldsGroup(css_class="box_grey", fields=[
                FieldsGroup(css_class="box_left", fields=[ .. ]),
                FieldsGroup(css_class="box_center", fields=[ .. ]),
                FieldsGroup(css_class="box3_gray", fields=[ .. ]),
            ])
        
    """    
    
    fields = None
    id = None
    css_classes = None
    css_style = None
    columns = 2
    expands = True
    field_column = 0
    linebreak = []
    title = None
    info_text = None
    separator = False
    accordion = False
    accordion_collapses = False
    accordion_single_view = False
    tabs = False
    #: use this in combination with tabs to have the form inside the tab
    form = False
    #: use this to have a custom save text for the tab form
    save_text = None
    toggle_name = None
    toggle_option = "on"
    toggle_function = None

    def __init__(self,
            fields=None,
            id=None,
            css_class=None,
            css_classes=None,
            css_style=None,
            columns=2,
            expands=True,
            title=None,
            info_text=None,
            separator=False,
            accordion=False,
            accordion_collapses=False,
            accordion_single_view=False,
            tabs=False,
            form=False,
            save_text=None,
            toggle_name=None,
            toggle_option="on",
            toggle_function=None):
        """
        .. autofunction:: __init__
            :param fields: the list of widgets (fields) 
            :type fields: list
            :param id: the div id - can be None
            :type id: string
            :param css_class: the css class - can be None
            :type css_class: string
            :param css_classes: the list of css classes - can be empty or None
            :type css_classes: list of strings
            :param columns: the number of columns 
            :type columns: int 
            :param css_class: the group title - can be None
            :type css_class: string
            :param accordion_collapses: Set to true hide all the accordion elements at startup
            :type accordion_collapses: boolean
            :param accordion_single_view: Set to true the accordion shows only one element at a time
            :type accordion_collapses: boolean
            :param toggle_name: name of the entity field which is responsible for toggling this field
            :type toggle_name: string
            :param toggle_option: when to toggle the field (e.g. "on", "off" with checkboxes or the option name(s) of a selectbox)
            :type toggle_option: string or list of strings
            :param toggle_function: js functio used as toggle callback. defaults to fieldTogglerChange or fieldTogglerClick
            :type toggle_function: string
        """
        self.fields = fields or []
        self.id = id
        self.css_classes = ["container"]
        if css_class:
            self.css_classes.append(css_class)
        if css_classes:
            self.css_classes.append(css_classes)
        self.css_style = css_style
        if columns:
            self.columns = columns
        self.expands = expands
        self.title = title
        self.info_text = info_text
        self.separator = separator
        self.accordion = accordion
        self.accordion_collapses = accordion_collapses
        self.accordion_single_view = accordion_single_view
        self.tabs = tabs
        self.form = form
        self.save_text = save_text
        self.toggle_name = toggle_name
        self.toggle_option = toggle_option
        self.toggle_function = toggle_function
        
        self.field_column = 0 # why is this reused on all child field groups?????
        self.linebreak = [] # why is this reused on all child field groups?????
        fieldcount = len(self.fields)
        for field in self.fields:
            self.field_column += 1
            fieldcount += 1
            if getattr(field, "expands", False):
                self.linebreak.append(True)
                self.field_column = 0
            elif self.field_column >= self.columns:
                self.linebreak.append(True)
                self.field_column = 0
            else:
                self.linebreak.append(False)
    
    def __iter__(self):
        """ Recursively iterate over the fields """
        result = []
        for element in self.fields:
            if hasattr(element, 'fields'):
                result.extend(element)
            else:
                result.append(element)
        return result.__iter__()
    
    def append(self, item):
        """ Append an item to the fieldsgroup """
        self.fields.append(item)
        fieldcount = len(self.fields)
        if getattr(item, "expands", False):
            self.linebreak.append(True)
            self.field_column = 0
        elif self.field_column >= self.columns:
            self.linebreak.append(True)
            self.field_column = 0
        else:
            self.linebreak.append(False)
    
    def getToggleList(self):
        toggle_list = []
        if self.toggle_name and self.toggle_option:
            toggle_list.append((self.toggle_name, self.toggle_option, self.toggle_function))
        for field in self.fields:
            if isinstance(field, FieldsGroup):
                toggle_list.extend(field.getToggleList())
        return toggle_list

class EmiWidgetsListType(meta.WidgetsListType):
    
    def __new__(meta, name, bases, dct):
        if hasattr(dct, 'copy'):
            dct = dct.copy()
        clones = []
        for id, w in dct.items():
            if hasattr(w,'_serial') and hasattr(w, 'clone'):
                dct.pop(id)
                clones.append((w._serial, id, w.clone) )
            elif isinstance(w, FieldsGroup): # is a fieldsgroup
                dct.pop(id)
                clones.append((-1, id, w))
        def __init__(self, clones=clones): 
            # we instantiate the clones on initialization
            widgets = []
            for w in clones:
                if hasattr(w[2], "__call__"):
                    widgets.append(w[2](id=w[1]))
                else: # is a fields group which is already initialized
                    widgets.append(w[2])
            self.extend(widgets)
        dct.update({'__slots__':[], '__init__':__init__})
        return type.__new__(meta,name,bases,dct)


class FieldSet(MagicSet):
    """
    The FieldSet acts like a list and dict at the same time.
    
    Each Field/Widget can be accessed using the field name/id as key.
    """
    _identifier = "name"

    __metaclass__ = EmiWidgetsListType


__all__ = ['FieldSet', 'FieldsGroup']


if __name__ == "__main__":    
    from tw.forms import TextField, HiddenField
    
    class MyList(FieldSet):
        name = TextField()
    
    ml = MyList()
    print "ml[0]:", ml[0]
    print "ml['name']:", ml["name"]
    print "ml.get('name'):", ml.get("name")
    print "ml.keys():", ml.keys()
    ml.append(HiddenField("ACTION"))
    ml.append(HiddenField("b"))
    ml.append(HiddenField("a"))
    print "ml.keys():", ml.keys()

    print '-' * 80
    MyList.pino = HiddenField("pino")
    ml2 = MyList()

    print "ml2.keys():", ml2.keys()
    for x in ml2:
        print x
