#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import os
import sys
import inspect
import cherrypy
import simplejson
import time
from cgi import parse_qs
from endian.emi.tg.controllers import TgController, expose, redirect, flash, _process_output, config

from endian.core.i18n import _
from endian.core.modules import module_registry
from endian.core import logger
from endian.emi.acl import NotLoggedInError, NotAuthorizedError
from endian.emi.framework import request, serve_file
from endian.emi.menu import Menu

__all__ = [
    'Controller',
    'BaseController',
    'expose',
    'redirect',
    'flash',
    'json',
    'jsonp',
    'registerController',
    'ERROR_TEMPLATES',
    'REQUEST_TYPE'
]

HTTP_ERROR_MESSAGES = {
    400: _("Bad Request"),
    401: _("Unauthorized"),
    402: _("Payment Required"),
    403: _("You are not allowed to perform this action"),
    404: _("Not Found"),
    405: _("Method Not Allowed"),
    406: _("Not Acceptable"),
    408: _("Request Timeout"),
    500: _("The management interface encountered an error. Please contact an administrator."), # _("Internal Server Error"),
    501: _("Not Implemented"),
    502: _("Bad Gateway"),
    503: _("Service Unavailable"),
}

# Default error templates
# The keys are an HTTP status codes or an exception types

ERROR_TEMPLATES = {
    "default":      "endian.emi.templates.error500",
    401:            "endian.emi.templates.error401",
    403:            "endian.emi.templates.error403",
    404:            "endian.emi.templates.error404",
    500:            "endian.emi.templates.error500"
}

# Template request types for controllers

class REQUEST_TYPE:
    MASTER = "MASTER"
    NAKED = "NAKED"
    STANDALONE = "STANDALONE"
    PLUGIN = "PLUGIN"
    JSON = "JSON"

def json(fct):
    """
    """
    @expose(content_type="application/json") # The MIME type for JSON is application/json (RFC 4627)
    def json_fct(*args1, **args2):
        #attention json needs ascii codes, does not escape
        ret = fct(*args1, **args2)
        if not isinstance(ret, dict):
            raise TypeError(
                "Function must return a dict to create a json response!")
        return ret

    return json_fct

def jsonp(fct):
    """
    Decorator to create a jquery compatible jsonp
    compatible response.
    The function fct must return a dict!

    The response looks like this:
    'callback(%json_of_returned_dict)'

    :param fct: A function which returns a dict.
    :type fct: dict returning callable
    """
    @expose(content_type="text/plain") # json
    def json_fct(*args1, **args2):
        #attention json needs ascii codes, does not escape
        ret = fct(*args1, **args2)
        if not isinstance(ret, dict):
            raise TypeError(
                "Function must return a dict to create a json response!")
        return ret

    @expose(content_type="application/javascript")
    def jsonp_fct(*args1, **args2):
        return "%s(%s)" % (args2.get("callback", "test_function"),
                           json_fct(*args1, **args2))

    return jsonp_fct

class Controller(TgController):

    path = None # Controller path (e.g. /manage/debug), setted by registerController
    error_templates = {} # Custom error templats - the keys are an HTTP status codes or an exception types
    error_handlers = {}

    @classmethod
    def register_error_handler(cls, path, handler):
        """
        Register a custom error handler for a specific path.
        The handler is a function this the following argument:
        * path - requested path (e.g. /manage/hotspotgui/index)
        * status - error status (e.g. 404)
        """
        cls.error_handlers[path] = handler
        logger.info("Error handler for '%s' registered", path)

    @classmethod
    def get_error_handler(cls, path):
        """
            Return the error handler for a given path
            
            :param path: the requested path (e.g /manage/hotspotgui/index)
            :type path: string
            :return: Return the longest matching error handler or None
            :rtype: function or NoneType
        """
        handler = None
        handler_path = ""
        for k, v in cls.error_handlers.iteritems():
            if path.startswith(k) and len(k) > len(handler_path):
                handler = v
                handler_path = k
        return handler

    @classmethod
    def send_error_page(cls, request_path, status):
        """
            Display the error page for the given HTTP status - this is the default error handler
            
            :param path: the requested path (e.g /manage/hotspotgui/index)
            :type path: string
            :param status: HTTP status code (e.g. 404)
            :type status: int
        """
        data = {}
        data["hidecontentbox"] = (status == 404)
        data["status"] = status
        # Get the type of the exception that is currently being handled
        # NOTE: exception_type is the type of the exception, not the exception instance
        try:
            exception_type = sys.exc_info()[0]
        except:
            exception_type = None
        if issubclass(exception_type, NotAuthorizedError):
            status = 403
        # Message
        data["message"] = HTTP_ERROR_MESSAGES.get(status, None)
        if not data["message"]:
            data["message"] = _("Internal Server Error")
        # The template is chosen according to the last exception or the HTTP status code
        template = cls.error_templates.get(exception_type, None) or \
            ERROR_TEMPLATES.get(exception_type, None) or \
            cls.error_templates.get(status, None) or \
            ERROR_TEMPLATES.get(status, None) or \
            cls.error_templates.get("default", None) or \
            ERROR_TEMPLATES.get("default", None)
        # Details
        data["details"] = ""
        if (config.get('emi.show_traceback', False)) and status not in (401, 403, 404):
            import traceback
            data["details"] = traceback.format_exc()

        # Render
        if cherrypy.request.headers["Content-Type"].lower() == "application/json" or \
                'application/json' in (cherrypy.request.headers.get('Accept') or ''):
            cherrypy.response.headers["Content-Type"] = "application/json"
            data['error'] = data["message"]
            data['time'] = time.time()
            del data['message']
            del data['hidecontentbox']
            body = simplejson.dumps(data)
        else:
            body = _process_output(data, template, "html", "text/html", None)
        cherrypy.response.headers["Content-Length"] = len(body)
        cherrypy.response.body = body

    def _cp_on_http_error(self, status, message):
        logger.debug("Oops! got a traceback", exc_info=True)
        cherrypy._cputil._cp_on_http_error(status, message)
        request_path = cherrypy.request.path
        handler = self.get_error_handler(request_path)
        logger.info("_cp_on_http_error status: %s message: %s request_path: %s handler: %s", status, message, request_path, handler)
        if handler != None:
            exit_code = handler(request_path, status)
        else:
            exit_code = None
        if not exit_code:
            self.send_error_page(request_path, status)

    def __getattr__(self, name, try_to_import=True):
        """
            Try to load a subcontroller
        """
        if try_to_import and \
                not name.startswith('_') and \
                name not in ['acl', 'menu_title', 'menu_order', 'title', 'is_app_root', 'path'] and \
                not getattr(self, 'is_app_root', False) and \
                getattr(self, 'path', None) != None:
            if module_registry.web.lookup_and_init(self.path + '/' + name):
                return self.__getattr__(name, False)
        raise AttributeError(name)


class BaseController(Controller):
    '''
    BaseController class - provides generic methods
    '''

    containerWidget = None

    hidecontentbox = None

    entity = None
    acl = None

    actions = [] # possible actions (custom actions do not to be listed her, but their function name must begin with _ e.g. _apply)
    permissions = [] # permissions which needs to be checked

    name = ""
    title = None
    menu_title = None

    def __init__(self, containerWidget=None, entity=None, acl=None, hidecontentbox=False, name="", **params):
        if not containerWidget and self.containerWidget:
            containerWidget = self.containerWidget
        if not self.entity:
            self.entity = entity
        if not self.acl:
            self.acl = acl
        if not self.hidecontentbox:
            self.hidecontentbox = hidecontentbox
        if name != "":
            self.name = name
        if containerWidget:
            if inspect.isclass(containerWidget):
                self.containerWidget = containerWidget(id=self.name and self.name or "base")
            else:
                self.containerWidget = containerWidget
            if not getattr(self,'title',None) and getattr(self.containerWidget, 'title', None):
                self.title = self.containerWidget.title
            if not getattr(self,'menu_title',None) and getattr(self.containerWidget, 'menu_title', None):
                self.menu_title = self.containerWidget.menu_title
            if not getattr(self,'menu_order',None) and getattr(self.containerWidget, 'menu_order', None):
                self.menu_order = self.containerWidget.menu_order
        else:
            self.containerWidget = None

    @expose(template="endian.emi.templates.basecontroller_master")
    def index(self, **args):
        return self.index_internal(**args)

    @expose("json", content_type="application/json")
    def json(self, **args):
        # hack to get post data from cherrypy....
        # cherrypy will not add post data to **args, it requires it to be a param...
        if request.method == "POST":
            try:
                post_data = parse_qs(request.body.read())
            except:
                post_data = {}
            args.update(post_data)

        # delete timestamp used to prevent caching
        if args.has_key("_"):
            del args["_"]
        if args.has_key("_nodata"):
            nodata = args["_nodata"] and True or False
            del args["_nodata"]
        else:
            nodata = False
        return self.index_internal(request_type=REQUEST_TYPE.JSON,
                                   data_options={"nodata": nodata},
                                   **args)

    @expose(template="endian.emi.templates.basecontroller")
    def naked(self, **args):
        return self.index_internal(request_type=REQUEST_TYPE.NAKED, **args)

    @expose(template="endian.emi.templates.basecontroller_standalone")
    def standalone(self, **args):
        return self.index_internal(request_type=REQUEST_TYPE.STANDALONE, **args)

    @expose(template="endian.emi.templates.basecontroller_plugin")
    def plugin(self, **args):
        return self.index_internal(request_type=REQUEST_TYPE.PLUGIN, **args)

    def index_internal(self, request_type=REQUEST_TYPE.MASTER,
                             data_options={},
                             **args):
        try:
            # Store the request type in the request object, so it can be accessed by the error page
            request.request_type = request_type

            # First, if the controller has an ACL, check the permissions
            if self.acl:
                hasAccess = self.acl_has_access()
                self.acl.check_permission('view', hasAccess=hasAccess)

            # Process actions
            args = self.process(**args)

            if not args:
                args = dict()

            data = self.getData(args, data_options=data_options)
            # If the entitiy has an ACL, compute the permissions
            # (i.e. determinate if the user can see the 'create', 'delete', and 'edit' buttons)
            if self.entity and self.entity.acl:
                permissions = set()
                for permission in self.permissions:
                    if self.entity.acl.has_permission(permission, hasAccess=True):
                        permissions.add(permission)

            else:
                permissions = set(self.permissions) # No ACL, full permissions

        except NotLoggedInError:
            if Menu.login_href and not request_type == REQUEST_TYPE.JSON:
                redirect(Menu.login_href)
            else:
                args = {'error' : _("You must login to view this page")}
                data = None
                permissions = set()

        controllername = args.get("CONTROLLERNAME", "")
        error = args.get("error", "")
        success = error and False or True
        important = args.get("important", "")
        info = args.get("info", "")

        ret = dict(success=success,
                   error=error,
                   important=important,
                   info=info,
                   args=args,
                   data=data,
                   controllername=controllername,
                   request_type=request_type,
                   permissions=permissions)

        if request_type == REQUEST_TYPE.JSON:
            return ret

        ret.update(dict(container=self.containerWidget,
                        hidecontentbox=self.hidecontentbox))
        return ret

    def getData(self, args,
                      data_options={}):
        return None

    def process(self, **args):
        logger.debug("Processing ARGS:%s %s", '', args) # debug dict workarround (first arg of debug must be not a dict)
        # check if we got an empty key in args and delete it
        if args.has_key(""):
            del(args[""])

        action = args.get("ACTION", "")
        controllername = args.get("CONTROLLERNAME", "")
        if controllername != self.name:
            action = ""

        triggered = False
        triggered_args = {}
        triggered_args['ACTION'] = action
        triggered_args['CONTROLLERNAME'] = controllername

        # Copy the filter arguments
        for k, v in args.iteritems():
            if k.startswith('filter_'):
                triggered_args[k] = v

        if action == "":
            return triggered_args

        if action in self.actions and hasattr(self, action):
            # trigger the action
            logger.debug("Triggering action %s->%s: %s", self, action, args)
            triggered_args = getattr(self, action)(**args)
            triggered = True
        if hasattr(self, "_%s" % action):
            # trigger the _action
            logger.debug("Triggering action %s->_%s: %s", self, action, args)
            processed_args = getattr(self, '_%s'%action)(**args)
            if hasattr(processed_args, "keys"):
                triggered_args.update(processed_args)
            triggered = True
        if not triggered:
            logger.error("Could not trigger unknown action '%s' of class '%s'" % (action, self.__class__.__name__))
        if not hasattr(triggered_args, 'keys'):
            triggered_args = {}
        return triggered_args

    def error(self, data, invalid):
        logger.error("%s" % invalid)
        return {}

    def acl_has_access(self, current_identity=None):
        """
           Returns 'True' if the current user has access to this controller
        """
        return True

def registerController(root, method, controller):
    """
    Register a controller defined by a module
    """
    logger.debug("Registering controller %s under '%s'", controller, method)

    # export static folder
    staticdir = os.path.join(os.path.dirname(inspect.getfile(controller.__class__)), "static")
    logger.debug("Registering static dir /%s/static", method)
    controller.static = lambda filename: serve_file(os.path.join(staticdir, filename))
    controller.static.exposed = True

    # assign controller
    setattr(root, method, controller)

    # set the controller path
    root_path = getattr(root, 'path', None)
    if root_path:
        controller.path = "%s/%s" % (root_path, method)
    return True
