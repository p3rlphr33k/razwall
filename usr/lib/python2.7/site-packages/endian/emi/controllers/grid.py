#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import copy
import math
import urllib
from cgi import parse_qs

import endian.core.i18n
from endian.core import logger
from endian.core.enumerate_plus import enumerate_plus
from endian.validators.core import Invalid
from endian.emi.framework import request
from endian.emi.controllers.base import BaseController, REQUEST_TYPE, expose
from endian.emi.widgets import KendoGrid, DataGrid, CheckBoxColumn, ActionsColumn
from endian.emi.widgets.kendodata import get_kendo_data

__all__ = [
    'GridController',
]

DEFAULT_PAGE_SIZE = 20

class GridController(BaseController):
    """
    Generic rules controller
    """
    
    show_label = _("Show settings")
    hide_label = _("Hide settings")
    
    hideable = None
    add_button_enabled = None
    edit_always = None
    editOnly = None
    gridOnly = None
    
    editorWidget = None
    gridWidget = None
    
    storage_filter = None
    
    do_validate = None # prevent validation e.g. if only chained validators should be used
    do_store = None # prevent store with readonly storages
    do_delete = None # prevent delete with readonly storages
    
    actions = [
        "edit",
        "store",
        "multiStore",
        "enable",
        "disable",
        "active",
        "delete",
        "moveUp",
        "moveDown",
    ]
    permissions = [
        "edit",
        "create",
        "delete",
        "store",
        "enable",
    ]
    def __init__(self,
            schema=None,
            editorWidget=None,
            gridWidget=None,
            storage=None,
            editOnly=False,
            gridOnly=False,
            hideable=False,
            add_button_enabled=True,
            edit_always=False,
            storage_filter=None,
            do_validate=True,
            do_store=True,
            do_delete=True,
            **params):
        """
        :param schema: defines the validators
        :type schema: endian.validators.core.Schema
        :param editorWidget: defines the form to edit/create items
        :type editorWidget: endian.emi.widgets.GridEditor
        :param gridWidget: defines the grid showing the items
        :type gridWidget: endian.emi.widgets.KendoGrid|DataGrid
        :param storage: defines the storage to handle items
        :type storage: endian.emi.storage.Storage
        :param editOnly: show only the editor widget (default: False)
        :type editOnly: bool
        :param gridOnly: show only the grid widget (default: False)
        :type gridOnly: bool
        :param hideable: defines if editor widget is hideable
        :type hideable: bool
        :param edit_always: defines if editor widget is always shown, overwrites hideable (default: False)
        :type edit_always: bool
        :param storage_filter: a function to do additional filtering on the data returned by the storage
        :type stoarge_filter: function
        :param do_validate: prevent validation e.g. if only chained validators should be used
        :type do_validate: bool
        :param do_store: prevent storage with readonly storages
        :type do_store: bool
        :param do_delete: prevent delete with readonly storages
        :type do_delete: bool
        """
        BaseController.__init__(self, **params)
        if not editorWidget and self.editorWidget:
            editorWidget = self.editorWidget
        if not gridWidget and self.gridWidget:
            gridWidget = self.gridWidget
        if editorWidget:
            self.entity = editorWidget.entity
            if not schema:
                schema = editorWidget.schema
        if gridWidget and not self.entity:
            self.entity = gridWidget.entity
        # Storage
        if not storage and self.entity:
            storage = self.entity.storage()
        # Schema
        if not schema:
            schema = getattr(editorWidget, 'schema', None)
        if not schema:
            schema = getattr(storage, 'schema', None)
        
        self.schema = schema
        if editorWidget:
            self.editorWidget = editorWidget(id=self.name and "%s_ruleseditor" % self.name or "ruleseditor", validator=schema, controllername=self.name)
        else:
            self.editorWidget = None
        if gridWidget:
            args = {}
            if hasattr(self, "gridWidget_args"):
                args = self.gridWidget_args
            self.gridWidget = gridWidget(id=self.name and "%s_datagrid" % self.name or "datagrid", controllername=self.name, **args)
            if not getattr(self,'title',None) and getattr(self.gridWidget, 'title', None):
                self.title = self.gridWidget.title
            if not getattr(self,'menu_title',None) and getattr(self.gridWidget, 'menu_title', None):
                self.menu_title = self.gridWidget.menu_title
            if not getattr(self,'menu_order',None) and getattr(self.gridWidget, 'menu_order', None):
                self.menu_order = self.gridWidget.menu_order
        else:
            self.gridWidget = None
        self.storage = storage
        if self.editOnly is None:
            self.editOnly = editOnly
        if self.gridOnly is None:
            self.gridOnly = gridOnly
        if self.hideable is None:
            self.hideable = hideable
        if self.add_button_enabled is None:
            self.add_button_enabled = add_button_enabled
        if self.edit_always is None:
            self.edit_always = edit_always
        if self.edit_always:
            self.hideable = False
        if not self.storage_filter:
            self.storage_filter = storage_filter
        if self.do_validate is None:
            self.do_validate = do_validate
        if self.do_store is None:
            self.do_store = do_store
        if self.do_delete is None:
            self.do_delete = do_delete
    
    @expose(template="endian.emi.templates.gridcontroller_master")
    def index(self, **args):
        """show the grid using master.mak as master template"""
        return self.index_internal(**args)
    
    @expose("json", content_type="application/json")
    def json_grid(self,
            subgridid="",
            rows=None, # jqGrid
            pageSize=None, # KendoGrid
            page=1,
            totalrows=DEFAULT_PAGE_SIZE,
            order_by=None,
            order_sort=None,
            search_field=None,
            search_string=None,
            raw=False,
            **args):
        """
        This function reads a filtered list of elements from a storage and returns
        them paginated as a list of raw or formated columns.
        
        Sequence:
            --> get_kendo_data
            --> self.getData
            --> self.paginate
            --> self.prepare_json_data
        
        :param subgridid: the id of the subgrid requesting the data
        :type subgridid: str
        :param rows: maximum number of elements per page (used only by the jqGrid widget)
        :type rows: int
        :param pageSize: maximum number of elements per page (used only by the KendoGrid widget)
        :type pageSize: int
        :param page: current page number
        :type page: int
        :param totalrows: maximum number of elements per page
        :type totalrows: int
        :param order_by: sort elements by this column
        :type order_by: str
        :param order_sort: sort elements ascending or descending (asc or desc)
        :type order_sort: str
        :param search_field: search this column for the search_string (default all fields)
        :type search_field: str
        :param search_string: filter elements with this string
        :type search_string: str
        :param raw: return elements raw (field) or formated (JSON ready)
        :type raw: bool
        :param **args: other arguments as dictionary
        :type **args: dict

        :return: a dictionary containing the page number, total page number, records and the rows as data
        :rtype: dict
        """
        
        # Store the request type in the request object, so it can be accessed by the error page
        request.request_type = REQUEST_TYPE.JSON
        
        # hack to get post data from cherrypy....
        # cherrypy will not add post data to **args, it requires it to be a param...
        if request.method == "POST":
            try:
                post_data = parse_qs(request.body.read())
            except:
                post_data = {}
            if post_data.has_key("subgridid"):
                subgridid = post_data.get("subgridid", [subgridid])[0]
                del post_data["subgridid"]
            if post_data.has_key("rows"):
                rows = post_data.get("rows", [rows])[0]
                del post_data["rows"]
            if post_data.has_key("page"):
                page = post_data.get("page", [page])[0]
                del post_data["page"]
            if post_data.has_key("pageSize"):
                pageSize = post_data.get("pageSize", [pageSize])[0]
                del post_data["pageSize"]
            if post_data.has_key("totalrows"):
                totalrows = post_data.get("totalrows", [totalrows])[0]
                del post_data["totalrows"]
            if post_data.has_key("order_by"):
                order_by = post_data.get("order_by", [order_by])[0]
                del post_data["order_by"]
            if post_data.has_key("order_sort"):
                order_sort = post_data.get("order_sort", [order_sort])[0]
                del post_data["order_sort"]
            if post_data.has_key("search_field"):
                search_field = post_data.get("search_field", [search_field])[0]
                del post_data["search_field"]
            if post_data.has_key("search_string"):
                search_string = post_data.get("search_string", [search_string])[0]
                del post_data["search_string"]
            if post_data.has_key("raw"):
                raw = post_data.get("raw", [raw])[0]
                del post_data["raw"]
                try:
                    raw = bool(raw)
                except:
                    raw = False
            args.update(post_data)
        
        # First, if the controller has an ACL, check the permissions
        if self.acl:
            hasAccess = self.acl_has_access()
            self.acl.check_permission('view', hasAccess=hasAccess)
        
        sort, filters = get_kendo_data(args)
        if sort:
            """
            Currently we only support sorting by one column.
                If the column uses kendo_column_template with multiple fields
                (e.g. Column.field = 'name,description'), it will order by all fields
                with the same direction in order given.
                If the storage does not support it only the first field will be used.
            """
            order_by = sort.get("0", {}).get("field", "")
            order_by = order_by and str(order_by) or None
            if order_by:
                # make sure we fix the order by if a column uses a kendo_template and
                # has fields set with a list of entity columns
                if subgridid:
                    gridWidget = self.gridWidget.subgrid
                else:
                    gridWidget = self.gridWidget
                
                for column in gridWidget.columns:
                    if column.name != order_by:
                        # if the order by does not match the column name, continue
                        continue
                    if column.name != column.order_by:
                        # if column needs a custom order_by replace it
                        order_by = column.order_by
                        break
                
                if isinstance(order_by, basestring):
                    # do we use a list to order by?
                    order_by = order_by.split(",")
                
                if not self.storage or not self.storage.multi_order_by:
                    # make sure it will work with storages not supporting ordering by multiple fields
                    order_by = order_by[0]
            
            order_sort = sort.get("0", {}).get("dir", "asc")
        
        if not filters:
            filters = {}
        else:
            """
            if columns use custom column.search_keys or column.fields
                replace the search key in the kendo filter.
            if it is a list explode it with OR logic.
            """
            
            if subgridid:
                gridWidget = self.gridWidget.subgrid
            else:
                gridWidget = self.gridWidget
            
            #: create a dict with key value pairs of columns which have a custom search_key
            explode_search_keys = {}
            for column in gridWidget.columns:
                if column.name == column.search_keys:
                    continue
                if isinstance(column.search_keys, basestring):
                    # do we use a list to order by?
                    search_keys = column.search_keys.split(",")
                else:
                    search_keys = column.search_keys
                explode_search_keys[column.name] = search_keys
            
            def explode_kendo_filter(filters, logic='or'):
                new_filters = {
                    'filters': {},
                    'logic': logic
                }
                for key, item in filters.iteritems():
                    if key == "filters": # this is a filter list
                        sub_filters = item
                        sub_logic = filters.get("logic", logic)
                        return explode_kendo_filter(filters=sub_filters, logic=sub_logic)
                    elif key == "logic": # this is a filter list
                        sub_filters = filters.get("filters", {})
                        sub_logic = item
                        return explode_kendo_filter(filters=sub_filters, logic=sub_logic)
                    elif item.get('filters'): # this contains a filter list
                        sub_filters = item.get('filters', {})
                        sub_logic = item.get('logic', logic)
                        item = explode_kendo_filter(filters=sub_filters, logic=sub_logic)
                        new_filters['filters'][key] = item
                        continue
                    elif item.get('field'):
                        field = item.get("field")
                        operator = item.get("operator")
                        value = item.get("value")
                        if field in explode_search_keys.keys():
                            search_keys = explode_search_keys.get(field)
                            item = {
                                'filters': {},
                                'logic': 'or'
                            }
                            for i, sub_field in enumerate(search_keys):
                                item['filters'][str(i)] = {
                                    'field': sub_field,
                                    'operator': operator,
                                    'value': value
                                }
                            if len(search_keys) == 1:
                                item = item['filters']['0']
                        new_filters['filters'][key] = item
                        continue
                #if len(new_filters['filters'].keys()) == 1:
                #    return new_filters['filters'].values()[0]
                return new_filters
            
            filters = explode_kendo_filter(filters)
        
        if subgridid: # at this point it is eighter str or None
            try: # convert int ids into int
                subgridid = int(subgridid)
            except:
                logger.debug("subgridid '%s' is not int" % subgridid)
            
            data = self.loadDataByID(subgridid)
            
            if not data:
                return dict(page=1,
                            total=1,
                            records=0,
                            data=[])
            
            # use this to filter / order the subgrid
            data_options = {
                "order_by": order_by,
                "order_sort": order_sort
            }
            # defaults to search in any field
            search_field = search_field or "search_string"
            # if search_field and search_string:
            #    subgrid_data_options[search_field] = search_string
            
            # check if the returned data has a property or callable method to get 
            # the needed data
            if hasattr(self.gridWidget.subgrid, '__call__'):
                data = self.gridWidget.subgrid(data, **data_options)
            elif hasattr(data, self.gridWidget.subgrid):
                data = getattr(data, self.gridWidget.subgrid)
                # if it is callable pass the sort and search options
                if hasattr(data, '__call__'): # if not it was a property
                    data = data(**data_options)
            else:
                data = data.get(self.gridWidget.subgrid, [])
            
            if not data:
                data = []
            
            data = self.onSubgrid(data)
        else:
            # defaults to search in any field
            search_field = search_field or "search_string"
            data_options = {
                "nodata": False,
                "order_by": order_by,
                "order_sort": order_sort,
                "search_name": search_field,
                "search_string": search_string,
                "filters": filters
            }
            data = self.getData(args, data_options=data_options) or []
        
        # convert entity objects into dicts
        if hasattr(data, "__json__"):
            data = data.__json__()
        
        # paginate
        if isinstance(self.gridWidget, KendoGrid) and not self.gridWidget.server_paging:
            rows = pageSize = totalrows = -1
        page, total, records, data = self.paginate(page, rows or pageSize or totalrows, data)

        # prepare the output
        data = self.prepare_json_data(page, total, records, data, subgridid, raw)

        # return
        if rows == -1:
            return dict(
                records=records,
                data=data
            )
        else: 
            return dict(
                page=page,
                total=total,
                records=records,
                data=data
            )
    
    def paginate(self, page, page_size, data):
        """
        This function paginates a list of elements.
        
        :param page: current page
        :type page: int
        :param page_size: maximum number of elements per page
        :type page_size: int
        :param data: list of elements for pagination
        :type data: ~array.array
        
        :return: list of elements for the requested page
        :rtype: ~array.array
        """
        # page number 
        if page:
            page = int(page)
        else:
            page = 1
        # count of rows
        if isinstance(data, list):
            records = data and len(data) or 0
        else:
            records = data.count()
        # page size
        try:
            page_size = int(page_size) or DEFAULT_PAGE_SIZE
        except:
            page_size = DEFAULT_PAGE_SIZE

        if page_size == -1:
            total = 1
            page = 1
        else:
            # calculate count of pages
            total = int(math.ceil(float(records)/page_size))
            # check if requested page still exists
            page = page <= total and page or total
            # index of first row to show
            first = ((page-1)*page_size)
            # index of last row to show
            last = first+page_size
            # if less entries as requested rows exist on this page
            # show all available
            if last >= records:
                data = data[first:]
            else:
                data = data[first:last]
        return page, total, records, data

    def prepare_json_data(self, page, total, records, data, subgridid, raw):
        """
        This function returns the fields (raw) or formated content of fields of a grid widget.
        
        :param page: current page
        :type page: int
        :param total: total number of pages
        :type total: int
        :param records: total number of elements
        :type records: str
        :param data: list of elements
        :type data: ~array.array
        :param subgridid: the id of the subgrid requesting the data
        :type subgridid: str
        :param raw: return elements as fields (raw) or formated
        :type raw: bool
        
        :return: a list of elements in raw or formated
        :rtype: ~array.array
        """
        # get GridColumns to be able to format the data
        if subgridid:
            if isinstance(self.gridWidget, DataGrid):
                gridid = "%s_table_%s_subgrid" % (self.gridWidget.id, subgridid)
            else:
                gridid = self.gridWidget.id
            fields = self.gridWidget.subgrid_columns
        else:
            if isinstance(self.gridWidget, DataGrid):
                gridid = "%s_table" % self.gridWidget.id
            else:
                gridid = self.gridWidget.id
            if hasattr(self.gridWidget, "fields"):
                fields = self.gridWidget.fields
            else:
                fields = None
    
        if raw or not fields:
            return data

        columns = []
        for i, is_first, is_last, row in enumerate_plus(data or []):
            column = {}
            for field in fields: # add all fields (also actions)
                try: # try to format the value using the field/column _getter method
                    if not isinstance(self.gridWidget, KendoGrid) and isinstance(field, CheckBoxColumn):
                        # XXX: fix me -> otherwhise jqgrid uses thecheckbox as tr ID
                        column[field.name] = row.get(field.name)
                        continue
                    if isinstance(field, ActionsColumn):
                        column[field.name] = field.get_field(row=row,
                                                             data=data,
                                                             index=i,
                                                             # can only be true on the first page
                                                             is_first_row=(page == 1) and is_first or False,
                                                             # can only be true on the last page
                                                             is_last_row=(page == total) and is_last or False,
                                                             gridid=gridid,
                                                             controllername=self.name,
                                                             ajax=True)
                    else:
                        column[field.name] = field.get_field(row=row,
                                                             data=data,
                                                             index=i,
                                                             # can only be true on the first page
                                                             is_first_row=(page == 1) and is_first or False,
                                                             # can only be true on the last page
                                                             is_last_row=(page == total) and is_last or False)
                except Exception, ex:
                    logger.error("Error while trying to format column '%s' value (%s)" % (field.name, str(ex)), exc_info=True)
                    column[field.name] = row.get(field.name)
            columns.append(column)
        return columns
   

    @expose(template="endian.emi.templates.gridcontroller_standalone")
    def standalone(self, **args):
        """show the grid using standalone.mak as master template"""
        return self.index_internal(request_type=REQUEST_TYPE.STANDALONE,
                                   **args)
    
    @expose(template="endian.emi.templates.gridcontroller")
    def naked(self, **args):
        """show only the html code of the datagrid widget"""
        return self.index_internal(request_type=REQUEST_TYPE.NAKED,
                                   **args)

    @expose(template="endian.emi.templates.gridcontroller_plugin")
    def plugin(self, **args):
        """show only the html code of the datagrid widget with css 
        and js includes"""
        return self.index_internal(request_type=REQUEST_TYPE.PLUGIN,
                                   **args)
    
    @expose(template="endian.emi.templates.gridcontroller")
    def naked_grid(self, **args):
        """show only the html code of the datagrid widget editor"""
        return self.index_internal(gridOnly=True,
                                   request_type=REQUEST_TYPE.NAKED,
                                   data_options={"nodata": False},
                                   **args)

    @expose(template="endian.emi.templates.gridcontroller_standalone")
    def standalone_edit(self, **args):
        """show the editor using standalone.mak as master template"""
        return self.index_internal(editOnly=True,
                                   request_type=REQUEST_TYPE.STANDALONE,
                                   **args)
    
    @expose(template="endian.emi.templates.gridcontroller")
    def naked_edit(self, **args):
        """show only the html code of the datagrid widget grid"""
        return self.index_internal(editOnly=True,
                                   request_type=REQUEST_TYPE.NAKED,
                                   **args)
    
    def index_internal(self,
                       editOnly=None,
                       gridOnly=None,
                       request_type=REQUEST_TYPE.MASTER,
                       data_options={},
                       **args):
        if editOnly is None:
            editOnly = self.editOnly
        if gridOnly is None:
            gridOnly = self.gridOnly
        try:
            tab = int(args.get("TAB", 0))
        except:
            tab = 0
        ret = BaseController.index_internal(self,
                                            request_type=request_type,
                                            data_options=data_options,
                                            **args)
        
        request_type = ret.get('request_type', REQUEST_TYPE.MASTER)
        # Store the request type in the request object, so it can be accessed by the error page
        request.request_type = request_type
        permissions = ret['permissions']
        args = ret['args']
        data = ret['data']
        error = ret['error']
        info = ret['info']
        important = ret['important']
        if hasattr(self, "_apply") and self.storage and self.storage.changed:
            important = _("The configuration has been changed and needs to be applied in order to make the changes active.")
        else:
            important = ""
        success = error and False or True
        
        #: make sure we show the correct editor tab
        args['TAB'] = tab
        
        ret = dict(success=success,
                   error=error,
                   important=important,
                   info=info,
                   args=args,
                   data=data,
                   controllername=self.name,
                   request_type=request_type,
                   permissions=permissions)
        
        if request_type == REQUEST_TYPE.JSON:
            return ret
        
        # Prepare the parameters for the template
        action = args.get("ACTION", "")
        if callable(self.add_button_enabled):
            add_button_enabled = self.add_button_enabled()
        else:
            add_button_enabled = self.add_button_enabled
        
        ret.update(dict(hideable=self.hideable,
                        show_label=self.show_label,
                        hide_label=self.hide_label,
                        edit_always=self.edit_always,
                        action=action,
                        editor=self.editorWidget,
                        grid=self.gridWidget,
                        editOnly=editOnly,
                        gridOnly=gridOnly,
                        request_type=request_type,
                        permissions=permissions,
                        hidecontentbox=self.hidecontentbox,
                        add_button_enabled=add_button_enabled))
        return ret
    
    def loadDataByID(self, id):
        """
        This function loads data by the given id from the storage.
        Overwrite this function if custom loading is needed
        e.g. with a database or backend not supported by the storage.
        
        :param id: the id of the subgrid requesting the data
        :type id: str
        
        :return: a dictionary containing the data for the given id
        :rtype: dict
        """
        if self.storage:
            return self.storage.load(id=id)
        return {}
    
    def storeDataByID(self, id, data):
        """
        This function stores data to the given id into a storage.
        Overwrite this function if you custom storing is needed
        e.g. with a database or backend not supported by the storage.
        
        :param id: the id of the subgrid requesting the data
        :type id: str
        :param data: the data which needs to be stored with the given id
        :type data: dict
        
        :return: a dictionary containing the data for the given id
        :rtype: dict
        """
        if self.storage and self.do_store:
            self.storage.store(data)
        return data
    
    def deleteDataByID(self, id):
        """
        This function deletes data by the given id from the storage.
        Overwrite this function if custom deleting is needed
        e.g. with a database or backend not supported by the storage.
        If you have performance problems remove the data loading here,
        but make sure that onDelete and onDeleteSuccess do not depend on the data.
        
        :param id: the id of the subgrid requesting the data
        :type id: str
        
        :return: a dictionary containing the data for the given id
        :rtype: dict
        """
        data = self.loadDataByID(id=id)
        if self.onDelete(id, data) and self.do_delete:
            self.storage.delete(id=id)
            self.onDeleteSuccess(data)
        return data
    
    def loadData(self,
            args,
            order_by,
            order_sort,
            search_args,
            filters=[],
            load_optional_args=None):
        """
        overwrite this method to use custom loading of data
        
        :param args:                    this parameter is ignored
        :type args:                     dict
        :param order_by:                ordering field
        :type order_by:                 str
        :param order_sort:              order direction (asc/desc)
        :type order_sort:               str
        :param disable_filter_query:    if True, don't execute the filter function
        :param search_args:             filter the result accoding to the key=values pairs 
        :type search_args:              dict
        :param filters:                 filters conditions
        :type filters:                  dict
        :param load_optional_args:      optional arguments passed to load/filter function
        :type load_optional_args:       dict
        """
        
        # no storage, no values
        if not self.storage:
            return []
        
        if search_args or filters:
            # return filtered data if storage supports it
            return self.storage.filter(order_by=order_by,
                    order_sort=order_sort,
                    disable_filter_query=self.gridWidget.disable_storage_filter_query,
                    filters=filters,
                    filter_optional_args=load_optional_args,
                    **search_args) or []
        else:
            # return all data if storage does not support filtering or no filtering is required
            try:
                return self.storage.load(order_by=order_by,
                        order_sort=order_sort,
                        disable_filter_query=self.gridWidget.disable_storage_filter_query,
                        load_optional_args=load_optional_args) or []
            except TypeError, e:
                # import traceback
                # traceback.print_exc()
                return self.storage.load() or []
        
        # will we ever get it here?
        return []
   
    def on_get_data(self, args, data_options):
        """
        This method can be customized in subclassed for parsing additional parameters
        (e.g. populate load_optional_args)

        :param args:          dictionary of arguments which will be passed to loadData and gridWidget.filterQuery
        :type args:           dict 
        :param data_options:  dictionary with options for sorting and filtering
        :type data_options:   dict
        :return:              args, data_options
        :rtype:               tuple
        """
        return args, data_options

    def getData(self, args,
                      data_options={}):
        """
        This function prepares the arguments and calls loadData.
        
        data_options:
            order_by (string)
            order_sort (asc/dsc)
            nodata (boolean)
            filters (dict)
            search_name (string) name of the 'search_string' option
            search_string (string)
            load_optional_args (dict)
        
        Sequence:
        json_grid --> getData --> on_get_data
                              --> loadData --> storage.filter/storage.load
                              --> storage_filter
                              --> gridWidget.filterQuery
        
        :param args:          dictionary of arguments which will be passed to loadData and gridWidget.filterQuery
        :type args:           dict 
        :param data_options:  dictionary with options for sorting and filtering
        :type data_options:   dict 
        :return:              list of loaded and filtered elements
        :rtype:               list
        """
        args, data_options = self.on_get_data(args, data_options)
        nodata = data_options.get("nodata", None)
        # overwrite nodata by passing nodata=True/False to index_internal/getData
        if nodata is None:
            # do not read data on load if gridwidget uses ajax, 
            if self.gridWidget and self.gridWidget.ajax:
                nodata = True
            else: # read data per default
                nodata = False
        
        # check if data should be returned
        if nodata:
            logger.debug("data will be loaded using an ajax call")
            return []
        
        order_by = data_options.get("order_by", None)
        if order_by is None:
            order_by = self.gridWidget.order_by
        order_sort = data_options.get("order_sort", None)
        if order_sort is None:
            order_sort = getattr(self.gridWidget, "order_sort", None) or "asc" 
        
        search_name = data_options.get("search_name", "search_string")
        search_string = data_options.get("search_string", "")
        filters = data_options.get("filters")
        load_optional_args = data_options.get("load_optional_args")
        
        search_args = {}
        if search_name and search_string:
            search_args = {search_name: search_string}
        
        data = self.loadData(args=args,
            order_by=order_by,
            order_sort=order_sort,
            search_args=search_args,
            filters=filters,
            load_optional_args=load_optional_args)
        
        if self.storage_filter:
            data = self.storage_filter(data)
        
        # Apply filters
        if data != [] and hasattr(self.gridWidget, 'filterQuery'):
            data = self.gridWidget.filterQuery(query=data, args=args)
        return data
    
    def onSubgrid(self, data):
        """
        Triggered after loading the subgrid data
        Manipulate the data here before it gets returned as json
        """
        return data
    
    def error(self, id, data, invalid):
        logger.error("%s" % invalid)
        return {}
    
    def edit(self, **args):
        id = args.get("ID", "")
        if id: # at this point it is eighter str or None
            try: # convert int ids into int
                id = int(id)
            except:
                logger.debug("id '%s' is not int" % id)
            args = self.loadDataByID(id=id)
            args = self.onLoad(id, args)
            if not hasattr(args, 'keys'):
                raise Exception("onLoad trigger has to return a dictionary, but it returned a value of type '%s': %s" % (type(args), args))
            args["ACTION"] = "edit"
        else:
            args = self.onNew("", args)
        return args
    
    def onLoad(self, id, data):
        """
        Triggered after loading a set of data for editing
        """
        # Warning, doing something like debug("onLoad: %s, %s" % (id, data)) will load all the data !
        return data

    def onNew(self, id, data):
        """
        Triggered before starting to edit a new item
        """
        return data
    
    def idsFromArgs(self, args):
        
        raw_ids = self.to_list(args.get("ID", args.get("ID[]", "")))
        
        all_ = args.get("all", False)
        if not raw_ids and all_:
            sort, filters = get_kendo_data(args)
            if not filters:
                filters = {}
            
            # defaults to search in any field
            data_options = {
                "nodata": False,
                "filters": filters
            }
            data = self.getData(args, data_options=data_options) or []
            
            # convert entity objects into dicts
            if hasattr(data, "__json__"):
                data = data.__json__()
            
            raw_ids = [record.get('ID', "") for record in data]
        
        return raw_ids
    
    def store(self, **args):
        id = args.get("ID", "")
        try:
            try: # convert int ids into int
                id = int(id)
            except:
                logger.debug("id '%s' is not int" % id)
            vargs = args.copy()
            vargs = self.onSubmit(id, vargs)
            if self.editorWidget and self.do_validate:
                vargs = self.editorWidget.validate(vargs)
            vargs["ID"] = id
        except Invalid, i:
            # The special key "form" is the error message for the form as a whole
            form_error =  i.error_dict.get('form')
            if form_error:
                args['form_error'] = form_error
            args["ACTION"] = "edit"
            logger.error("Could not validate: %s" % vargs)
            logger.debug(str(i), exc_info=True)
            self.error(id, args, i)
            return args
        else:
            vargs = self.onStore(id, vargs)
            if 'error' in vargs:
                return vargs
            vargs = self.storeDataByID(id, vargs)
            vargs = self.onStoreSuccess(id, vargs)
        return vargs
    
    def multiStore(self, **args):
        error = []
        raw_ids = self.idsFromArgs(args)
        for i, raw_id in enumerate(raw_ids):
            vargs = {}
            id = raw_id or ""
            try: # convert int ids into int
                id = int(id)
            except:
                logger.debug("id '%s' is not int" % id)
            try:
                item = self.loadDataByID(id)
                for key, value in item.iteritems():
                    if args.has_key(key):
                        vargs[key] = args[key][i]
                    else:
                        vargs[key] = value
                vargs['ACTION'] = args['ACTION']
                vargs['CONTROLLERNAME'] = args['CONTROLLERNAME']
                vargs = self.onSubmit(id, vargs)
                if self.editorWidget and self.do_validate:
                    vargs = self.editorWidget.validate(vargs)
                vargs["ID"] = id
            except Invalid, i:
                args["ACTION"] = "edit"
                error.append("%s" % i)
            except Exception, e:
                error.append("%s" % e)
            else:
                vargs = self.onStore(id, vargs)
                if 'error' in vargs:
                    return vargs
                vargs = self.storeDataByID(id, vargs)
                vargs = self.onStoreSuccess(id, vargs)
        if error:
            args['error'] = "<br />".join(error)
        else:
            args = self.onMultiStoreSuccess(args)
        return args
    
    def onStore(self, id, data):
        """
        Triggered before saving
        """
        return data
    
    def onStoreSuccess(self, id, data):
        """
        Triggered after data has been written to storage
        """
        return data
    
    def onMultiStoreSuccess(self, data):
        """
        Triggered after all data has been written to storage
        """
        return data
    
    def onSubmit(self, id, data):
        """
        Triggered before validation
        """
        return data
    
    def changeFlag(self, args, idKey, default, onChange=None, onChangeSuccess=None, boolean=False):
        """
        This functions changes a parameter of stored elements based on the id of the element.
        
        :param args: POST request arguments containing the value of the parameter.
        :type args: dict
        :param idKey: key which needs to be changed
        :type idKey: str
        :param default: default value
        :type default: str
        :param onChange: class function triggered before the parameter is changed
        :type onChange: function
        :param onChangeSuccess: class function triggered after the parameter was changed
        :type onChangeSucces: function
        :param boolean: is the parameter a boolean
        :type boolean: bool
        
        :return: processed arguments
        :rtype: dict
        """
        error = []
        empty = True
        value = args.get(idKey, default)
        if boolean:
            value = value == "on"
        
        raw_ids = self.idsFromArgs(args)
        
        for raw_id in raw_ids:
            id = raw_id or ""
            try: # convert int ids into int
                id = int(id)
            except:
                logger.debug("id '%s' is not int" % id)
            try:
                item = self.loadDataByID(id=id)
                item[idKey] = value
                item['ACTION'] = args['ACTION']
                item['CONTROLLERNAME'] = args['CONTROLLERNAME']
                if onChange:
                    item = onChange(id, item)
                self.storeDataByID(id, item)
                empty = False
            except Invalid, i:
                error.append("%s" % i)
                empty = False
            except Exception, e:
                error.append("%s" % e)
        
        if empty:
            error.append(_("You have to choose at least one element"))
        if error:
            args['error'] = "<br />".join(error)
        elif onChangeSuccess:
            onChangeSuccess(args)
        return args
    
    def enable(self, default="on", **args):
        """
        This function sets the 'enabled' parameter of a single item/a list of items to True.
        
        :param default: default value
        :type default: str
        :param **args: additional arguments
        :type **args: dict
        
        :return: processed arguments
        :rtype: dict
        """
        return self.changeFlag(args=args, idKey="enabled", default=default,
                                       onChange=self.onEnable, onChangeSuccess=self.onEnableSuccess,
                                       boolean=True)
    
    def disable(self, **args):
        """
        This function sets the 'enabled' parameter of a single item/a list of items to False.
        
        :param **args: additional arguments
        :type **args: dict
        
        :return: processed arguments
        :rtype: dict
        """
        return self.enable(default="off", **args)
    
    def onEnable(self, id, data):
        """
        This function is triggered before the 'enable/disable' action is executed on a single item.
        
        :param id: id of the data element
        :type id: str
        :param data: loaded data element
        :type data: dict
        
        :return: processed data element
        :rtype: dict
        """
        return data
    
    def onEnableSuccess(self, data):
        """
        This function is triggered after the 'enable/disable' action was
        finished successfully on a single item.
        
        :param id: id of the data element
        :type id: str
        :param data: stored data element
        :type data: dict
        
        :return: processed data element
        :rtype: dict
        """
        return data
    
    def active(self, default="on", **args):
        """
        This function sets the 'activated' parameter of a single item/a list of items to True.
        
        :param **args: additional arguments
        :type **args: dict
        
        :return: list of loaded and filtered elements
        :rtype: dict
        """
        return self.changeFlag(args=args, idKey="activated", default=default,
                                       onChange=self.onActive, onChangeSuccess=self.onActiveSuccess,
                                       boolean=True)
    
    def onActive(self, id, data):
        """
        This function is triggered before the 'active' action is executed on a single item.
        
        :param id: id of the data element
        :type id: str
        :param data: loaded data element
        :type data: dict
        
        :return: processed data element
        :rtype: dict
        """
        return data
    
    def onActiveSuccess(self, data):
        """
        This function is triggered after the 'active' action was
        finished successfully on a single item.
        
        :param id: id of the data element
        :type id: str
        :param data: stored data element
        :type data: dict
        
        :return: processed data element
        :rtype: dict
        """
        return data
    
    def delete(self, **args):
        """
        This function deletes a single item/a list of items.
        
        :param **args: additional arguments
        :type **args: dict
        
        :return: list of loaded and filtered elements
        :rtype: dict
        """
        error = []
        empty = True
        idlist = []
        
        raw_ids = self.idsFromArgs(args)
        
        for raw_id in raw_ids:
            try:
                id = raw_id or ""
                try: # convert int ids into int
                    id = int(id)
                except:
                    logger.debug("id '%s' is not int" % id)
                idlist.append(id)
            except Exception, e:
                error.append("%s " % e)
        idlist.sort(reverse=True) # need to delete from highest to lowest ID
        for id in idlist:
            try:
                empty = False
                self.deleteDataByID(id=id)
            except Exception, e:
                error.append("%s " % e)
        if empty:
            error.append(_("You have to choose at least one element"))
        if error:
            args['error'] = "<br />".join(error)
        return args
    
    def onDelete(self, id, data):
        """
        This function is triggered before the 'delete' action is executed on a single item.
        
        :param id: id of the data element
        :type id: str
        :param data: loaded data element
        :type data: dict
        
        :return: processed data element
        :rtype: dict
        """
        return data
    
    def onDeleteSuccess(self, data):
        """
        This function is triggered after the 'delete' action was
        finished successfully on a single item.
        
        :param data: deleted data element
        :type data: dict
        
        :return: processed data element
        :rtype: dict
        """
        return data
    
    def moveUp(self, **kargs):
        id_ = kargs.get("ID", "")
        items = self.storage.load()
        try:
            id_ = int(id_) # only works with int IDs
            index = id_
            # do we have an oldschool grid / custom storage?
            if len(items) == index:
                index = index-1
            # do we have an oldschool grid / custom storage?
            if id_ != int(items[index]['ID']):
                index = index-1
                if id_ != int(items[index]['ID']):
                    raise Exception("invalid ID value")
            above = copy.copy(items[index-1]) # item above
            items[index-1] = items[index] # replace item above
            items[index-1]['ID'] = id_-1
            items[index] = above # replace item with item above
            items[index]['ID'] = id_
            self.storage.store(items)
        except Exception, e:
            raise Exception("Could not moveUp record #%s: %s" % (id_, e))
        return kargs
    
    def moveDown(self, **kargs):
        id_ = kargs.get("ID", "")
        items = self.storage.load()
        try:
            id_ = int(id_) # only works with int IDs
            index = id_
            # do we have an oldschool grid / custom storage?
            if len(items) == index:
                index = index-1
            # do we have an oldschool grid / custom storage?
            if id_ != int(items[index]['ID']):
                index = index-1
                if id_ != int(items[index]['ID']):
                    raise Exception("invalid ID value")
            below = copy.copy(items[index+1]) # item below
            items[index+1] = items[index] # replace item below
            items[index+1]['ID'] = id_+1
            items[index] = below # replace item with item below
            items[index]['ID'] = id_
            self.storage.store(items)
        except Exception, e:
            raise Exception("Could not moveDown record #%s: %s" % (id_, e))
        return kargs
    
    @staticmethod
    def to_list(values):
        """
        Returns an iterable value.
        If 'values' is null returns and empty list.,
        if it is a single element returns a list composed of the single element,
        else returns 'values' 
        """
        if not values:
            return []
        elif hasattr(values, '__iter__') and not isinstance(values, basestring):
            return values
        else:
            return [values]

