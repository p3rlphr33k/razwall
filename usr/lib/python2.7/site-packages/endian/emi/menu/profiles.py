#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2015 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import re
import os
import glob
import os.path
import threading
import base64
import fnmatch
from endian.emi.framework import HTTPError, request
from endian.data import DataSource
from endian.data.constants import constants

__all__ = [
    'check_user_path_access',
    'check_access',
    'get_current_user',
]

_profiles = {} # id -> profile
_profiles_timestamp = None
_profiles_lock = threading.Lock()
_users = {} # name -> user
_users_timestamp = None
_users_lock = threading.Lock()

def _getmtime(f):
    try:
        return os.path.getmtime(f)
    except:
        return None

def _calculate_hash(t):
    files = [os.path.join(constants['USER_D'], 'auth/' + t)] + glob.glob(os.path.join(constants['PERSISTENT_D'], 'auth/' + t + '*.default'))
    files = [(x, _getmtime(x)) for x in files]
    return hash(str(files))

def _load_profiles():
    global _profiles, _profiles_timestamp
    profiles_timestamp = _calculate_hash('guiprofile') 
    if _profiles_timestamp == profiles_timestamp:
        return True
    try:
        _profiles_lock.acquire()
        _profiles_timestamp = profiles_timestamp
        profiles = {}
        ds = DataSource()
        for profile in ds.auth.guiprofile:
            _id = profile.get('id')
            if not _id:
                continue
            profiles[_id] = profile
            profile['white_list'] = [re.compile(fnmatch.translate(w)) for w in profile.get('white_list', [])] + \
                    [re.compile(fnmatch.translate(x[:-2 ])) for x in profile.get('white_list', []) if x.endswith('/*')]
            profile['black_list'] = [re.compile(fnmatch.translate(w)) for w in profile.get('black_list', [])] + \
                    [re.compile(fnmatch.translate(x[:-2 ])) for x in profile.get('black_list', []) if x.endswith('/*')]
        _profiles = profiles
    finally:
        _profiles_lock.release()
    return True

def _load_users():
    global _users, _users_timestamp
    users_timestamp = _calculate_hash('guiuser') 
    if _users_timestamp == users_timestamp:
        return False
    try:
        _users_lock.acquire()
        users = {}
        ds = DataSource()
        for user in ds.auth.guiuser:
            name = user.get('name')
            if not name:
                continue
            users[name] = user
        _users = users
    finally:
        _users_lock.release()
    return True

def get_current_user():
    """
       Get the name of the current user (logged with basic auth)

       :return: the username or None
       :rtype: str
    """
    try:
        auth_header = request.headers.get('Authorization')
        scheme, params = auth_header.split(' ', 1)
        return base64.decodestring(params).split(':', 1)[0]
    except:
        return None

def check_user_path_access(user, path):
    """
        Check if an user has the rights to access to a given page

        :param user: username
        :type user: str
        :param path: url path (e.g. /manage/dashboard/)
        :type path: str
        :return: true if the user can access to the page
        :type: bool
    """
    if not _load_profiles():
        return True
    if not _load_users():
        return True
    user = _users.get(user)
    if user is None:
        return True
    try:
        profile = _profiles.get(int(user.get('profile')), None)
    except:
        profile = None
    if profile is None:
        return True
    for w in profile.get('black_list'):
        if w.match(path) is not None:
            return False
    if len(profile.get('white_list')) == 0:
        return True
    for w in profile.get('white_list'):
        if w.match(path) is not None:
            return True
    return False

def check_access(*args, **kargs):
    """
        Check if the current user (logged with basic auth) has the rights to access to the requested page
    """
    if not check_user_path_access(get_current_user(), request.path_info):
        raise HTTPError(403, "Forbidden")

