#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2010-03-11"

"""
EMI Status interface API
"""

# publish status API wrapping from commands library

from endian.core.commands import register, lookup, getRegistry

from endian.core.commands import call
from endian.core.commands import HTTPOptionError
from endian.core.commands import OptionParserHelpExit
from endian.core.commands import OptParseError
from endian.core.commands import parseFunctionDoc

from endian.core.cache import Cache
from endian.core.cache import CacheException
from endian.core.cache import Expirer
from endian.core.cache import TimeExpirer
import time
import types

from endian.core.logger import *

__all__ = [
    'register',
    'lookup',
    'getRegistry',
    'call',
    'HTTPOptionError',
    'OptionParserHelpExit',
    'OptParseError',
    'parseFunctionDoc',
    'getData',
    
    ]


_cache = Cache()

def _get(cmd, *argl, **args):
    method = lookup(cmd)
    data = method(**args)
    if not isinstance(data, types.DictType):
        raise TypeError("Status method need to return a dict!")
    return data

def getData(cmd, timeout=None, expire=False, *argl, **args):
    """
    ... autofunction::: getData
        returns status data identified by 'cmd'.

        If 'timeout' is set, the generated status data will
        be cached for the specified amount of time (float, in seconds).

        If 'expire' is set, old values will be expired from the cache
        and a new one will be generated.
        
        In that case, the following additional keys will be added
        to the returning dict:

        cached
          is :const:`True` or :const:`False`, whether or not the value
          comes from the cache or not.
        cachedOn
          timestamp of when the value has been put into the cache
        cacheHitAt
          timestamp when the value was retrieved from cache.

        Optional parameters to the status call will be passed to the
        specified status module. Right now different arguments don't expire
        the cache item.

    """
    if timeout == None:
        debug("Do not cache '%s'", cmd)
        ret = _get(cmd, *argl, **args)
        ret['cached'] = False
        return ret

    debug("Cache '%s' with a timeout of %s", cmd, timeout)
    if expire or cmd not in Expirer.keys:
        try:
            debug("Register expirer with '%s' for key '%s'", timeout, cmd)
            Expirer.register(TimeExpirer(float(timeout)), 
                             key=cmd)
        except ValueError:
            raise ValueError("Expiration timeout 'expire' must be numeric!")

    # ok, let's cache a bit
    try:
        obj = _cache.get(cmd)
        if expire:
            debug("Expire the cache item '%s'", cmd)
            obj.expire()
        ret = obj.get()
        ret['cacheHitAt'] = time.time()
        ret['cachedOn'] = obj.timestamp
        ret['cached'] = True
        return ret
    except CacheException:
        debug("Not in cache: ",  exc_info=True)
        try:
            obj = _cache.put(cmd, _get(cmd, *argl, **args))
            ret = obj.get()
            ret['cacheHitAt'] = time.time()
            ret['cachedOn'] = obj.timestamp
            ret['cached'] = False
            return ret
        except CacheException:
            return None
    return None
