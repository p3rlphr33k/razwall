#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import sys
import os
import signal
import pkg_resources
import cherrypy
import turbogears
from endian.core.daemon import registerSignalHandler
from endian.core.logger import *
from endian.core.events import registerEvent, subscribeEvent, triggerEvent
from endian.core.commands import register
from endian.core.procutils import set_process_name
from endian.core.i18n import setLanguage
from endian.core.modules import module_registry
from endian.emi.server.release import version
from endian.emi.server.daemon import ConfigurationError, reload_language, load_emi_module, setDebugLevel
from endian.emi.menu import Menu

BRAND_SETTINGS = "/etc/endian/emi-custom.conf"

cherrypy.lowercase_api = True

emi = None

def noneToEmptyString(string):
    import types
    if isinstance(string, types.NoneType):
        return ""
    return string


def _read_config(args, modulename="endian.emi.server.config"):
    """Read deployment configuration file.

    First looks on the command line for a desired config file, if it's not on
    the command line, then looks for 'setup.py' in the parent of the directory
    where this module is located.

    If 'setup.py' is there, assumes that the application is started from
    the project directory and should run in development mode and so loads the
    configuration from a file called 'dev.cfg' in the current directory.

    If 'setup.py' is not there, the project is probably installed and the code
    looks first for a file called 'prod.cfg' in the current directory and, if
    this isn't found either, for a default config file called 'default.cfg'
    packaged in the egg.

    """
    setupdir = os.path.dirname(os.path.dirname(__file__))
    curdir = os.getcwd()
    if args:
        configfile = args[0]
    elif os.path.exists(os.path.join(setupdir, "setup.py")):
        configfile = os.path.join(setupdir, "dev.cfg")
    elif os.path.exists(os.path.join(curdir, "prod.cfg")):
        configfile = os.path.join(curdir, "prod.cfg")
    elif os.path.exists(os.path.join(curdir, "dev.cfg")):
        configfile = os.path.join(curdir, "dev.cfg")
    else:
        try:
            configfile = pkg_resources.resource_filename(
              pkg_resources.Requirement.parse("emi"),
                "config/default.cfg")
        except pkg_resources.DistributionNotFound:
            raise ConfigurationError("Could not find default configuration.")

    info("Read configuration from '%s'.", configfile)
    turbogears.update_config(configfile=configfile, modulename=modulename)

    if os.path.exists(BRAND_SETTINGS):
        turbogears.update_config(configfile=BRAND_SETTINGS)

def bootstrap():
    """ Dummy function for loading bootstrap data into the database """
    pass

def start(daemon_name="endian.emi.server.daemon.EmiDaemon",
          exclude_families="EndianNetwork",
          include_families=None,
          process_name="emi"):
    """ Start EMI """
    global emi

    set_process_name(process_name)

    # The first argument on the command line is the daemon class name
    if len(sys.argv) > 1 and not sys.argv[1].startswith('-'):
        daemon_name = sys.argv[1]

    daemon_module_name, daemon_name_class = daemon_name.rsplit('.', 1)
    __import__(daemon_module_name)
    daemon_class = getattr(sys.modules[daemon_module_name],daemon_name_class)
    emi = daemon_class()
    emi.catchTracebacks = True

    # Exclude the modules with family=EndianNetwork
    emi.optparser.set_defaults(exclude_families=exclude_families,
                               include_families=include_families)

    modules = emi.getOptionParserGroup("Modules configuration")
    modules.add_option("-x", "--exclude", dest="excludemodules",
                       help="Comma separated list of modules to be excluded "
                       "during auto-load",
                       metavar="EXCLUDE")
    modules.add_option("--exclude_families", dest="exclude_families",
                       help="Comma separated list of modules families to be excluded",
                       metavar="EXCLUDE")
    modules.add_option("--include_families", dest="include_families",
                       help="Comma separated list of modules families to be included",
                       metavar="INCLUDE")

    dblog = emi.getOptionParserGroup("Database log")
    dblog.add_option("--dblog", action="store_true", dest="dblog",
                       help="Enable db statements log",
                       metavar="INCLUDE", default=False)
    dblog.add_option("--dblogfile", dest="dblogfile",
                       help="Specify the file where to log db statements",
                       metavar="DBLOGFILE", default=None)

    emi.opthandler()

    if emi.options.configfile:
        try:
            _read_config([emi.options.configfile], daemon_module_name + ".config")
        except AttributeError:
            _read_config(emi.arguments, daemon_module_name + ".config")
    else:
        _read_config(emi.arguments, daemon_module_name + ".config")

    if emi.options.dblog or emi.options.dblogfile:
        dblogger = logging.getLogger('sqlalchemy.engine')
        if emi.options.dblogfile:
            log_handler = logging.FileHandler('db.log')
        else:
            log_handler = logging.StreamHandler()
        dblogger.addHandler(log_handler)
        dblogger.setLevel(emi.options.debug and logging.DEBUG or logging.INFO)

    emi.run(emi.options)

def reload(module=None, reload_all=True, session_id=None):
    """
    Reloads EMI modules by re-instantiation.
    If a module is supplied in '''module''' and ''reload_all'' is False,
    only that EMI module will be re-instantiated.
    If omitted, the entire EMI will reloaded.

    :param module: Specifies the module to be reloaded
        Reload entire EMI if None.
    :type module: string
    :param reload_all: Force reloading all the modules,
        even if ''module'' is specified
    :type reload_all: bool
    :param session_id: EMI session ID
    :type session_id: string
    """
    if emi != None:
        info("Reload EMI...")
        emi.reload(module, reload_all, session_id)
    return "Reloading EMI..."


def reload_language_handler(sig=None, frame=None):
    reload_language()

registerSignalHandler(signal.SIGHUP, reload_language_handler)


__all__ = [
    'start',
    'bootstrap',
    'ConfigurationError',
    'reload',
    'setDebugLevel',
    'noneToEmptyString',
    ]
