#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+
#

import cPickle as pickle
import threading
import time
import datetime
from endian.emi.framework import config
from endian.core.logger import error

EMI_VISITS_PATH = "/tmp/visits.emi"

class EmiVisit(object):
    key = None
    visit_key = None
    is_new = None
    created = None
    expiry = None
    user_id = None # the id is not necessary a numeric id, it could be the username


class EmiVisitManager(threading.Thread):

    def __init__(self, timeout):
        threading.Thread.__init__(self, name="VisitManager")
        if isinstance(timeout, datetime.timedelta):
            timeout = timeout.days * 86400 + timeout.seconds
        self.timeout = timeout
        self.visits_path = EMI_VISITS_PATH
        # Load visits
        try:
            f = open(self.visits_path, 'rb')
            self.visits = pickle.load(f)
            f.close()
        except:
            self.visits = {}
        self.lock = threading.Lock()
        self._shutdown = threading.Event()
        self.interval = config.get('visit.interval', 150) # seconds
        self._expire_hooks = []
        self.setDaemon(True)
        self.start()

    def new_visit_with_key(self, visit_key):
        """
            Return a new Visit object with the given key.

            :param visit_key: visit key
            :type visit_key: string
        """
        try:
            visit = EmiVisit()
            visit.visit_key = visit_key
            visit.is_new = True
            visit.created = time.time()
            visit.expiry = visit.created + self.timeout
            try:
                self.lock.acquire()
                self.visits[visit_key] = visit
                self._write_visits()
            finally:
                self.lock.release()
            return visit
        except Exception, ex:
            error(ex)
            raise ex

    def visit_for_key(self, visit_key):
        """
            Return the visit (tg api Visit) for this key
            Returns None if the visit doesn't exist or has expired.

            :param visit_key: visit key
            :type visit_key: string
        """
        try:
            try:
                self.lock.acquire()
                visit = self.visits[visit_key]
            finally:
                self.lock.release()

            now = time.time()
            if visit.expiry < now:
                return None
            visit.expiry = now + self.timeout
            visit.is_new = False
            return visit
        except KeyError, ex:
            return None
        except Exception, ex:
            error(ex)
            raise ex

    def update_visit(self, visit_key, expiry):
        error("Visit Manager update_visit %s", visit_key)
        try:
            try:
                self.lock.acquire()
                visit = self.visits[visit_key]
            finally:
                self.lock.release()

            now = time.time()
            if visit.expiry < now:
                return None
            visit.expiry = now + self.timeout
            visit.is_new = False
        except KeyError:
            return None

    def shutdown(self, timeout=None):
        try:
            self.lock.acquire()
            self._shutdown.set()
            self.join(timeout)
        finally:
            self.lock.release()
        try:
            self._write_visits()
        except Exception, ex:
            error(ex)
        if self.isAlive():
            error("Visit Manager thread failed to shutdown.")

    def _write_visits(self):
        f = open(self.visits_path, 'wb')
        pickle.dump(self.visits, f)
        f.close()

    def run(self):
        while not self._shutdown.isSet():
            self.lock.acquire()
            if self._shutdown.isSet():
                self.lock.release()
                continue
            try:
                if self.visits:
                    # Delete expired session
                    now = time.time()
                    visits = {}
                    expired = {}
                    for k, v in self.visits.iteritems():
                        if v.expiry >= now:
                            visits[k] = v
                        else:
                            expired[k] = v
                    self.visits = visits
                    # Write the visits
                    self._write_visits()
                    # Execute the hooks
                    for hook in self._expire_hooks:
                        if hook is not None:
                            try:
                                hook(expired, visits)
                            except:
                                pass
            finally:
                self.lock.release()
            self._shutdown.wait(self.interval)


    def register_expire_hook(self, fn):
        """
            Register an hook to be executed when some visits expire
            The hook is called with the following arguments:
            - expired: dictionary of expired visits
            - visits: dictionary of not expired visits
        """
        self._expire_hooks.append(fn)

__all__ = ['EmiVisitManager']
