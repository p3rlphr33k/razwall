#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import sys
# set system to utf-8
reload(sys)
sys.setdefaultencoding("utf-8")
import os
import cherrypy
import turbogears
from endian.core.daemon import Daemon, MainLoopExit
from endian.core.commands import register, getRegistry
from endian.core.logger import info, error, debug, logger, logString
from endian.core.modules import module_registry
from endian.core.i18n import setLanguage
from endian.emi.tg import view
from endian.emi.tg.controllers import register_expose_hook
from endian.emi.menu.profiles import check_access

turbogears.startup.view = view

__all__ = ['ConfigurationError',
           'EmiDaemon',
           'reload_language',
           'load_emi_module',
           'get_emi_modules',
           'setDebugLevel',
           ]


class ConfigurationError(Exception):
    pass

def _turbogears_server_start(emi):
    """ Start turbogears (CherryPy) with a custom file alteration monitor """
    from cherrypy import _cpwsgi
    from cherrypy._cpengine import STARTING

    env = {'start_again': False, 'startup_cwd': os.getcwd(), 'start_server': True }

    # Init cherrypy server
    cherrypy.root = emi.root
    cherrypy.server.httpserverclass = _cpwsgi.WSGIServer
    cherrypy.server.httpserver = _cpwsgi.WSGIServer()
    cherrypy.server.blocking = True
    cherrypy.server.state = STARTING
    cherrypy.server.interrupt = None

    # Setup autoreload
    if cherrypy.config.get('autoreload.on', False):
        from endian.core import alteration_monitor

        def _restart_turbogear(changed_modules):
            modules = set()
            for module in changed_modules:
                splitted_module = module.split('.')
                if len(splitted_module) >= 2 and splitted_module[0] == 'endian' and \
                    splitted_module[1] != 'emi' and splitted_module[1] != 'core':
                    modules.add('endian.%s' % splitted_module[1])
                else:
                    info(file)
                    modules.add('all')
            info("Changed modules: %s " % ",".join(modules))
            if 'all' in modules: # restart emi
                env['start_again'] = True
                cherrypy.server.stop()
            else: # reload the modules (without restarting emi) calling the command 'emi.reload'
                import urllib, urllib2
                host = cherrypy.config.get('server.socket_host') or "localhost"
                port = cherrypy.config.get('server.socket_port')
                for module in modules:
                    try:
                        args = { 'module': module, 'reload_all': False, 'session_id': emi.session_id }
                        reload_command = emi.reload_command
                        if not reload_command.startswith('/'):
                            reload_command = '/' + reload_command
                        # print "http://%s:%s%s?%s" % (host, port, reload_command, urllib.urlencode(args))
                        urllib2.urlopen("http://%s:%s%s" % (host, port, reload_command), urllib.urlencode(args))
                    except:
                        pass

        frequency = cherrypy.config.get('autoreload.frequency', 1)
        alteration_monitor.install_altertion_monitor(_restart_turbogear, frequency=frequency, debug=True, changed_modules_arg=True)

    # Start server
    while env['start_server']:
        env['start_server'] = False
        cherrypy.server._start()

    # If the server was interrupted by autoreload, restart the server
    if env['start_again']:
        info("Restarting...")
        import time
        time.sleep(1) # avoid "port is already in use"...
        args = sys.argv[:]
        args.insert(0, sys.executable)
        os.chdir(env['startup_cwd'])
        os.execv(sys.executable, args)


class EmiDaemon(Daemon):

    root = None
    emi_root = None # the default emi root is root.manage
    session_id = None # random id of this emi instance
    reload_command = "/manage/commands/commands.emi.reload/" # emi command used to reload the modules
    reload_check_session_id = False # if true, check the session_id before executing the reload command
                                    # this options prevents not-authorized user to reload emi modules

    def __init__(self, *args, **kargs):
        Daemon.__init__(self, *args, **kargs)
        self.session_id = os.urandom(32).encode('hex')

    def create_root_controller(self):
        """ Create the root controller """
        from endian.emi.controllers import RootController, ManageController
        self.root = RootController()
        self.root.manage = ManageController(path="/manage")
        self.emi_root = self.root.manage
        module_registry.emi_root = self.emi_root

    def register_commands(self):
        reload = lambda *argv, **kargs : self.reload(*argv, **kargs)
        reload.__doc__ = self.reload.__doc__
        register("commands.emi.reload", reload)
        register("commands.emi.reloadLanguage", reload_language)
        register("commands.emi.load_emi_module", load_emi_module)
        register("commands.emi.setDebugLevel", setDebugLevel)
        register("status.emi.modules", get_emi_modules)
        register("status.emi.commands", get_emi_commands)

    def instance_emi(self, options):
        import endian.core.i18n
        self._reload_emi = False
        self._reload_module = None
        self._reload_all = True

        # Registed an hook for checking permissions
        register_expose_hook(check_access)

        # Create the root controller
        self.create_root_controller()

        turbogears.config.update({'i18n.gettext': endian.core.i18n.translationWrapper})
        turbogears.config.update({
            # Set mako as the template engine
            'tg.defaultview': 'mako',
            # Mako 'Cant locate template for ...' workaround
            'mako.directories': [dir for dir in sys.path if os.path.isdir(dir)],
            # Mako custom filter to replace None with empy string
            'mako.default_filters': ["noneToEmptyString", "unicode"],
            'mako.imports': ['from endian.core.i18n import translationWrapper as _', 'from endian.emi.server.commands import noneToEmptyString']
        })

        # Module registry init
        options.ensure_value('excludemodules', '')
        module_registry.exclude_modules = options.excludemodules.split(',')
        debug("Modules to be excluded: %s" % module_registry.exclude_modules)
        options.ensure_value('exclude_families', None)
        module_registry.exclude_families = options.exclude_families and options.exclude_families.split(',') or []
        debug("Families to be excluded: %s" % module_registry.exclude_families)
        options.ensure_value('include_families', None)
        module_registry.include_families = options.include_families and options.include_families.split(',') or []
        debug("Families to be included: %s" % module_registry.include_families)

        # Register the emi commands
        self.register_commands()

        # Load modules manifest or init modules

        if turbogears.config.get('emi.lazy_load_modules'):
            module_registry.init_modules(subSystem='emi_manifest')

        else:
            module_registry.init_modules(subSystem='status')
            module_registry.init_modules(subSystem='web')

        turbogears.start_server(self.root)

    def do(self, options):
        Daemon.do(self)
        try:
            self.instance_emi(options)
            if self._reload_emi:
                self._reload_emi = False
                raise MainLoopExit
        except MainLoopExit:
            if self._reload_module and not self._reload_all:
                # Relaod the modules with name starting with 'endian.<MODULE_NAME>'
                modules_to_unload = [name for name in sys.modules if name and name.startswith('endian.%s' % self._reload_module)]
                module_registry.unload_modules(modules_to_unload=modules_to_unload)
            else:
                # Reload all the modules
                module_registry.unload_modules()
            # FIXME: Unload only the command loaded from unloaded modules, not all the commands
            import endian.core.commands
            endian.core.commands._REGISTRY.clear() # ugly :-(
            # Reload language
            reload_language()
            raise
        except ConfigurationError, exc:
            error("Could not launch EMI instance (%s)", exc)
            debug("Could not launch EMI instance", exc_info=True)
            sys.exit(1)

    def reload(self, module=None, reload_all=True, session_id=None):
        """
            Reloads EMI modules by re-instantiation.
            If a module is supplied in '''module''' and ''reload_all'' is False,
            only that EMI module will be re-instantiated.
            If omitted, the entire EMI will reloaded.

            :param module: Specifies the module to be reloaded
                Reload entire EMI if None.
            :type module: string
            :param reload_all: Force reloading all the modules,
                even if ''module'' is specified
            :type reload_all: bool
            :param session_id: EMI session ID
            :type session_id: string
        """
        if self.reload_check_session_id and self.session_id != session_id:
            from endian.emi.acl import NotAuthorizedError
            raise NotAuthorizedError()

        self._reload_emi = True
        self._reload_module = module
        if reload_all == None:
            reload_all = True
        self._reload_all = reload_all
        cherrypy.server.stop()
        return True


def reload_language():
    """ Reload the language settings and menu structure """
    # Reload language settings
    setLanguage()
    # Reload menu
    from endian.emi.menu import Menu
    Menu.is_dirty = True
    ret = "Language settings and menu structure reloaded"
    info(ret)
    return ret

def load_emi_module(module):
    """
    Force the loading of a emi modules (or a list of modules)
    :param module: The name of the module to be loaded or a coma-separated list of modules names or 'all' for loading all the available modules
    :type module: string
    """
    if module == 'all' or module == '*':
        modules = module_registry.available_modules()
    elif not module:
        modules = []
    else:
        modules = module.split(',')
    for module in modules:
        module_registry.init_module(module)
    return { 'loaded_modules': module_registry.loaded_modules() }

def get_emi_modules():
    """ Get the lists of the available and loaded emi modules """
    available_modules = module_registry.available_modules()
    loaded_modules = module_registry.loaded_modules()
    web = module_registry.web.items.keys()
    commands = module_registry.commands.items.keys()
    return { 'available_modules': available_modules,
             'loaded_modules': loaded_modules,
             'web': web,
             'commands': commands }

def get_emi_commands():
    """ Get the list of the available emi commands """
    return { 'commands': getRegistry(flat=True).keys() }

def setDebugLevel(level="DEBUG"):
    """
    Sets debug level of EMI to one of the following values:

    * DEVELDEBUG
    * DEBUG
    * INFO
    * WARNING
    * ERROR

    :param level: The debug level to be set.
    :type level: string
    """
    try:
        logger.setLevel(logString[level])
        ret = "Debug level set to '%s'" % level
        info(ret)
        return ret
    except KeyError:
        ret = "Invalid debug level '%s'" % level
        error(ret)
        raise Exception(ret)
