#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2011-11-09"

import UserDict
import commands
from endian.datatypes.network import CIDR

def find(l, s):
    try:
        return l.index(s)
    except ValueError:
        return None

def getkey(tok, key):
    try:
        return tok[tok.index(key)+1]
    except ValueError:
        return None

class Nic(UserDict.UserDict):
    """
    This class represents an "ip addr show" holding all
    necessary information of that output easily accessible with python

    the class is a dict with nic names as keys and the following
    data-structure as value:

    {
        'device': None,
        'inet': [CIDR, CIDR],
        'inet6': ['', ''],
        'remoteIp': None,
        'mac': None,
        'mtu': None,
        'flags': None,
        'state': None,
        'isPPP': False,
    }

    'device':   devicename
    'inet':     CIDR list of ip/bit pairs held by the device
    'inet6':    string list of ipv6 addresses held by the device
    'mac':      mac address of the device if it is an ethernet device
    'mtu':      the mtu value of the device
    'flags':    string represented flags of the device. example: 
                '<BROADCAST,MULTICAST,PROMISC,UP,LOWER_UP>'
    'state':    state of the device: UNKNOWN, UP, LOWERLAYERDOWN, etc
    'isPPP':    True if the device is a point-to-point device
    'remoteIP': holds remote ip in case of a ppp device

    The class contains also a field 'ipmap' which maps ip-addresses
    to the device items which are holding that ip-address

    """

    def __init__(self):
        self.data = {}
        self.ipmap = {}
        self.load()

    def load(self):
        cmd = "ip -o addr show"
        (status, data) = commands.getstatusoutput(cmd)
        if status != 0:
            return
        for line in data.split("\n"):
            line = line.strip()
            tok = line.split()
            dev = tok[1].strip().strip(":")
            dev = dev.split("@")[0]
            if dev not in self.data:
                self.data[dev] = {
                    'device': None,
                    'inet': [],
                    'inet6': [],
                    'remoteIp': None,
                    'mac': None,
                    'mtu': None,
                    'flags': None,
                    'state': None,
                    'isPPP': False,
                    }
            item = self.data[dev]
            item['device'] = dev

            if tok[1].endswith(":"):
                item['flags'] = tok[2]
                item['mtu'] = getkey(tok, "mtu")
                item['state'] = getkey(tok, "state")
                item['mac'] = getkey(tok, "link/ether")
                if item['flags'].startswith("<POINTOPOINT"):
                    item['isPPP'] = True
                continue

            remote = getkey(tok, "peer")
            if remote:
                item['remoteIp'] = CIDR(remote)

            ip = getkey(tok, "inet6")
            if ip:
                item['inet6'].append(ip)
                self.ipmap[ip] = item

            ip = getkey(tok, "inet")
            if ip:
                cidr = ip
                if cidr.find("/") == -1:
                    cidr += "/32"              
                ip = CIDR(cidr)
                item['inet'].append(ip)
                self.ipmap[cidr] = item


__all__ = [
    'Nic',
    ]

if __name__ == '__main__':
    a = Nic()
    import pprint
    pprint.pprint(a)

    pprint.pprint(filter(lambda x: x['isPPP'], a.values()))
