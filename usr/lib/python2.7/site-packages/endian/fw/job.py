#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2015 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2015-06-30"

import os
import copy
import shutil
import tempfile
import filecmp
from endian.core import logger
from endian.job.commons import Job, action, iptables, get_config, Template, send_cmd_to_engine
from endian.data.container.csvconfig import CsvConfigFile
from endian.datatypes.config_dict import ConfigDict
from endian.fw.substitutors import get_substitutor, LIST_SEPARATOR, AbstractMappingSubstitutor

LOG_SETTINGS = '/var/efw/logging/settings'

class NoSuitableSubstitution(Exception):
    pass

class GenericFirewallJob(Job):

    # Please initialize the following fields in subclass
    firewall_name = None
    chain = None
    explodable_fields = None
    substitutions = None

    tmpl = None # Don't change
    settings = None # Don't change
    script = None # Dont' change
    substitutors_cache = None # Don't change

    @property
    def _rules_path(self):
        """ Rules file path """
        return '/var/efw/' + self.firewall_name + '/config'

    @property
    def _rules_config_path(self):
        """ Rules config file path """
        return self._rules_path.replace('/var/efw/', '/usr/lib/efw/') + '.config',
    
    @property
    def _settings_path(self):
        """ Settings file path """
        return '/var/efw/' + self.firewall_name + '/settings'

    @property
    def _state_path(self):
        """ State file path """
        return '/etc/firewall/' + self.firewall_name + '/iptables' + self.firewall_name
    
    @property
    def _rule_template_path(self):
        """ Rule template file path """
        return '/etc/firewall/' + self.firewall_name + '/rules.tmpl'

    @property
    def _tmp_path(self):
        """ Temp file path """
        return '/var/tmp/iptable' + self.firewall_name

    @property
    def _needreload_path(self):
        """ Reload needed flagfile  path """
        return '/var/efw/' + self.firewall_name + '/needreload'

    def pre_sanitize_rule(self, item):
        """ This method is executed before sanitize_rule """
        pass

    def post_sanitize_rule(self, item):
        """ This method is executed after sanitize_rule """
        pass

    def sanitize_rule(self, item):
        """ 'Sanitize' a rule """
        self.pre_sanitize_rule(item)
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in = False
        item.physdev_out = False
        if item.src_dev.startswith('PHYSDEV'):
            item.physdev_in = True
            item.src_dev = item.src_dev.split(":")[1]
        item.logtarget = item.target
        if item.target == '':
            item.target = 'ACCEPT'
        item.ipsecin = False
        item.ipsecout = False
        if item.src_dev == 'ipsec+':
            item.src_dev = ''
            item.ipsecin = True
        self.post_sanitize_rule(item)
        # Source IP/Set
        if item.src_ip and item.src_ip.startswith('SET:'):
            item.src_set = item.src_ip.split(':')[1]
            item.src_ip = None
        else:
            item.src_set = None
        # Destinarion IP/Set
        if item.dst_ip and item.dst_ip.startswith('SET:'):
            item.dst_set = item.dst_ip.split(':')[1]
            item.dst_ip = None
        else:
            item.dst_set = None
        return item

    def insert_rule(self, obj, tmpl, log=False):
        methods = {}
        obj.log = log
        self.sanitize_rule(obj)
        # obj.physdev_out = False
        self.debug(str(obj))
        cmd = str(tmpl(namespaces = [obj, methods]))
        self.debug("Create rule nr %d: %s ", obj.i, cmd)
        return cmd.strip()

    def explode_rules(self, rule):
        if rule.enabled != 'on':
            return
        rules = []
        rules.append(rule)
        for field in self.explodable_fields:
            tmprules = []
            fieldval = getattr(rule, field)
            if fieldval == '':
                continue
            for value in fieldval.split(LIST_SEPARATOR):
                if value == '':
                    continue
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rule_number = len(rules)
        if rule_number > 1:
            self.debug("Exploded rules to %d", rule_number)
        return rules

    def get_substitutor_instance(self, fullname, constructor_args=None):
        """
        Get a substitutor intance by its name - store the intance in a cache
        If the substitutor instance does not exists, it will be initializated
        using the optional constructor args

        :param fullname: substitutor class full name
        :type fullname: str
        :param constructor_args: optional substitutor constructor args
        :type constructor_args: dict
        :return: substitutor instance
        :type: AbstractSubstitutor
        """
        if self.substitutors_cache is None:
            self.substitutors_cache = {}
        substitutor = self.substitutors_cache.get(fullname)
        if substitutor is None:
            args = { 'logger': logger }
            if constructor_args is not None:
                args.update(constructor_args)
            substitutor = get_substitutor(fullname)(**args)
            self.substitutors_cache[fullname] = substitutor
        return substitutor

    def apply_substitution(self, rule, field, substitutor):
        """
        Apply one substituton to a single rule value

        :param rule: rule
        :type rule:
        :param field: affected rule parameter
        :type field: string
        :param substitutor: substitutor 
        :type substitutor: AbstractSubstitutor
        """
        # Get the value and the substitutor function
        values = getattr(rule, field)
        substitute_values = getattr(substitutor, 'substitute_values', None)
        if not values or substitute_values is None:
            return
        # Substitute the values
        result = substitute_values(rule, values, self)
        if not result:
            self.debug("No suitable value found for substitution of '%s'" % values)
            raise NoSuitableSubstitution("No suitable value found for substitution")
        # Set the result
        setattr(rule, field, result)

    def apply_mapping_substitution(self, rule, substitutor):
        """
        Apply one mapping substituton

        :param rule: rule
        :type rule:
        :param substitutor: substitutor 
        :type substitutor: AbstractMultiSubstitutor
        """
        # Get the value and the substitutor function
        substitute_values = getattr(substitutor, 'substitute_values', None)
        if substitute_values is None:
            return
        # Substitute the values
        result = substitute_values(rule, self)
        if not result:
            self.debug("No suitable value found for substitution of '%s'" % str(rule))
            raise NoSuitableSubstitution("No suitable value found for substitution")
        for key, value in result.items():
            setattr(rule, key, value)

    def substitute_values(self, rule):
        """
        Apply all the substitutons to a single rule

        :param rule: rule
        :type rule: 
        :return: True in case of success, False otherwise
        :rtype: boolean
        """
        try:
            for substitution in self.substitutions:
                substitutor = self.get_substitutor_instance(substitution.get('substitutor'), substitution.get('constructor_args'))
                if isinstance(substitutor, AbstractMappingSubstitutor):
                    self.apply_mapping_substitution(rule, substitutor) 
                else:
                    self.apply_substitution(rule, substitution.get('field'), substitutor) 
            return True
        except NoSuitableSubstitution, ex:
            self.debug(str(ex))
            return False
        except Exception, ex:
            self.error(str(ex), exc_info=True)
            return False

    def satanize_rule(self, item):
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in=False
        item.physdev_out=False
        if item.src_dev.startswith('PHYSDEV'):
            item.physdev_in=True
            item.src_dev = item.src_dev.split(":")[1]
        if item.dst_dev.startswith('PHYSDEV'):
            item.physdev_out=True
            item.dst_dev = item.dst_dev.split(":")[1]
        item.logtarget = item.target
        if item.target == '':
            item.target = 'ACCEPT'
        item.bridge = False
        item.ipsecin = False
        item.ipsecout = False
        if item.src_dev == 'ipsec+':
            item.src_dev = ''
            item.ipsecin = True
        if item.dst_dev == 'ipsec+':
            item.dst_dev = ''
            item.ipsecout = True
        return item

    def get_rules(self):
        """
        Load the rules from a config file

        :return: a list of rules
        :rtype: list
        """
        rules = []
        if self.settings == None:
            self.load_config()
        self.debug("Read from '%s'" % self._rules_path)
        try:
            rules = CsvConfigFile(self._rules_config_path, self._rules_path, tolerant=True)
        except Exception:
            self.debug("Traceback: ", exc_info=True)
            self.error("Could not load config file '%s'!" % self._rules_path)
            return []
        return self.post_get_rules(rules)

    def post_get_rules(self, rules):
        """
        This method is executed after loading the rules

        :param rules: a list of rules
        :type rules: list
        :return: a list of rules
        :rtype: list
        """
        return rules

    def _compute_hash(self, rule):
        return hash(frozenset(rule.items()))

    def pre_generate_script(self, script):
        """ This method is executed before generating the script """
        pass

    def post_generate_script(self, script):
        """ This method is executed after generating the script """
        pass

    def generate_script(self):
        if self.settings == None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=self._tmp_path)
        self.pre_generate_script(script)
        i = 0
        self.debug("Generate iptables script")
        for rule in self.get_rules():
            i += 1
            rule.i = i
            # print self._compute_hash(rule) 
            if rule.enabled != 'on':
                continue
            log = (rule.log == 'on')
            if self.settings['LOG_ACCEPTS'] == 'on':
                if rule.target in ['ACCEPT', 'ALLOW']:
                    log = True
            if self.settings.get('DISABLE_FIREWALL_LOGS','off') == 'on':
                log = False
            # ICMP hack
            if rule.proto == 'icmp':
                   rule.dst_port = '8&30'
            if self.substitute_values(rule):
                for item in self.explode_rules(rule):
                    try:
                        script.write(self.insert_rule(item, self.tmpl, log))
                        script.write("\n")
                    except Exception:
                        self.debug("Explosion failed", exc_info=True)
                        continue
        self.post_generate_script(script)
        script.flush()
        return script

    def save_config(self):
        self.script = self.generate_script()
        if not os.path.exists(self._state_path):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, self._state_path, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed

    def dump_script(self):
        """
        Test method, return the generated script as a string
        """
        script = self.generate_script()
        script.seek(0)
        return script.read()

    def load_config(self):
        """
        Load the configration files and the rule template
        """
        self.settings = ConfigDict()
        self.settings.update(get_config(self._settings_path))
        self.settings.update(get_config(LOG_SETTINGS))
        self.tmpl = Template.compile(file=self._rule_template_path)

    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False        
        options['force'] = options.get('force', False)
        self.start(options)

    @action(name="start",
            depends=["firewall=start"],
            exit_status="start",
            on="startup_done",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces start."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def start(self, options):
        Job.start(self, options)       
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        self.load_config()

        if options.get('force'):
            self.info("Force restarting %s", self.firewall_name)
        else:
            self.info("Restarting %s", self.firewall_name)
        changed = self.save_config()

        if changed or options.get('force'):
            self.debug("Save script to state file '%s'" % self._state_path)
            shutil.copy(self.script.name, self._state_path)

            self.debug("Call iptables script %s" % self.script.name)
            iptables(script=self.script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()

        if os.path.exists(self._needreload_path):
            os.unlink(self._needreload_path)

        send_cmd_to_engine("event(msg:sync_ipsets)")

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)

    @action(name="firewall_restart", 
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart %s" % self.firewall_name)
        options['force'] = True
        self.start(options)

