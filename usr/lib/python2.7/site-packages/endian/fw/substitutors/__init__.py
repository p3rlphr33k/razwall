#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2015 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import os
import re
import glob
from endian.data import DataSource
from endian.core.pdict import ReadOnlyPersistentDict

__all__ = [
    'LIST_SEPARATOR',
    'get_substitutor',
    'AbstractSubstitutor',
    'AbstractMappingSubstitutor',
]

IP_PATTERN = re.compile("^(?:\d{1,3}\.){3}\d{1,3}(?:/\d{1,2})?$")
MAC_PATTERN = re.compile("^(?:[\da-fA-F]{2}:){5}[\da-fA-F]{2}$")
LIST_SEPARATOR = '&'
OPENVPN_CLIENT_DIR = '/var/efw/openvpnclients/'

def get_substitutor(fullname):
    """
        Get a subsitutor class by name

        :param fullname: name in the form 'module_name'.'class_name'
        :type fullname: str
    """
    try:
        module, name = fullname.rsplit('.', 1)
        module = __import__(module, None, None, [module])
        return getattr(module, name)
    except:
        raise KeyError(fullname)


class AbstractSubstitutor(object):

    log = None
    _uplink_pool = None
    _red_interface_cache = None
    _openvpn_device_cache = None

    def __init__(self, logger=None, list_separator="&"):
        """
        instantiates substitutor with following possible options:

        :param logger: instance to logger, which allows to have debug output
        :type logger: logger instance
        :param list_separator: defines list separator. if None, real list will be returned
        :type list_separator: string
        """
        self.logger = logger
        self.list_separator = list_separator

    def info(self, msg, *args, **kw):
        if self.logger:
            self.logger.info(msg, *args, **kw)

    def debug(self, msg, *args, **kw):
        if self.logger:
            self.logger.debug(msg, *args, **kw)

    def error(self, msg, *args, **kw):
        if self.logger:
            self.logger.error(msg, *args, **kw)

    def get_config(self, filename):
        """
            Reads a configuration file and returns a hash
        """
        from endian.core.settingsfile import SettingsFile
        filename = os.path.normpath(filename)
        if filename.startswith('/var/efw/'):
            filename = filename[9:]
        self.debug("Read settings file %s", filename)
        return SettingsFile(filename)

    def get_uplink_pool(self):
        """
            Return an UplinkPool instance
        """
        from uplinksdaemon.uplinks import UplinksPool
        if self._uplink_pool != None:
            return self._uplink_pool
        self._uplink_pool = UplinksPool()
        return self._uplink_pool

    def all_red_interfaces(self):
        if self._red_interface_cache is None:
            self._red_interface_cache = []
            try:
                for uplink in self.get_uplink_pool().getActiveUplinks():
                    if uplink.getSettings()['RED_TYPE'] == 'NONE':
                        continue
                    data = uplink.getData()
                    dev = data.get('INTERFACE')
                    if uplink.getSettings()['RED_TYPE'] == 'STEALTH':
                        if 'BRIDGE_PORT' in data:
                            dev = "PHYSDEV:%s" % data.get('BRIDGE_PORT')
                        else:
                            continue
                    self._red_interface_cache.append(dev)
            except:
                pass
        return self._red_interface_cache

    def get_interface_by_uplink(self, uplink):
        if uplink != 'ANY':
            ul = self.get_uplink_pool().get(uplink)
            if ul.getSettings()['RED_TYPE'] == 'NONE':
                return []
            dev = ul.getInterface()
            if dev != None:
                return [dev]
            return []
        else:
            return self.all_red_interfaces()

    @staticmethod
    def is_ipaddress(addr):
        """
            Checks if addr is and IP address

            :param addr: address to check
            :type  addr: string
            :return: True if the string is valid IP address
            :rtype: boolean
        """
        return IP_PATTERN.match(addr)

    @staticmethod
    def is_macaddress(addr):
        """
            Checks if addr is a MAC address

            :param addr: address to check
            :type  addr: string
            :return: True if the string is valid MAC address
            :rtype: boolean
        """
        return MAC_PATTERN.match(addr)

    def get_interface_by_openvpn_name(self, name):
        filename = os.path.join(OPENVPN_CLIENT_DIR, name, 'settings')
        if not os.path.exists(filename):
            return None
        conf = self.get_config(filename)
        if conf.get('DEVICE', '') == '':
            return None
        device = conf['DEVICE']
        if conf.get('ROUTETYPE', 'routed') == 'bridged':
            return "PHYSDEV:%s" % device
        return device

    def get_vpn_device(self, conn):
        if conn == 'ANY':
            ov = []
            # OpenVPN
            ov.extend(self.all_openvpn_interfaces())
            # IPSec/L2TP
            ov.append('ipsec+')
            ov.append('l2tp+')
            for device, bridged in self.get_purple_devices():
                if bridged:
                    device = 'PHYSDEV:%s' % device
                ov.append(device)
            return ov
        if conn == 'IPSEC':
            return ['ipsec+']
        if conn == 'L2TP':
            return ['l2tp+']
        if conn == 'SERVER': # OpenVPN servers (any)
            res = []
            for device, bridged in self.get_purple_devices():
                if bridged:
                    device = 'PHYSDEV:%s' % device
                res.append(device)
            if not res:
                self.error("No device found for openvpn server")
            return res
        if conn and conn.startswith('SERVER:'): # Single OpenVPN server
            res = []
            for device, bridged in self.get_purple_devices(server_name=conn.split(':', 1)[1]):
                if bridged:
                    device = 'PHYSDEV:%s' % device
                res.append(device)
            if not res:
                self.error("No device found for openvpn server")
            return res
        ret = []
        tap = self.get_interface_by_openvpn_name(conn)
        if tap != None:
            ret.append(tap)
        return ret

    def get_purple_devices(self, server_name=None):
        try:
            pd = ReadOnlyPersistentDict('/var/cache/var.efw.vpn.servers')
            servers = DataSource("openvpn").server or []
            purple_devices = set()
            for conf in servers:
                if not conf.get('enabled'):
                    continue
                if server_name is not None and server_name != conf.get('name'):
                    continue
                id_ = conf.get('id')
                if not id_:
                    continue
                purple_dev = pd.get(id_, {}).get('purple_devices') or []
                bridged = conf.get('bridged')
                for pdev in purple_dev:
                    purple_devices = purple_devices.union([(pdev, bridged)])
            return list(purple_devices)
        except Exception, e:
            self.error('error getting the list of PURPLE devices: %s', e)
            return []

    def all_openvpn_interfaces(self):
        if self._openvpn_device_cache != None:
            return self._openvpn_device_cache
        self._openvpn_device_cache = []
        for ov in glob.glob(os.path.join(OPENVPN_CLIENT_DIR, '*')):
            dev = self.get_interface_by_openvpn_name(os.path.basename(ov))
            if dev == None:
                continue
            self._openvpn_device_cache.append(dev)
        return self._openvpn_device_cache

    def substitute_values(self, rule, values, job):
        """
            Substitute the values

            :param rule: rule
            :type rule:
            :param values: '&'-separated values
            :type values: str
            :param job: firewall job instance
            :type job: Job
            :return: '&'-separated substituted values or (for mapping substitutors) a dict with key=field, value=values
            :rtype: str or dict
        """
        result = []
        for value in values.split(LIST_SEPARATOR):
            if value is not None:
                try:
                    value = self.process(value, rule)
                    if value is not None:
                        result.append(value)
                except Exception, ex:
                    self.error("Substitution failed: %s" % ex, exc_info=True)
        return LIST_SEPARATOR.join(result)

    def process(self, value):
        """
            Substitute a single value

            :param values: value
            :type values: str
            :return: substituted value
            :rtype: str
        """
        raise NotImplementedError


class AbstractMappingSubstitutor(AbstractSubstitutor):
    """
        In a mapping substitutors, substitute_values returns a dict instead of a string
    """

    def substitute_values(self, rule, job):
        """
            Substitute the values

            :param rule: rule
            :type rule:
            :param job: firewall job instance
            :type job: Job
            :return: a dict with key=field, value=values
            :rtype: dict
        """
        return rule
