#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2015-06-25"

from endian.fw.substitutors import AbstractSubstitutor

__all__ = [
    'SubstUplinkDev',
    'SubstAddressByInterface',
]

class SubstUplinkDev(AbstractSubstitutor):

    def process(self, value, rule=None, params=None):
        if not value.startswith('UPLINK:'):
            return value
        self.debug("Substitute UPLINK '%s'", value)
        uplink = value.split(':')[1]
        if uplink == '':
            self.debug("Key '%s' contains no value.", value)
            raise KeyError("Key '%s' contains no value." % value)
        devlist = self.get_interface_by_uplink(uplink)
        if len(devlist) <= 0:
            self.debug("Uplink '%s' has no Devices.", uplink)
            raise KeyError("Uplink '%s' has no Devices."%uplink)
        self.debug("Substituted UPLINK '%s' to: %s", value, devlist)
        return self.list_separator.join(devlist)


class SubstAddressByInterface(AbstractSubstitutor):

    def get_address_table(self):
        import subprocess
        import iplib

        if self._address_cache != None:
            return self._address_cache
        process = subprocess.Popen(['ip', '-o', 'addr', 'show'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        out, err = process.communicate()
        if process.returncode != 0:
            return None

        for line in out.split("\n"):
            tokens = line.split()
            if tokens[2] != 'inet':
                continue
            try:
                dev = tokens[1]
                if dev not in self._address_cache['dev']:
                    self._address_cache['dev'][dev] = []
                cidr = tokens[3]
                if cidr.find("/") == -1:
                    cidr = "%s/32"%tokens[3]
                ip = iplib.CIDR(cidr).get_ip().get()
                if ip in self._address_cache['dev'][dev]:
                    continue
                self._address_cache['dev'][dev].append(ip)
                self._address_cache['ip'][ip] = dev
            except:
                self.debug("Could not determine ip address of interface '%s'" % tokens[1], exc_info=True)
        return self._address_cache
    
    def get_addresses_by_interface(self, dev):
        t = self.get_address_table()
        return t['dev'][dev]

    def process(self, value, rule=None, params=None):
        if value.find(":") != -1:
            ip = value.split(":")[0]
            if self.is_ipaddress(ip):
                return ip
        return "&".join(self.get_addresses_by_interface(value))

