#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2011-11-08"

from endian.system.wtmp import Wtmp
from endian.system.nic import Nic
from endian.fw.substitutors import AbstractSubstitutor, LIST_SEPARATOR

DEVICEPREFIX="L2TPDEVICE"
IPPREFIX="L2TPIP"
PPPDEVICE="l2tp"

__all__ = [
    'SubstL2tpDevice',
    'SubstL2tpIp',
]

class SubstL2tpDevice(AbstractSubstitutor):
    """
        substitutes 'value', which is taken as a L2TPDEVICE:<username> string
        into the ppp interface name which the user actually uses.

        If the user is logged in multiple times, a '&' separated list of
        device names will be returned 
    """
    def __init__(self, logger=None, list_separator=LIST_SEPARATOR):
        """
        instantiates substitutor with following possible options:

        :param logger: instance to logger, which allows to have debug output
        :type logger: logger instance

        :param list_separator: defines list separator. if None, real list will
        be returned
        :type list_separator: string
        """
        AbstractSubstitutor.__init__(self, logger, list_separator)
        self.wtmp = None
        self._mapcache = {}
        self.pppdevice = PPPDEVICE

    def _lookup_wtmp_user(self, user):
        if user == 'ALL':
            return [self.pppdevice + "+"]
        if user not in self._mapcache:
            if self.wtmp is None:
                self.wtmp = Wtmp()
            devices = filter(lambda x: (x['loggedIn'] and 
                                        x['user'].__eq__(user) and 
                                        x['source'].startswith(self.pppdevice)),
                             self.wtmp)
            devices = list(set(map(lambda x: x['source'], devices)))
            self._mapcache[user] = devices
        return self._mapcache[user]

    def process(self, value, rule=None, params=None):
        if not value.startswith(DEVICEPREFIX+":"):
            if self.list_separator:
                return value
            else:
                return [value]
        username = value.split(':')[1]
        ret = self._lookup_wtmp_user(username)
        if not ret:
            raise KeyError("User '%s' not logged in" % username)
        self.debug("Substituted L2TP user '%s' into '%s'",
                   username,
                   ret)
        if self.list_separator:
            return self.list_separator.join(ret)
        else:
            return ret


class SubstL2tpIp(AbstractSubstitutor):
    """
        substitutes 'value', which is taken as a L2TPIP:<username> string
        into the ip address assigned to the l2tp user.

        If the user is logged in multiple times, a '&' separated list of
        device names will be returned 
    """
    def __init__(self, logger=None, list_separator=LIST_SEPARATOR):
        """
        instantiates substitutor with following possible options:

        :param logger: instance to logger, which allows to have debug output
        :type logger: logger instance
        :param list_separator: defines list separator. if None, real list will be returned
        :type list_separator: string
        """
        AbstractSubstitutor.__init__(self, logger, list_separator)
        self._devicegetter = SubstL2tpDevice(logger=logger, list_separator=None)
        self.iff = None
        self._mapcache = {}

    def _lookupDevice(self, device):
        if device not in self._mapcache:
            if self.iff is None:
                self.iff = Nic()
            if not self.iff[device]['isPPP']:
                return []
            self._mapcache[device] = [str(self.iff[device]['remoteIp'].address)]
        return self._mapcache[device]

    def process(self, value, rule=None, params=None):
        if not value.startswith(IPPREFIX+":"):
            if self.list_separator:
                return value
            else:
                return [value]
        username = value.split(':')[1]
        devices = self._devicegetter.process(DEVICEPREFIX+":"+username)
        ret = []
        for i in devices:
            if i.endswith("+"):
                continue
            ret.extend(self._lookupDevice(i))
        if not ret:
            raise KeyError("User '%s' not logged in" % username)

        self.debug("Substituted L2TP user '%s' to '%s'",
                   username,
                   ret)
        if self.list_separator:
            return self.list_separator.join(ret)
        else:
            return ret

