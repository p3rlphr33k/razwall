#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2015 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2015-07-02"

import re
import subprocess

__all__ = [
    'SET_TYPES',
    'list_sets',
    'create_set',
    'destroy_set',
    'destroy_sets',
    'flush_set',
    'flush_sets',
    'add_to_set',
    'remove_from_set',
    'create_set_list',
    'get_version',
]

SET_TYPES = [
    # The iphash set type uses a hash to store IP addresses where clashing is
    # resolved by double-hashing and, as a last resort, by dynamically growing the hash.
    # Same size network addresses can be stored in an iphash as well.
    'iphash',
    # The nethash set type also uses a hash to store CIDR netblocks,
    # which may be of different sizes. The same techique is used to avoid
    # clashes as at the iphash set type.
    'nethash',
    # The portmap set type uses a memory range, where each bit represents one port.
    # A portmap type of set can store up to 65535 ports.
    'portmap',
    # The ipmap set type uses a memory range, where each bit represents one IP address
    # and can store up to 65535 (B-class network) entries.
    # You can store same size network addresses in an ipset as well and an IP address
    # will be in the set if the network address it belongs to can be found in the set.
    'ipmap',
    # The macipmap set type uses a memory range, where each 8 bytes represents one
    # IP and a MAC addresses. A macipmap set type can store up to 65535 (B-class network)
    # IP addresses with MAC.
    'macipmap',
    # The iptree set type uses a tree to store IP addresses, optionally with timeout values.
    'iptree',
    'ipporthash',
    'ipportiphash',
    'ipportnethash',
    'iptreemap',
    'setlist',
]

def list_sets(prefix=None):
    """
    Get IPSets list 

    :param prefix: optional name prefix 
    :type prefix: str or list
    :return: a list of set names
    :rtype: list
    """
    result = []
    if prefix is not None and isinstance(prefix, basestring):
        prefix = [ prefix ]
    process = subprocess.Popen(['ipset', '--list'], stdout=subprocess.PIPE)
    out, err = process.communicate()
    for line in out.split('\n'):
        if line.startswith('Name:'):
            name = line[6:].strip()
            if prefix is None or [True for x in prefix if name.startswith(x)]:
               result.append(name)
    return result

def get_elements(prefix=None):
    """
    Get IPSets elements 

    :param prefix: optional name prefix 
    :type prefix: str or list
    :return: a dict with name as key and elements as value 
    :rtype: dict
    """
    result = {}
    if prefix is not None and isinstance(prefix, basestring):
        prefix = [ prefix ]
    process = subprocess.Popen(['ipset', '--list'], stdout=subprocess.PIPE)
    out, err = process.communicate()
    in_members = False
    for line in out.split('\n'):
        if line.startswith('Name:'):
            in_members = False
            name = line[6:].strip()
            elements = []
            if prefix is None or [True for x in prefix if name.startswith(x)]:
               result[name] = elements
        if in_members:
            if not line:
                in_members = False
            else:
                elements.append(line)
        if line.startswith('Members:'):
            in_members = True

    return result

def create_set(name, set_type='iphash', elements=None, ignore_errors=False):
    """
    Create a IPSet

    :param name: IPSet name 
    :type name: str
    :param set_type: set type (default: iphash)
    :type set_type: str
    :param elements: optional list of elements to be added to the set
    :type elements: list
    """
    if set_type not in SET_TYPES:
        raise ValueError('Invalid set type')
    process = subprocess.Popen(['ipset', '--create', name, set_type], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    if process.returncode != 0 and not ignore_errors:
        raise Exception(err)
    if elements is not None:
        for element in elements:
            add_to_set(name, element, ignore_errors=ignore_errors)

def destroy_set(name, ignore_errors=False):
    """
    Destroy an IPSet

    :param name: IPSet name 
    :type name: str
    """
    process = subprocess.Popen(['ipset', '--destroy', name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    if process.returncode != 0 and not ignore_errors:
        raise Exception(err)

def destroy_sets(prefix=None):
    """
    Destroy IPSets

    :param prefix: optional name prefix 
    :type prefix: str or list
    :return: list of deleted set names
    :rtype: list
    """
    result = []
    names = list_sets(prefix)
    for name in names:
        try:
            destroy_set(name)
            result.append(name)
        except:
            pass
    return result

def add_to_set(name, element, ignore_errors=False):
    """
    Add an element to an IPSet

    :param name: IPSet name 
    :type name: str
    :param element: element to be added 
    :type element: str
    """
    process = subprocess.Popen(['ipset', '--add', name, element], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    if process.returncode != 0 and not ignore_errors:
        raise Exception(err)

def remove_from_set(name, element, ignore_errors=False):
    """
    Remove an element to an IPSet

    :param name: IPSet name 
    :type name: str
    :param element: element to be added 
    :type element: str
    """
    process = subprocess.Popen(['ipset', '--del', name, element], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    if process.returncode != 0 and not ignore_errors:
        raise Exception(err)

def flush_set(name, ignore_errors=False):
    """
    Flush an IPSet

    :param name: IPSet name 
    :type name: str
    """
    process = subprocess.Popen(['ipset', '--flush', name], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    if process.returncode != 0 and not ignore_errors:
        raise Exception(err)

def flush_sets(prefix=None):
    """
    Flush IPSets

    :param prefix: optional name prefix 
    :type prefix: str or list
    :return: list of flushed set names
    :rtype: list
    """
    result = []
    names = list_sets(prefix)
    for name in names:
        try:
            flush_set(name)
            result.append(name)
        except:
            pass
    return result

def create_set_list(name, elements, ignore_errors=False):
    """
    Create a set list

    :param name: set list name
    :type name: str
    :param elements: list of set names
    :type elements: list
    """
    process = subprocess.Popen(['ipset', '--create', name, 'setlist', '--size', str(len(elements))], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    if process.returncode != 0 and not ignore_errors:
        raise Exception(err)
    for element in elements:
        add_to_set(name, element, ignore_errors=ignore_errors)

def get_version():
    """
    Return the IPSet version

    :return: ipset version, e.g. 4.5 or 6.20.1
    :rtype: str
    """
    process = subprocess.Popen(['ipset', '--version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = process.communicate()
    try:
        return re.match('^ipset v(.*),.*', out).group(1)
    except:
        return None

