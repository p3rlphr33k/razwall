#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2015 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2015-07-01"

import hashlib

__all__ = [
    'name_hash',
    'list_hash',
]

PREFIXES = {
    'OPENVPNUSER':     'O',
    'L2TPDEVICE':      'L',
    'UPLINK':          'U',
    'PHYSDEV':         'P',
    # unknow/no prefix 'N',
}

def name_hash(value):
    """
    Calculate the IPSet name for a given value

    Maximum IPSet name length is 31 characters.
    Name prefixes are converted to a single characted followed by '_'

    OPENVPNUSER:   -> O_
    L2TPDEVICE:    -> L_
    UPLINK:        -> U_
    PHYSDEV:       -> P_
    without prefix -> N_

    Example:
    > Original name:
    OPENVPNUSER:gw2
    > Conversion:
    O_gw2
    ^^^
    |||
    ||name(max 29 characters)
    |'_'
    prefix

    If name is longer than 29 characters, the conversion is the following:
    [lowercase prefix] + ':' + [first 13 characters of the name] + [16 characters hash]

    Example:
    > Original name:
    OPENVPNUSER:with_a_very_very_very_long_name
    > Conversion:
    o_with_a_very_vfRajuPQafKqDTr/i

    :param value: value to be hashed
    :type value: str
    :return: set name
    :rtype: str
    """
    try:
        prefix, label = value.split(':', 1)
        prefix = PREFIXES[prefix]
    except:
        prefix = 'N' # unknow/no prefix
        label = value.replace(':', '_')
    if len(label) <= 29: 
        return prefix + '_' + label
    else:
        prefix = prefix.lower()
        if prefix == 'N':
            h = hashlib.md5(value).digest().encode('base64')[:16]
        else:
            h = hashlib.md5(label).digest().encode('base64')[:16]
        label = label[:13]
        return prefix + '_' + label + h


def list_hash(prefix, value, list_separator='&'):
    if value is None:
        value = ''
    if hasattr(value, 'lower'): # is value a string?
        value = value.split(list_separator)
    # Order the list
    value = '&'.join(sorted(value))
    # Calculate the hash
    result = prefix + '_' + hashlib.md5(value).digest().encode('base64')
    return str(result[:31].replace('=', '').strip())

