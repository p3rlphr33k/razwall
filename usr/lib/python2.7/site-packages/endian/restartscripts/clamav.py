#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import shutil
import pwd
import grp
import glob
import os

from endian.data.ds import DataSource
from endian.job.commons import send_cmd_to_engine
from endian.job.commons import to_bool
from endian.job.commons import run
from endian.job.commons import remove_path
from endian.job.commons import require_enabled_service, unrequire_enabled_service
from endian.job.generic.servicejob import ServiceJob
from endian.job.job import function
try:
    from endian.core.redirect.enterprise import ValidityChecker
except ImportError:
    ValidityChecker = None
from endian.core import version
from endian.core.niclist import any_uplink_has_property


SIGNATURES = '/var/signatures/clamav/'
SIGNATURES_INIT = '/usr/share/clamav-init/'
DB_LIST = ['main', 'daily', 'bytecode', 'safebrowsing']
EICAR_FILE = "/usr/share/clamav-init/eicartest.ndb"


class ClamAVJob(ServiceJob):
    serviceName = 'clamd'
    settingsName = 'clamav'
    serviceCanReload = False
    job_groups = ["icapgroup"]

    configFiles = [
        {
            'file': "/etc/clamav/clamd.conf",
            'affects': serviceName,
            'onstop': True,
        },
        {
            'file': "/etc/clamav/freshclam.conf",
            'affects': 'nothing',
        },
        {
            'file': "/etc/logrotate.d/clamav",
            'affects': 'nothing',
        },
        {
            'file': "/etc/c-icap/virus_scan.d/clamd_mod.conf",
            'affects': 'icap',
            'onstop': True,
        },
        {
            'file': "/etc/squid/squid.conf.d/clamav.conf",
            # if this would affect squid we would have a loop
            # squid job calls icapgroup sync, so it waits
            # for this job to finish, so this should be ok.
            'affects': 'nothing',
            'onstop': True,
        },
    ]

    actions = {
        'icap': [
            {
                'name': 'icap',
                'type': 'job',
                'action': 'apply',
                'options': {'force': True}
            },
        ],
    }

    job_actions = {
        "start": {
            "options": {
                "debug": (bool, "Be more verbose."),
                "force": (bool, "Forces restart."),
            },
            "depends": ["system_accessible=start", "clamavcron=start"],
            "priority": 80,
            "use_notifications": True,
        },
        "restart": {
            "options": {
                "debug": (bool, "Be more verbose."),
                "force": (bool, "Forces restart."),
            },
            "depends": ["system_accessible=start", "clamavcron=start"],
            "use_notifications": True,
        },
    }

    def save_hook(self, options, changed):
        if not glob.glob("%s/*" % SIGNATURES):
            os.system("cp %s/* %s/" % (SIGNATURES_INIT, SIGNATURES))

        if self.config_values.get('S', {}).get('SAFEBROWSING') != 'on':
            remove_path('%s/safebrowsing.cvd' % SIGNATURES)
        disabled_dbs = self.config_values.get('S', {}).get('EXCLUDE_SIGNATURES', '').split(',')
        for db in disabled_dbs:
            remove_path('%s/%s.cvd' % (SIGNATURES, db))
        if os.path.exists(EICAR_FILE) and not os.path.exists(
                os.path.join(SIGNATURES, "eicartest.ndb")):
            shutil.copy(EICAR_FILE, SIGNATURES)
            uid = pwd.getpwnam("clamav").pw_uid
            gid = grp.getgrnam("clamav").gr_gid
            os.chown(os.path.join(SIGNATURES, "eicartest.ndb"), uid, gid)

    def stop_hook(self, options):
        send_cmd_to_engine(
            "stop clamavcron",
            options={"debug": options.get("debug")}
        )

    def restart_hook(self, options):
        send_cmd_to_engine(
            "start clamavcron",
            options={"debug": options.get("debug")}
        )

    @staticmethod
    def any_opt(datasource, opts):
        return any(map(lambda x: to_bool(x), [datasource.get(x) for x in opts]))

    def shouldstart_hook(self):
        ds = DataSource()
        ret = False

        try:
            cfg = ds.avengine.settings
        except:
            cfg = {}
        try:
            ds_proxy = ds.proxy.settings
        except:
            ds_proxy = {}
        try:
            ds_smtpscan = ds.smtpscan.settings
        except:
            ds_smtpscan = {}
        try:
            ds_p3scan = ds.p3scan.settings
        except:
            ds_p3scan = {}
        try:
            ds_frox = ds.frox.settings
        except:
            ds_frox = {}

        if cfg.get("AVENGINE_HTTP", "clamav") == "clamav" and \
                to_bool(ds_proxy.get("PROXY_ENABLED")) and to_bool(ds_proxy.get("ANTIVIRUS_ENABLED")):
            self.debug("ClamAV should start because of HTTP Proxy")
            ret = True
            self.debug("Implicitely enable ICAP Service")
            require_enabled_service("icap", self.settingsName)
        else:
            unrequire_enabled_service("icap", self.settingsName)

        if cfg.get("AVENGINE_SMTP", "clamav") == "clamav" and \
                to_bool(ds_smtpscan.get("SMTPSCAN_ENABLED")) and to_bool(ds_smtpscan.get("AV_ENABLED")):
            self.debug("ClamAV should start because of SMTP Proxy")
            return True

        elif cfg.get("AVENGINE_POP", "clamav") == "clamav" and \
                to_bool(ds_p3scan.get("CHECKVIRUS")) and \
                self.any_opt(ds_p3scan, ["P3SCAN_GREEN_ENABLE", "P3SCAN_BLUE_ENABLE", "P3SCAN_ORANGE_ENABLE"]):
            self.debug("ClamAV should start because of POP Proxy")
            return True

        elif cfg.get("AVENGINE_FTP", "clamav") == "clamav" and \
                self.any_opt(ds_frox, ["FROX_GREEN_ENABLE", "FROX_BLUE_ENABLE", "FROX_ORANGE_ENABLE"]):
            self.debug("ClamAV should start because of FTP Proxy")
            return True

        if not ret:
            self.debug("ClamAV should not start.")
        return ret

    @function(name="run_freshclam",
              async=True,  # This function is executed asynchronously
              options={"debug": (bool, "Be more verbose.")})
    def run_freshclam(self, options):
        self.info("%s run_freshclam", self.serviceName)
        if not version.is_community():
            try:
                vc = ValidityChecker()
                if vc.is_expired(use_grace=True):
                    self.info("License expired. Not updating signatures")
                    return
            except:
                pass
        if any_uplink_has_property("DISABLE_SIGNATURE_DOWNLOAD"):
            self.info("Some uplinks are disabled for signatures updates. Not updating signatures")
            return
        if self.config_values is None:
            self.load_config()

        disabled_dbs = self.config_values.get('S', {}).get('EXCLUDE_SIGNATURES', '').split(',')
        if self.config_values.get('S', {}).get('SAFEBROWSING') != 'on':
            disabled_dbs.append("safebrowsing")

        args = ["--update-db=%s" % i for i in DB_LIST if i not in disabled_dbs]
        cmd = "freshclam --quiet %s" % (" ".join(args))
        self.info("executing %s", cmd)
        run(cmd)
