#!/usr/bin/python
from endian.job.commons import *

#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2006 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

NETWORK_SETTINGS = "/var/efw/ethernet/settings"
AVENGINE_SETTINGS = "/var/efw/avengine/settings"

VAR = "/var/efw/frox/"
SETTINGS = VAR + "/settings"
TRANSPARENT_SOURCE_BYPASS = VAR + "/source_bypass"
TRANSPARENT_DESTINATION_BYPASS = VAR + "/destination_bypass"

ETC = "/etc/frox/"
FROX_CONF = "frox.conf"
FIREWALL = "/etc/firewall/inputfw/frox.conf"
PROXIES = "/etc/firewall/proxies/frox.conf"

LOGROTATE = "/etc/logrotate.d/frox" 

class FroxJob(Job):

    config_values = None
    _shouldstart = None
    
    def save_config(self):
        if self.config_values == None:
            self.load_config()
        changed = {}
        changed["xtaccess"] = write_config(FIREWALL+".tmpl",
                                           FIREWALL,
                                           self.config_values)
        changed["proxies"] = write_config(PROXIES+".tmpl",
                                          PROXIES,
                                          self.config_values)
        if not self.shouldstart():
            return changed
        write_config(LOGROTATE + ".tmpl",
                     LOGROTATE,
                     self.config_values)
        changed["frox"] = write_config(ETC+FROX_CONF+".tmpl",
                                       ETC+FROX_CONF,
                                       self.config_values)
        return changed

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        if options.get("onboot"):
            return EXIT_STATUS_STOP
        self.debug("Stopping frox")
        monit("stop frox", logger=self.logger)
        send_cmd_to_engine("restart clamav")
        send_cmd_to_engine("restart panda")
        send_cmd_to_engine("restart sophos")
        send_cmd_to_engine("restart setxtaccess")
        send_cmd_to_engine("restart setredirect")
        return EXIT_STATUS_STOP

    @action(name="restart",
            depends=["system_accessible=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        self.debug("Begin starting frox process")
        self.compatibility()
        changed = self.save_config()
        if not self.shouldstart():
            self.stop(options)
            return EXIT_STATUS_STOP

        if options.get('force', False):
            set_all_true(changed)
        reload_service("frox",
                       logger=self.logger,
                       changed=changed["frox"],
                       can_reload=False)

        send_cmd_to_engine("restart clamav")
        send_cmd_to_engine("restart panda")
        send_cmd_to_engine("restart sophos")
        if changed["xtaccess"] and not options.get('onboot', False):
            send_cmd_to_engine("restart setxtaccess")
        if changed["proxies"] and not options.get('onboot', False):
            send_cmd_to_engine("restart setredirect")
        return EXIT_STATUS_START

    @action(name="start",
            on="startup", 
            depends=["system_accessible=start"],
            exit_status="start",
            priority=90,
            options={"debug":(bool,"Be more verbose.")}
            )    
    def start(self, options):
        Job.start(self, options)
        options['force'] = True
        return self.restart(options)
        
    @function(name="shouldstart")
    def shouldstart(self, options={}):
        if self._shouldstart != None:
            return self._shouldstart
        if self.config_values == None:
            self.load_config()
        enabled = to_bool(self.config_values.get('FROX_GREEN_ENABLE',  'off'))
        enabled |= to_bool(self.config_values.get('FROX_BLUE_ENABLE',   'off'))
        enabled |= to_bool(self.config_values.get('FROX_ORANGE_ENABLE', 'off'))
        self._shouldstart = enabled
        return self._shouldstart
    
    def get_enabled_zones(self):
        if self.config_values == None:
            self.load_config()
        ret = []
        if to_bool(self.config_values.get('FROX_GREEN_ENABLE',  'off')):
            ret.append("GREEN")
        if to_bool(self.config_values.get('FROX_BLUE_ENABLE',   'off')):
            ret.append("BLUE")
        if to_bool(self.config_values.get('FROX_ORANGE_ENABLE', 'off')):
            ret.append("ORANGE")
        return ret
    
    def load_config(self):
        self.config_values = {}
        self.config_values.update(SettingsFile(NETWORK_SETTINGS))
        self.config_values.update(SettingsFile(SETTINGS))
        self.config_values.update(SettingsFile(AVENGINE_SETTINGS))
        
        self.config_values['ENABLED'] = self.shouldstart()
        self.config_values['TRANSPARENT_ZONES'] = self.get_enabled_zones()
        self.config_values['BYPASSRULES'] = get_bypasses(TRANSPARENT_SOURCE_BYPASS, TRANSPARENT_DESTINATION_BYPASS, logger=self.logger)
        if self.config_values.get('LOG_FIREWALL', 'off') == '1':
            self.config_values['LOG_FIREWALL'] = 'on'
        self.debug(self.config_values)
        self.config_values['DS'] = DataSource()

    @action(name="updatewizard",
            on="updatewizard",
            priority=50,
            exit_status=DONT_CHANGE_STATUS,
            options={"debug":(bool,"Be more verbose.")}
            )
    def updatewizard(self, options):
        self.info("Updatewizard frox")
        return self.restart(options)

    def compatibility(self):
        changed = False
        s = {}
        if os.path.exists(VAR + "/enable_green"):
            s['FROX_GREEN_ENABLE'] = 'on'
            changed = True
            os.unlink(VAR + "/enable_green")
        if os.path.exists(VAR + "/enable_blue"):
            s['FROX_BLUE_ENABLE'] = 'on'
            changed = True
            os.unlink(VAR + "/enable_blue")
        if os.path.exists(VAR + "/enable_orange"):
            s['FROX_ORANGE_ENABLE'] = 'on'
            changed = True
            os.unlink(VAR + "/enable_orange")
        if changed:
            sfile = SettingsFile(SETTINGS)
            sfile.update(s)
            sfile.write()
