#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2010 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import copy
import tempfile
import iplib
from endian.datatypes.network import CIDR
from endian.job.commons import *
from endian.data.container.csvconfig import CsvConfigFile
from endian.datatypes.config_dict import ConfigDict
from endian.validators.boolean import to_bool

CONFIGBASE='/var/efw/'
CHAIN='SOURCENAT'

SETTINGS='/var/efw/snat/settings'
CONFIG='/var/efw/snat/config'
ETHERNET_SETTINGS='/var/efw/ethernet/settings'
STATE='/etc/firewall/snat/iptablessnat'
TMPFILE="/var/tmp/iptablessnat"
OPENVPNDIR='/var/efw/openvpnclients/'
OPENVPN_SETTINGS='/var/efw/openvpn/settings'
NEEDRELOAD='/var/efw/snat/needreload'
LOG_SETTINGS='/var/efw/logging/settings'
HA_GLOBAL_SETTINGS='/var/efw/ha/settings_global'

TMPL='/etc/firewall/snat/rules.tmpl'

class SetSNAT(Job):

    tmpl = None
    settings = None
    script = None
    _addressCache = None
    _routingCache = {}
    _openvpnDevicesCache = None
    _redInterfacesCache = None
    _uplinkPool = None
    _openvpnIpsCache = None

    def insert_rule(self, obj, tmpl, log=False):
        methods = {}
        methods['getInterfaceByAddress'] = self.getInterfaceByAddress
        methods['getAddressByInterface'] = self.getAddressByInterface
        methods['getAddressOfExitingInterface'] = self.getAddressOfExitingInterface
        methods['getExitingInterface'] = self.getExitingInterface

        obj.log = log
        self.satanize_rule(obj)
        cmd = str(tmpl(namespaces = [obj, methods]))
        self.debug("Create rule nr %d: %s"%(obj.i, cmd))
        return cmd.strip()

    def explode_rules(self, line, explodefields):
        if line.enabled != 'on':
            return
        rules = []
        rules.append(line)
        for field in explodefields:
            tmprules = []
            fieldval = getattr(line, field)
            if fieldval == '':
                continue
            for value in fieldval.split('&'):
                if value == '':
                    continue
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rulenum = len(rules)
        if rulenum > 1:
            self.debug("Exploded rules to %d"%rulenum)
        return rules

    def getRemoteVPNNets(self, user):
        import openvpnutils
        ret = []
        userconf = openvpnutils.getUser(user)
        for net in userconf['remotenet'].split(","):
            net = net.strip()
            if net == '' or net == 'None':
                continue
            ret.append(net)
        return ret

    def allOpenvpnIPs(self):
        import openvpnutils.status
        if self._openvpnIpsCache is not None:
            return self._openvpnIpsCache
        self._openvpnIpsCache = {}
        try:
            for ipport, data in openvpnutils.status.Status().iteritems():
                ip = data['virtual_address']
                if ip == '':
                    continue
                if ip == '0/0':
                    continue
                user = data['user']

                if user in self._openvpnIpsCache:
                    # If the user if already in the cache (e.g. multiple logins), add only the remote IP
                    self._openvpnIpsCache[user].append(ip)
                else:
                    # Add the user remote IP and remote networks
                    self._openvpnIpsCache[user] = [ip]
                    try:
                        self._openvpnIpsCache[user].extend(self.getRemoteVPNNets(user))
                    except:
                        self.debug("OpenVPN user '%s' has no remote networks." % user)
        except:
            self.error("Error getting OpenVPN users addresses", exc_info=True)
        return self._openvpnIpsCache

    def getOpenvpnIPByUser(self, user):
        if self._openvpnIpsCache is None:
            self.allOpenvpnIPs()
        if user not in ['ANY', 'ALL']:
            return self._openvpnIpsCache.get(user) or []
        else:
            ret = []
            for user, net in self._openvpnIpsCache.iteritems():
                ret.extend(net)
            return ret
        return []

    def getUplinkPool(self):
        from uplinksdaemon.uplinks import UplinksPool
        if self._uplinkPool != None:
            return self._uplinkPool
        self._uplinkPool = UplinksPool()
        return self._uplinkPool

    def allRedInterfaces(self):
        if self._redInterfacesCache != None:
            return self._redInterfacesCache
        self._redInterfacesCache = []
        try:
            for uplink in self.getUplinkPool().getActiveUplinks():
                if uplink.getSettings()['RED_TYPE'] == 'NONE':
                    continue
                if uplink.getSettings()['RED_TYPE'] == 'STEALTH':
                    continue
                self._redInterfacesCache.append(uplink.getInterface())
        except:
            pass
        return self._redInterfacesCache

    def getInterfaceByUplink(self, uplink):
        if uplink != 'ANY':
            ul = self.getUplinkPool().get(uplink)
            if ul.getSettings()['RED_TYPE'] == 'NONE':
                return []
            if ul.getSettings()['RED_TYPE'] == 'STEALTH':
                return []
            dev = ul.getInterface()
            if dev != None:
                return [dev]
            return []
        else:
            return self.allRedInterfaces()

    def allOVPNInterfaces(self):
        if self._openvpnDevicesCache != None:
            return self._openvpnDevicesCache
        self._openvpnDevicesCache = []
        for ov in glob.glob(OPENVPNDIR+'/*'):
            dev = self.getInterfaceByOpenvpnName(os.path.basename(ov))
            if dev == None:
                continue
            self._openvpnDevicesCache.append(dev)
        return self._openvpnDevicesCache

    def getInterfaceByOpenvpnName(self, name):
        filename = os.path.join(OPENVPNDIR, name, 'settings')
        if not os.path.exists(filename):
            return None
        conf = get_config(filename)
        if conf.get('DEVICE', '') == '':
            return None
        device = conf['DEVICE']
        if conf.get('ROUTETYPE', 'routed') == 'bridged':
            return "PHYSDEV:%s"%device
        return device

    def get_purple_devices(self, server_name=None):
        try:
            from endian.core.pdict import PersistentDict
            pd = PersistentDict('/var/cache/var.efw.vpn.servers')
            servers = DataSource("openvpn").server or []
            purple_devices = set()
            for conf in servers:
                if not conf.get('enabled'):
                    continue
                if server_name is not None and server_name != conf.get('name'):
                    continue
                id_ = conf.get('id')
                purple_dev = pd.get(id_, {}).get('purple_devices') or []
                if id_ and purple_dev:
                    purple_devices = purple_devices.union(purple_dev)
            return list(purple_devices)
        except Exception, e:
            self.logger.error('error getting the list of PURPLE devices: %s', e)
            return []

    def getVPNDevice(self, conn):
        if self.settings == None:
            self.load_config()
        if conn == 'ANY':
            ov = []
            ov.extend(self.allOVPNInterfaces())
            ov.append('ipsec+')
            ov.append('l2tp+')
            ov.extend(['PHYSDEV:%s' % p for p in self.get_purple_devices()])
            return ov
        if conn == 'SERVER':
            return ['PHYSDEV:%s' % p for p in self.get_purple_devices()]
        if conn and  conn.startswith('SERVER:'):
            return ['PHYSDEV:%s' % p for p in self.get_purple_devices(server_name=conn.split(':', 1)[1])]
        if conn == 'IPSEC':
            return ['ipsec+']
        if conn == 'L2TP':
            return ['l2tp+']
        ret = []
        tap = self.getInterfaceByOpenvpnName(conn)
        if tap != None:
            ret.append(tap)
        return ret

    def substOpenvpnUser(self, user, rule=None):
        if not user.startswith('OPENVPNUSER:'):
            return user
        username = user.split(':', 1)[1]
        nets = self.getOpenvpnIPByUser(username)
        if len(nets) == 0:
            self.debug("Substitution of OPENVPNUSER '%s' failed. User unknown or not connected."%username)
            return None
        self.debug("Substitute OPENVPNUSER '%s' with '%s'."%(username, nets))
        return "&".join(nets)

    def substVPNDev(self, dev, rule=None):
        if not dev.startswith('VPN:'):
            return dev

        self.debug("Substitute VPN '%s'"%dev)
        openvpnconn = dev.split(':')[1]
        if openvpnconn == '':
            self.debug("Key '%s' contains no value."%dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.getVPNDevice(openvpnconn)
        if len(devlist) <= 0:
            self.debug("Connection '%s' has no Devices."%openvpnconn)
            raise KeyError("Connection '%s' has no Devices."%openvpnconn)
        self.debug("Substituted VPN '%s' to: %s"%(dev, devlist))
        return "&".join(devlist)

    def substUplinkDev(self, dev, rule=None):
        if not dev.startswith('UPLINK:'):
            return dev
        self.debug("Substitute UPLINK '%s'"%dev)
        uplink = dev.split(':')[1]
        if uplink == '':
            self.debug("Key '%s' contains no value."%dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.getInterfaceByUplink(uplink)
        if len(devlist) <= 0:
            self.debug("Uplink '%s' has no Devices."%uplink)
            raise KeyError("Uplink '%s' has no Devices."%uplink)
        self.debug("Substituted UPLINK '%s' to: %s"%(dev, devlist))
        return "&".join(devlist)

    def substZoneDev(self, value, rule=None):
        if self.settings == None:
            self.load_config()
        if value == 'ALL' or value == 'ANY' or value == '':
            return ''
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED']:
            return value
        self.debug("Substitute ZONE '%s'"%value)
        if value != 'RED':
            dev = self.settings["%s_DEV"%value]
            self.debug("Substituted ZONE '%s' to: %s"%(value, dev))
            return dev
        return None

    def substAddressByInterface(self, value, rule=None):
        if is_ipaddress(value):
            return value
        return self.getAddressByInterface(value)

    def getRoutingInformation(self, ip):
        dev = self._routingCache.get(ip, None)
        if dev != None:
            return dev
        cmd = "ip -o route get %s"%ip
        (status, data) = commands.getstatusoutput(cmd)
        if status != 0:
            self.debug("Could not call '%s'. Command exit with %s"%(cmd, status))
            raise Exception("ip route get failed")
        srcip = None
        dev = None
        prevtoken = ""
        for token in data.split():
            if prevtoken == "src":
                srcip = token
            if prevtoken == "dev":
                dev = token
            prevtoken = token
        self._routingCache[ip] = (srcip, dev)
        self.debug("Store interface %s for ip %s in cache"%(srcip, ip))
        return (srcip, dev)

    def getAddressOfExitingInterface(self, ip):
        return self.getRoutingInformation(ip)[0]

    def getExitingInterface(self, ip):
        return self.getRoutingInformation(ip)[1]

    def getAddressTable(self):
        if self._addressCache != None:
            return self._addressCache
        cmd = "ip -o addr show"
        (status, data) = commands.getstatusoutput(cmd)
        if status != 0:
            return None
        self._addressCache = {'dev':{}, 'ip':{}}

        for line in data.split("\n"):
            tokens = line.split()
            if tokens[2] != 'inet':
                continue
            try:
                dev = tokens[1]
                cidr = tokens[3]
                if cidr.find("/") == -1:
                    cidr = "%s/32"%tokens[3]
                ip = iplib.CIDR(cidr).get_ip().get()

                # if HA is enabled, check if ip is HA management ip, then skip it. that's not the primary ip.
                if self.settings['HA_ENABLED']:
                    try:
                        ha_net = CIDR(self.settings.get('HA_MANAGEMENT_NET', ''))
                        if ip in ha_net:
                            continue
                    except ValueError:
                        pass

                self._addressCache['ip'][ip] = dev
                if self._addressCache['dev'].get(dev, None) != None:
                    continue
                self._addressCache['dev'][dev] = ip
            except:
                self.debug("Could not determine ip address of interface '%s'"%tokens[1], exc_info=True)
        return self._addressCache

    def getAddressByInterface(self, dev):
        t = self.getAddressTable()
        return t['dev'][dev]

    def getInterfaceByAddress(self, ip):
        t = self.getAddressTable()
        return t['ip'][ip]

    def substIter(self, values, cb, rule=None, delimiter='&'):
        if not values:
            return values
        if cb == None:
            return values
        ret = ''
        empty = True
        for i in values.split(delimiter):
            if i == None:
                continue
            value=None
            try:
                value = cb(i, rule)
            except:
                self.debug("Substitution failed", exc_info=True)
                continue
            if value == None:
                continue
            ret+=delimiter+value
            empty=False
        if empty:
            self.debug("No suitable value found for substitution of '%s'"%values)
            raise Exception("No suitable value found for substitution")
        if ret == '':
            return ''
        return ret[1:]

    def substitute_values(self, rule):
        try:
            rule.dst_dev = self.substIter(rule.dst_dev, self.substVPNDev, rule)
            rule.dst_dev = self.substIter(rule.dst_dev, self.substUplinkDev, rule)
            rule.dst_dev = self.substIter(rule.dst_dev, self.substZoneDev, rule)
            rule.dst_dev = self.substIter(rule.dst_dev,
                                          self.substL2tpDevice.process,
                                          rule)
            rule.src_ip = self.substIter(rule.src_ip, self.substOpenvpnUser, rule)
            rule.src_ip = self.substIter(rule.src_ip,
                                         self.substL2tpIp.process,
                                         rule)
            rule.dst_ip = self.substIter(rule.dst_ip, self.substOpenvpnUser, rule)
            rule.snat_to = self.substIter(rule.snat_to, self.substVPNDev, rule)
            rule.snat_to = self.substIter(rule.snat_to, self.substUplinkDev, rule)
            rule.snat_to = self.substIter(rule.snat_to, self.substZoneDev, rule)
            rule.snat_to = self.substIter(rule.snat_to,
                                          self.substL2tpDevice.process,
                                          rule)
            rule.snat_to = self.substIter(rule.snat_to, self.substAddressByInterface, rule)
        except:
            self.debug("Substitution failed", exc_info=True)
            return None
        return rule

    def satanize_rule(self, item):
        if item.target == '':
            item.target = 'SNAT'
        if item.src_ip == '':
            item.src_ip = '0/0'
        if item.dst_ip == '':
            item.dst_ip = '0/0'
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in=False
        item.physdev_out=False
        if item.dst_dev.startswith('PHYSDEV'):
            item.physdev_out=True
            item.dst_dev = item.dst_dev.split(":")[1]
        item.ipsecin = False
        item.ipsecout = False
        if item.dst_dev == 'ipsec+':
            item.dst_dev = ''
            item.ipsecout = True
        return item

    def getRules(self):
        ret = []
        self.debug("Read from '%s'"%CONFIG)
        try:
            rules=CsvConfigFile(
                '/usr/lib/efw/snat/config.config',
                CONFIG,
                tolerant=True,
                )
            ret.extend(rules)
        except Exception, e:
            self.error("Could not load config file '%s', because: %s!"%(CONFIG, e))
        return ret

    def generate_script(self):
        if self.settings == None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE)
        
        i = 0
        self.debug("Generate iptables script")
        script.write(("iptables -t nat -F %s\n") % CHAIN)
        for rule in self.getRules():
            i += 1
            rule.i = i
            if rule.enabled != 'on':
                continue
            log = (rule.log == 'on')
                # ICMP hack
            if self.settings.get('DISABLE_FIREWALL_LOGS','off') == 'on':
                log = False
            if rule.proto == 'icmp':
                   rule.dst_port = '8&30'
            if self.substitute_values(rule) == None:
                continue
            for item in self.explode_rules(rule, ['proto', 'src_ip', 'dst_ip', 'dst_port', 'dst_dev']):
                try:
                    script.write(self.insert_rule(item, self.tmpl, log))
                    script.write("\n")
                except Exception, e:
                    self.debug("Explosion failed", exc_info=True)
                    continue
        script.flush()
        return script

    def save_config(self):
        self.script = self.generate_script()
        if not os.path.exists(STATE):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, STATE, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed

    def load_config(self):
        from endian.firewall.substitutors.l2tp import SubstL2tpDevice
        from endian.firewall.substitutors.l2tp import SubstL2tpIp
        DS = DataSource()
        self.settings = get_config(SETTINGS)
        self.settings.update(get_config(ETHERNET_SETTINGS))
        self.settings.update(get_config(LOG_SETTINGS))
        self.settings.update(get_config(HA_GLOBAL_SETTINGS))
        try:
            self.settings['HA_ENABLED'] = to_bool(DS.HA.SETTINGS.HA_ENABLED)
        except:
            self.settings['HA_ENABLED'] = False
        self.tmpl = Template.compile(file=TMPL)
        self.substL2tpDevice = SubstL2tpDevice(self.logger)
        self.substL2tpIp = SubstL2tpIp(self.logger)
    
    @action(name="restart", 
            depends=["firewall=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False        
        options['force'] = options.get('force', False)
        self.start(options)
        
    @action(name="start",
            depends=["firewall=start"],
            exit_status="start",
            on="startup_done",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces start."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )
    def start(self, options):
        Job.start(self, options)
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        self.load_config()

        self.info("Restart SNAT firewall, force: %s", options.get('force'))
        changed = self.save_config()
    
        if changed or options.get('force'):
            self.debug("Save script to state file '%s'"%STATE)
            shutil.copy(self.script.name, STATE)
    
            self.debug("Call iptables script %s" % self.script.name)
            iptables(script=self.script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()
        
        if os.path.exists(NEEDRELOAD):
            os.unlink(NEEDRELOAD)

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)

    @action(name="firewall_restart", 
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart setsnat")
        options['force'] = True
        self.start(options)
