#!/usr/bin/python
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2016 Endian S.p.A. <info@endian.com>                       |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import iplib
import glob
from endian.core.zones import getZones
from endian.core.settingsfile import SettingsFile
from endian.data import DataSource
from endian.job.job import Job, action, function
from endian.job.engine_control import EXIT_STATUS_START, EXIT_STATUS_STOP
from endian.job.commons import (
    DONT_CHANGE_STATUS,
    write_config,
    touch,
    chown,
    chgrp,
    to_bool,
    get_config,
    file_exists,
    write_file_content,
    monit,
    send_cmd_to_engine,
    set_all_true,
    reload_service )

NETWORK_SETTINGS     = '/var/efw/ethernet/settings'
NETWORK_SETTINGS_OLD = '/var/efw/ethernet/settings.old'
VAR                  = '/var/efw/dhcp/'
SETTINGS             = '/var/efw/dhcp/settings'
FIXLEASES            = '/var/efw/dhcp/fixleases'
HA_NODES_DIR         = '/var/efw/ha/nodes/'
HA_GLOBAL_SETTINGS   = '/var/efw/ha/settings_global'
SERVICE_CONF         = '/etc/dhcpd.conf'
SERVICE_TPL          = '/etc/dhcpd.conf.tmpl'
SYSCONFIG            = '/etc/sysconfig/dhcpd'
SYSCONFIG_TPL        = '/etc/sysconfig/dhcpd.tmpl'
FIREWALL             = '/etc/firewall/inputfw/dhcpd.conf'
FIREWALL_TPL         = '/etc/firewall/inputfw/dhcpd.conf.tmpl'
LEASEFILE            = '/var/lib/dhcp/dhcpd.leases'
GREEN_DHCP_CLIENT    = '/etc/rc.d/event_first_startup_done.d/99greendhclient'
BR0_SETTINGS         = '/var/efw/ethernet/br0'
NOBODY               = 'nobody'
NOGROUP              = 'nogroup'

class DhcpJob(Job):

    config_values = None

    def save_config(self):
        # If the network associated to a zone is changed, update the gateway IP, DNS, etc...
        self.actualize_subnets()
        # Save the config files
        changed = {}
        if self.config_values == None:
            self.load_config()
        changed['firewall'] = write_config(FIREWALL_TPL, FIREWALL, self.config_values, alter_config = self.alter_config)
        changed['service'] = write_config(SYSCONFIG_TPL, SYSCONFIG, self.config_values, alter_config = self.alter_config)
        changed['service'] |= write_config(SERVICE_TPL, SERVICE_CONF, self.config_values, alter_config = self.alter_config)
        if not os.path.exists(LEASEFILE):
            touch(LEASEFILE)
        return changed

    def empty_zone(self):
        ret = {
            'NETADDRESS' : '',
            'BROADCAST' : '',
            'NETMASK' : '',
            'START_ADDR' : '',
            'END_ADDR' : '',
            'DOMAINNAME' : '',
            'ADDRESS' : '',
            'DNS' : '',
            'DNS1' : '',
            'DNS2' : '',
            'NTP' : '',
            'NTP1' : '',
            'NTP2' : '',
            'NETBIOS' : '',
            'WINS1' : '',
            'WINS2' : '',
            'DEFAULT_LEASE_TIME' : '',
            'MAX_LEASE_TIME' : '',
            'DEV' : '',
            'GATEWAY' : '',
            'DISABLE_WPAD': False,
            }
        return ret

    def alter_config(self, config_values):
        zones = {}
        for zone in self.config_values['ENABLED_ZONES']:
            if to_bool(config_values.get('ENABLE_%s' % zone)):
                zones[zone] = self.get_zone_values(zone, config_values)
        # Update the ADDRESS,NETADDRESS,NETMASK according to the START/END_ADDR
        # (this is necessary for using DHCP on a secondary subnet)
        for zone in zones.values():
            if zone.get('START_ADDR') and zone.get('IPS'):
                for net in [iplib.CIDR(x) for x in zone['IPS'].split(',')]:
                    if zone['START_ADDR'] in net:
                        zone['ADDRESS'] = net.get_ip().get_dot()
                        zone['NETADDRESS'] = net.network_ip.get_dot()
                        zone['NETMASK'] = net.get_netmask().get_dot()
                        break
        config_values['zones'] = zones
        return config_values

    def get_zone_values(self, zone, config_values):
        ret = self.empty_zone()
        if not zone:
            return ret
        ret['KEY'] = zone

        # copy values from ethernet settings
        for key in self.config_values['NETWORK_SETTINGS']:
            if key.startswith(zone):
                newkey = key[len(zone+'_'):]
                ret[newkey] = self.config_values['NETWORK_SETTINGS'][key]

        # copy values from dhcp settings
        for key in config_values:
            if key.endswith(zone):
                newkey = key[:len(key)-len('_'+zone)]
                ret[newkey] = config_values[key]

        ret['DEFAULT_LEASE_TIME'] = int(ret['DEFAULT_LEASE_TIME']) * 60 # convert minutes to seconds
        ret['MAX_LEASE_TIME'] = int(ret['MAX_LEASE_TIME']) * 60 # convert minutes to seconds

        proxy_settings = self.config_values['PROXY_SETTINGS']
        ret['DISABLE_WPAD'] = True
        if proxy_settings.get('PROXY_ENABLED') == 'on' and \
                proxy_settings.get('PROXYPAC_%s_ENABLED' % zone) == 'on' or \
                (proxy_settings.get('PROXYPAC_%s_ENABLED' % zone) == 'auto' and \
                proxy_settings.get('PROXYPAC_DHCP_WPAD_%s' % zone) == 'on' and \
                proxy_settings.get('%s_ENABLED' % zone) not in ('transparent', 'tproxy')):
            ret['DISABLE_WPAD'] = False
        return ret

    def actualize_subnets_zone(self, zone):
        # Check if the zone address is changed
        changed = False
        gateway_address = self.config_values['NETWORK_SETTINGS']['%s_ADDRESS' % zone]
        if self.config_values['NETWORK_SETTINGS']['%s_IPS' % zone] != self.config_values['OLD_NETWORK_SETTINGS']['%s_IPS' % zone]:
            # Update the DNS, NTP, and GATEWAY
            old_gateway_address = self.config_values['OLD_NETWORK_SETTINGS']['%s_ADDRESS' % zone]
            if gateway_address != old_gateway_address:
                for key in ['DNS1', 'DNS2', 'NTP1', 'NTP2', 'GATEWAY']:
                    key = '%s_%s' % (key, zone)
                    if self.config_values.get(key) == old_gateway_address:
                        self.config_values[key] = gateway_address
                        changed = True

        # Check if gateway and dns address are present
        for key in ['DNS1', 'GATEWAY']:
            key = '%s_%s' % (key, zone)
            if not self.config_values.get(key):
                self.config_values[key] = gateway_address
                changed = True

        # Check if the start/end address are in the zone
        if self.config_values['START_ADDR_%s' % zone] and \
                not [True for x in (self.config_values['NETWORK_SETTINGS']['%s_IPS' % zone] or '').split(',') if self.config_values['START_ADDR_%s' % zone] in iplib.CIDR(x)]:
            self.config_values['START_ADDR_%s' % zone] = ''
            changed = True
        if self.config_values['END_ADDR_%s' % zone] and \
                not [True for x in (self.config_values['NETWORK_SETTINGS']['%s_IPS' % zone] or '').split(',') if self.config_values['END_ADDR_%s' % zone] in iplib.CIDR(x)]:
            self.config_values['END_ADDR_%s' % zone] = ''
            changed = True

        # Calculate the start/end addresses
        if not self.config_values['START_ADDR_%s' % zone] or not self.config_values['END_ADDR_%s' % zone]:
            try:
                cidr = iplib.CIDR(gateway_address + '/' + self.config_values['NETWORK_SETTINGS'].get('%s_CIDR' % zone))
                first = cidr.get_first_ip()
                last = cidr.get_last_ip() - 1
                net_address = iplib.IPv4Address(gateway_address)
                if first <= net_address <= last:
                    if net_address - first > last - net_address:
                        last = net_address - 1
                    else:
                        first = net_address + 1
                self.config_values['START_ADDR_%s' % zone] = str(first)
                self.config_values['END_ADDR_%s' % zone] = str(last)
                changed = True
            except:
                self.error('Error calculation default start/end addresses', exc_info=True)
        self.debug('actualize_subnets_zone zone: %s changed: %s', zone, changed)
        return changed

    @function(name="actualize_subnets")
    def actualize_subnets(self, options=None):
        """ If the network associated to a zone is changed, update the gateway IP, DNS, etc... """
        if self.config_values == None:
            self.load_config()
        changed = False
        for zone in self.config_values['ENABLED_ZONES']:
            if self.actualize_subnets_zone(zone):
                changed = True
        # Write the modified settings file
        if changed and os.path.exists(SETTINGS):
            settings = SettingsFile(SETTINGS)
            for key in settings:
                settings[key] = self.config_values[key]
            settings.write()
            chown(SETTINGS, NOBODY)
            chgrp(SETTINGS, NOGROUP)
        return changed and 'Config updated' or 'OK'

    def shouldstart(self):
        if self.config_values == None:
            self.load_config()
        if  not to_bool(self.config_values.get('ENABLE_GREEN','off')) and \
            not to_bool(self.config_values.get('ENABLE_BLUE','off')) and \
            not to_bool(self.config_values.get('ENABLE_ORANGE','off')):
            return False
        if to_bool(self.config_values.get('HA_ENABLED', 'off')) and \
                self.config_values['HA_STATE'] == 'slave' and \
                self.config_values['HA_NODE'] != self.config_values['DHCP_SLAVE_NODE']:
            self.info("HA slave node, which should not start DHCP instance")
            return False
        return True

    def load_config(self, force_enable_green=False):
        self.config_values = {}
        self.config_values['ENABLED_ZONES'] = [x.upper() for x in getZones().keys()]
        self.config_values['NETWORK_SETTINGS'] = get_config(NETWORK_SETTINGS)
        self.config_values['OLD_NETWORK_SETTINGS'] = get_config(NETWORK_SETTINGS)
        if file_exists(NETWORK_SETTINGS_OLD):
            self.config_values['OLD_NETWORK_SETTINGS'].update(get_config(NETWORK_SETTINGS_OLD))
        self.config_values.update(SettingsFile(SETTINGS))
        if force_enable_green:
            self.config_values['ENABLE_GREEN'] = 'on'

        # If the Hotspot is enabled, disable the DHCP on blue
        try:
            if to_bool(DataSource().hotspot.settings.HOTSPOT_ENABLED):
                self.config_values['ENABLED_ZONES'].remove('BLUE')
        except:
            pass

        # Proxy
        self.config_values['PROXY_SETTINGS'] = DataSource("proxy").settings or {}

        # High availability
        self.config_values.update(SettingsFile(HA_GLOBAL_SETTINGS))
        self.config_values.update(DataSource("ha").settings)
        if to_bool(self.config_values.get('HA_ENABLED')):
            self.config_values.update(self.calculate_ha_slave())
            self.config_values.update(self.calculate_ha_management_net())

        self.config_values['ENABLED'] = self.shouldstart()

        # Fixed leases
        self.config_values['FIXEDLEASES'] = [x for x in DataSource().dhcp.fixleases if to_bool(x.get('enabled'))]
        return self.config_values

    def calculate_ha_slave(self):
        if self.config_values == None:
            self.load_config()
        ret = {}
        self.config_values['IS_FAILOVER'] = False
        if not to_bool(self.config_values.get('HA_ENABLED', 'off')):
            return ret
        master = self.config_values['HA_MASTER_NODE']
        nodes = glob.glob(HA_NODES_DIR+'*')
        nodes = [os.path.basename(x) for x in nodes]
        nodes.remove(master)
        if len(nodes) <= 0:
            self.debug("HA configured, but no slaves available")
            return ret
        slave_node = nodes[0]
        self.debug("First slave node is: %s", slave_node)

        slave = SettingsFile(HA_NODES_DIR + slave_node)
        self.config_values['DHCP_SLAVE_NODE'] = slave_node
        self.config_values['DHCP_SLAVE_IP'] = slave['NODE_IP']
        if slave_node:
            # ENTERPRISE-249 - Check if there is a configured zone with the ONLY_FIXEDLEASE disabled
            if [x for x in self.config_values['ENABLED_ZONES'] if not to_bool(self.config_values.get('ONLY_FIXEDLEASE_%s' % x))]:
                self.config_values['IS_FAILOVER'] = True
        return ret

    def calculate_ha_management_net(self):
        if self.config_values == None:
            self.load_config()
        try:
            m = {'NETADDRESS' : '',
                 'NET' : '',
                 'DEV' : '',
                 'NETMASK' : '',
                 'CIDR' : '',
                 }
            ret = {'HA_MANAGEMENT' : m}
            if not to_bool(self.config_values.get('HA_ENABLED', 'off')):
                return ret
            self.debug("Calculate HA management network values")
            m['DEV'] = self.config_values['HA_MANAGEMENT_PORT']
            m['NET'] = self.config_values['HA_MANAGEMENT_NET']

            cidr = iplib.CIDR(m['NET'])
            m['CIDR'] = cidr.get_netmask().get_bits()
            m['NETMASK'] = cidr.get_netmask().get()
            m['NETADDRESS'] = cidr.get_network_ip().get()
            return ret
        except:
            self.error("Invalid HA management network configuration", exc_info=True)
            return {}

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        if options.get("onboot"):
            return EXIT_STATUS_STOP
        self.debug("Stopping dhcpd...")
        monit("stop dhcpd", logger=self.logger)
        send_cmd_to_engine("restart setxtaccess")
        return EXIT_STATUS_STOP

    @action(name="restart",
            depends=["system_accessible=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "force_enable_green":(bool,"Force enable dhcp on GREEN.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        if self.config_values == None:
            self.load_config(force_enable_green=options.get('force_enable_green', False))
        if not self.shouldstart():
            self.stop(options)
            self.debug("dhcp should not start. Don't start dhcp")
            return EXIT_STATUS_STOP
        changed = self.save_config()
        if options.get('force', False):
            set_all_true(changed)
        reload_service("dhcpd",
                       logger=self.logger,
                       can_reload=False,
                       changed=changed['service'])
        if not options.get('onboot', False):
            if changed['firewall'] or changed['service']:
                send_cmd_to_engine("restart setxtaccess")
        return EXIT_STATUS_START

    @action(name="start",
            on="startup",
            depends=["system_accessible=start"],
            exit_status="start",
            priority=90,
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart.")}
            )
    def start(self, options):
        Job.start(self, options)
        # force restart on start especially on boot
        options['force'] = True
        return self.restart(options)

    @action(name="updatewizard",
            on="updatewizard",
            priority=50,
            exit_status=DONT_CHANGE_STATUS,
            options={"debug":(bool,"Be more verbose.")}
            )
    def updatewizard(self, options):
        self.info("Updatewizard dhcp")
        options['force'] = True
        return self.restart(options)

    @action(name="first_startup",
            on="first_startup",
            #exit_status="start",
            exit_status=DONT_CHANGE_STATUS,
            depends=["monit=start", "network=start"],
            priority=1,
            options={"debug":(bool,"Be more verbose.")}
            )
    def first_startup(self, options):
        # Check if the DHCP server must start before the netwizard
        ds = DataSource()
        try:
            if file_exists(GREEN_DHCP_CLIENT) or \
               to_bool(ds.product.settings.FIRST_BOOT_DISABLE_DHCP_SERVER):
                return EXIT_STATUS_STOP
        except:
            pass
        # GREEN bridge setup
        if ds.product.settings.get('DEFAULT_GREEN'):
            interface = ds.product.settings.DEFAULT_GREEN
        else:
            # Use the first interface as GREEN
            from endian.core.niclist import get_default_wan, get_system_nics
            interfaces = get_system_nics(include_only_names=True)
            try:
                interfaces.remove(get_default_wan())
            except:
                pass
            if interfaces:
                interface = interfaces[0]
            else:
                interface = None
        if interface and set(ds.ethernet.br0) != set([interface]):
            write_file_content(BR0_SETTINGS, interface, logger=self.logger, newline=True)
            chown(BR0_SETTINGS, NOBODY)
            chgrp(BR0_SETTINGS, NOGROUP)
            send_cmd_to_engine('restart bridges')
        # Start the DHCP server on GREEN zone
        options['force'] = True
        options['force_enable_green'] = True
        return self.restart(options)

