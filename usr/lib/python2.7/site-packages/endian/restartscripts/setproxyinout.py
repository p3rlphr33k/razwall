#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2010 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import tempfile
from endian.job.commons import *
from endian.data import *

CHAINS = ['PROXYOUT', 'PROXYIN']

ETHERNET_SETTINGS = '/var/efw/ethernet/settings'
STATE = '/etc/firewall/proxies/iptablesproxyinout'
TMPFILE = "/var/tmp/iptablesproxyinout"
OPENVPNDIR = '/var/efw/openvpnclients/'

TMPL = '/etc/firewall/outgoingfw/proxyinout.tmpl'

PROXYINOUT_DEVICES = (
    'GREEN',
    'ORANGE',
    'BLUE',
    'ipsec+',
    'tap+',
    'tun+',
    'openvpntun+',
    'l2tp+',
    'PHYSDEV:tap+',
    'POLICY:ipsec',
)


class SetProxyInOut(Job):

    settings = None
    tmpl = None
    script = None
    _uplink_pool = None
    _redInterfacesCache = None
    _openvpnDevicesCache = None
    _zoneCache = None

    def get_uplink_pool(self):
        from uplinksdaemon.uplinks import UplinksPool
        if self._uplink_pool is None:
            self._uplink_pool = UplinksPool()
        return self._uplink_pool

    def get_zone_cache(self):
        from endian.core.zones import getZones
        if self._zoneCache is None:
            self._zoneCache = getZones()
        return self._zoneCache

    def all_red_interfaces(self):
        if self._redInterfacesCache is None:
            self._redInterfacesCache = []
            try:
                for uplink in self.get_uplink_pool().getActiveUplinks():
                    if uplink.getSettings()['RED_TYPE'] == 'NONE':
                        continue
                    data = uplink.getData()
                    dev = data.get('INTERFACE')
                    if uplink.getSettings()['RED_TYPE'] == 'STEALTH':
                        if 'BRIDGE_PORT' in data:
                            dev = "PHYSDEV:%s" % data.get('BRIDGE_PORT')
                        else:
                            continue
                    self._redInterfacesCache.append(dev)
            except:
                pass
        return self._redInterfacesCache

    def get_interface_by_openvpn_name(self, name):
        filename = os.path.join(OPENVPNDIR, name, 'settings')
        if not os.path.exists(filename):
            return None
        conf = get_config(filename)
        if conf.get('DEVICE', '') == '':
            return None
        device = conf['DEVICE']
        if conf.get('ROUTETYPE', 'routed') == 'bridged':
            return "PHYSDEV:%s" % device
        return device

    def all_openvpn_interfaces(self):
        if self._openvpnDevicesCache is not None:
            return self._openvpnDevicesCache
        self._openvpnDevicesCache = []
        for ov in glob.glob(OPENVPNDIR + '/*'):
            dev = self.get_interface_by_openvpn_name(os.path.basename(ov))
            if dev is None:
                continue
            self._openvpnDevicesCache.append(dev)
        return self._openvpnDevicesCache

    def subst_zone(self, value, exclude_stealth=False):
        if not exclude_stealth:
            return [self.settings['%s_DEV' % value]]
        zone_cache = self.get_zone_cache()
        # If zone is not defined, return XX_DEV
        try:
            members = set(zone_cache[value].members)
        except KeyError:
            return [self.settings['%s_DEV' % value]]
        # Find stealth uplinks
        stealth_uplinks = set()
        for intf in self.all_red_interfaces():
            if intf.startswith("PHYSDEV:"):
                stealth_uplinks.add(intf[8:])
        # If no stealth uplink is member of this zone,
        # return XX_DEV
        members_no_stealth_uplinks = members - stealth_uplinks
        if members_no_stealth_uplinks == members:
            return [self.settings['%s_DEV' % value]]
        # Explode members via PHYSDEV:<device>,
        # avoiding stealth uplinks
        return ["PHYSDEV:%s" % x for x in sorted(members_no_stealth_uplinks)]

    def subst_zones(self, value, exclude_stealth=False):
        if value == 'ALL' or value == 'ANY' or value == '':
            return ['']
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED', 'HOTSPOT']:
            return [value]
        self.debug("Substitute ZONE '%s'", value)
        if value != 'RED':
            dev = self.subst_zone(value, exclude_stealth=exclude_stealth)
            self.debug("Substituted ZONE '%s' to: %s", value, dev)
            return dev
        redifs = self.get_interface_by_uplink('ANY')
        if len(redifs) <= 0:
            self.debug(
                "Substitution of ZONE '%s' failed. No red interface is up!",
                value)
            raise Exception("No red interface is up")
        self.debug("Substituted ZONE '%s' to: %s", value, redifs)
        return redifs

    def render_template(self, tmpl):
        cmd = str(tmpl(namespaces=[self.settings]))
        return cmd

    def generate_script(self):
        if self.settings is None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE)
        self.debug("Generate iptables script")
        for chain in CHAINS:
            script.write("iptables -F %s\n" % chain)
        for input_ in (True, False):
            if input_:
                exclude_stealth=True
            else:
                exclude_stealth=False
            for d in PROXYINOUT_DEVICES:
                for dev in self.subst_zones(d, exclude_stealth=exclude_stealth):
                    physdev = ''
                    device = ''
                    policy = ''
                    if dev.startswith("PHYSDEV:"):
                        physdev = dev[8:]
                    elif dev.startswith("POLICY:"):
                        policy = dev[7:]
                    else:
                        device = dev
                    self.settings['PHYSDEV'] = physdev
                    self.settings['POLICY'] = policy
                    self.settings['DEVICE'] = device
                    self.settings['INPUT'] = input_
                    rule_str = self.render_template(self.tmpl)
                    script.write(rule_str)
        script.flush()
        return script

    def save_config(self):
        self.script = self.generate_script()

        if not os.path.exists(STATE):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, STATE, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed

    def load_config(self):
        self.settings = {}
        ds = DataSource()
        self.settings.update(ds.proxy.settings)
        self.settings.update(get_config(ETHERNET_SETTINGS))
        self.tmpl = Template.compile(file=TMPL)

    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug": (bool, "Be more verbose."),
                     "force": (bool, "Forces restart."),
                     "trace": (bool, "Display iptables shell script trace.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False
        options['force'] = options.get('force', False)
        self.start(options)

    @action(name="start",
            depends=["firewall=start"],
            exit_status="start",
            on="startup_done",
            options={"debug": (bool, "Be more verbose."),
                     "force": (bool, "Forces start."),
                     "trace": (bool, "Display iptables shell script trace.")}
            )
    def start(self, options):
        Job.start(self, options)
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        self.load_config()

        self.info("Restart proxyinout rules, force: %s", options.get('force'))
        changed = self.save_config()

        if changed or options.get('force'):
            self.debug("Save script to state file '%s'", STATE)
            shutil.copy(self.script.name, STATE)

            self.debug("Call iptables script %s", self.script.name)
            iptables(
                script=self.script.name,
                trace=options.get('trace'),
                logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()

    @action(name="firewall_restart",
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug": (bool, "Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart setproxyinout")
        options['force'] = True
        self.start(options)
