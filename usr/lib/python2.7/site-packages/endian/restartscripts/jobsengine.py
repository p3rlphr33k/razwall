#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
from endian.data import DataSource
from endian.job.commons import Job, action, function, write_config, EXIT_STATUS_START
from endian.job.generic.handlersjob import HandlersJob

LOGROTATE = "/etc/logrotate.d/jobsengine"

class JobsengineJob(HandlersJob, Job):

    config_values = None

    def load_config(self):
        self.config_values = {}
        self.config_values['DS'] = DataSource()

    def save_config(self):
        if self.config_values == None:
            self.load_config()
        write_config(LOGROTATE + ".tmpl",
                     LOGROTATE,
                     self.config_values)
        return False

    @action(name="start",
            on="startup",
            depends=["monit", "network"],
            priority=25,
            options={"debug":(bool,"Be more verbose.")}
            )
    def start(self, options):
        """ This function does not start the jobsengine, but it creates the logrotate config file """
        Job.start(self, options)
        return self.restart(options)

    @action(name="restart",
            depends=["monit=start", "network=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def restart(self, options):
        """ This function does not start the jobsengine, but it creates the logrotate config file """
        Job.restart(self, options)
        self.save_config()
        return EXIT_STATUS_START

    @function(name="run_parts",
              async=True,
              options={"directory":   (unicode, "Run scripts and jobsengine commands from this directory"),
                       "prefix":      (unicode, "Prefix added to the jobsengine cmds (e.g. internal)"),
                       "environ":     (unicode, "Additional environ vars")})
    def run_parts(self, options):
        """
        ... autofunction :: run_parts
            Runs a number of scripts and jobsengine commands found in a single directory directory.
            Scripts and jobsengine commands are recognized by the filename.
            * scripts -- Filenames should consist entirely of upper and lower case letters,
                         digits, underscores, and hyphens (e.g. 01interfacemark)
            * jobsengine cmd -- Filename format [PRIORITY].cmd.args (e.g. 05.restart.xyz, restart.xyz)
                         If the file is not empty, the file content is used as additional argument.
            Options:

            * directory directory path
            * prefix prefix added to the jobsengine cmds (e.g. internal)
            * environ if it is not None, it must be a mapping that defines the
                            environment variables for the new process;
                            these are used instead of inheriting the jobsengine environment,
                            which is the default behavior.

            All the additional argument except directory, prefix and eviron
            are converted in environ vars passed to the triggered commands.
        """
        prefix = options.get("prefix", None)
        directory = options.get('directory', None)

        # Convert all the additional options into environ vars
        environ = dict(options.get('environ', {}))
        for key, value in options.iteritems():
            if key not in ['directory', 'prefix', 'environ']:
               environ[key] = value

        # Check if the directory option is present
        if not directory:
            raise Exception("Missing parameter directory")
        if not os.access(directory, os.F_OK):
            self.debug("Triggers directory %s not found" % directory)
            return
        self.info("Running triggers from %s" % directory)
        return HandlersJob.run_parts(self, directory=directory, prefix=prefix, environ=environ)
