#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2006 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import copy
import tempfile
from endian.job.commons import *
from endian.data.container.csvconfig import CsvConfigFile
from endian.datatypes.config_dict import ConfigDict


CONFIGBASE='/var/efw/'
CHAINS=['OUTGOINGFW', 'PROXYOUTGOINGFW']

CONFIG='/var/efw/outgoing/config'
STATE='/etc/firewall/outgoingfw/iptablesoutgoingfw'
TMPFILE="/var/tmp/iptablesoutgoingfw"
SETTINGS='/var/efw/outgoing/settings'
ETHERNET_SETTINGS='/var/efw/ethernet/settings'
NEEDRELOAD='/var/efw/outgoing/needreload'
LOG_SETTINGS='/var/efw/logging/settings'
HOTSPOT_SETTINGS='/var/efw/hotspot/settings'

TMPL='/etc/firewall/outgoingfw/rules.tmpl'

APPLICATION_MASK="0x3"
APPLICATION_ACCEPT_MARK="0x0"
APPLICATION_DEFERRED_MARK="0x1"
APPLICATION_DROP_MARK="0x2"
APPLICATION_REJECT_MARK="0x3"

class SetOutgoing(Job):

    _uplink_pool = None
    _red_interfaces_cache = None
    settings = None
    script = None
    tmpl = None
    
    def all_red_interfaces(self):
        if self._red_interfaces_cache != None:
            return self._red_interfaces_cache
        self._red_interfaces_cache = []
        try:
            for uplink in self.get_uplink_pool().getActiveUplinks():
                if uplink.getSettings()['RED_TYPE'] == 'NONE':
                    continue
                data = uplink.getData()
                dev = data.get('INTERFACE')
                if uplink.getSettings()['RED_TYPE'] == 'STEALTH':
                    if 'BRIDGE_PORT' in data:
                        dev = "PHYSDEV:%s" % data.get('BRIDGE_PORT')
                    else:
                        continue
                self._red_interfaces_cache.append(dev)
        except:
            pass
        return self._red_interfaces_cache
    
    def get_interface_by_uplink(self, uplink):
        if uplink != 'ANY':
            ul = self.get_uplink_pool().get(uplink)
            if ul.getSettings()['RED_TYPE'] == 'NONE':
                return []
            data = ul.getData()
            dev = data.get('INTERFACE')
            if 'BRIDGE_PORT' in data:
                dev = "PHYSDEV:%s" % data.get('BRIDGE_PORT')
            if dev != None:
                return [dev]
            return []
        else:
            return self.all_red_interfaces()

    def get_uplink_pool(self):
        from uplinksdaemon.uplinks import UplinksPool
        if self._uplink_pool != None:
            return self._uplink_pool
        self._uplink_pool = UplinksPool()
        return self._uplink_pool

    def insert_rule(self, obj, data={}):
        methods = {}
        localdata = {}
    
        obj.log = data.get('log', False)
        obj.deferred = obj.get('deferred', False)
        localdata['app'] = obj.application
        if obj.application:
            data['useApplication'] = True
        self.satanize_rule(obj)
        cmd = str(self.tmpl(namespaces = [obj, methods, data, localdata]))
        self.debug("Create rule nr %d: %s", obj.i, cmd)
        return cmd.strip()
    
    def explode_rules(self, line, explodefields):
        if line.enabled != 'on':
            return
        rules = []
        rules.append(line)
        for field in explodefields:
            tmprules = []
            fieldval = getattr(line, field)
            if fieldval == '':
                continue
            for value in fieldval.split('&'):
                if value == '':
                    continue
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rulenum = len(rules)
        if rulenum > 1:
            self.debug("Exploded rules to %d", rulenum)
        return rules

    def subst_uplink_dev(self, dev, rule=None):
        if not dev.startswith('UPLINK:'):
            return dev
        self.debug("Substitute UPLINK '%s'", dev)
        uplink = dev.split(':')[1]
        if uplink == '':
            self.debug("Key '%s' contains no value.", dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.get_interface_by_uplink(uplink)
        if len(devlist) <= 0:
            self.debug("Uplink '%s' has no Devices.", uplink)
            raise KeyError("Uplink '%s' has no Devices."%uplink)
        self.debug("Substituted UPLINK '%s' to: %s", dev, devlist)
        return "&".join(devlist)

    def subst_zones(self, value, rule=None):
        if value == 'ALL' or value == 'ANY' or value == '':
            return ''
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED', 'HOTSPOT']:
            return value
        self.debug("Substitute ZONE '%s'", value)
        if value != 'RED':
            dev = self.settings["%s_DEV"%value]
            self.debug("Substituted ZONE '%s' to: %s", value, dev)
            return dev
        redifs = self.get_interface_by_uplink('ANY')
        if len(redifs) <= 0:
            self.debug("Substitution of ZONE '%s' failed. No red interface is up!", value)
            raise Exception("No red interface is up")
        self.debug("Substituted ZONE '%s' to: %s", value, redifs)
        return "&".join(redifs)

    def subst_iter(self, values, cb, rule=None, delimiter='&'):
        if not values:
            return values
        if cb == None:
            return values
        ret = ''
        empty = True
        for i in values.split(delimiter):
            if i == None:
                continue
            value=None
            try:
                value = cb(i, rule)
            except:
                self.debug("Substitution failed", exc_info=True)
                continue
            if value == None:
                continue
            ret+=delimiter+value
            empty=False
        if empty:
            self.debug("No suitable value found for substitution of '%s'", values)
            raise Exception("No suitable value found for substitution")
        if ret == '':
            return ''
        return ret[1:]

    def substitute_values(self, rule):
        try:
            rule.src_dev = self.subst_iter(rule.src_dev, self.subst_zones, rule)
            rule.dst_dev = self.subst_iter(rule.dst_dev, self.subst_uplink_dev, rule)
            rule.dst_dev = self.subst_iter(rule.dst_dev, self.subst_zones, rule)
        except:
            return None
        return rule

    def satanize_rule(self, item):
        if 'onlychain' not in item:
            item.onlychain = ''
        if item.src_ip in ['0.0.0.0', '']:
            item.src_ip = '0/0'
        if item.dst_ip in ['0.0.0.0', '']:
            item.dst_ip = '0/0'
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in=False
        item.physdev_out=False
        if item.src_dev.startswith('PHYSDEV'):
            item.physdev_in=True
            item.src_dev = item.src_dev.split(":")[1]
        if item.dst_dev.startswith('PHYSDEV'):
            item.physdev_out=True
            item.dst_dev = item.dst_dev.split(":")[1]
        item.logtarget = item.target
        if item.target == '':
            item.target = 'ACCEPT'
        item.dst_port = item.dst_port.replace("-", ":")
        item.dst_range = False
        if item.dst_ip.find('-') != -1:
            item.dst_range = True
        item.src_range = False
        if item.src_ip.find('-') != -1:
            item.src_range = True
        return item

    def get_rules(self):
        ret = []
        if self.settings['POLICY'] == 'ALLOW':
            # allow all
            add = ConfigDict({
                    'enabled' : 'on',
                    'proto' : '',
                    'src_ip' : '',
                    'dst_ip' : '',
                    'dst_port' : '',
                    'target' : '',
                    'mac' : '',
                    'remark' : '',
                    'log' : '',
                    'src_dev' : 'ORANGE&BLUE&GREEN',
                    'dst_dev' : '',
                    'application': '',
                    'onlychain': '',
                    })
            ret.append(add)
            return ret
    
        self.debug("Read from '%s'"%CONFIG)
        try:
            rules=CsvConfigFile(
                '/usr/lib/efw/outgoing/config.config',
                CONFIG,
                tolerant=True,
                )
            ret.extend(rules)
        except Exception, e:
            self.error("Could not load config file '%s', because: %s!" % (CONF, e))

        add = ConfigDict({
                'enabled' : 'on',
                'proto' : '',
                'src_ip' : '',
                'dst_ip' : '',
                'dst_port' : '',
                'target' : 'ACCEPT',
                'mac' : '',
                'remark' : '',
                'log' : '',
                'src_dev' : '',
                'dst_dev' : '',
                'application': 'NOT_YET',
                'deferred': True,
                'lastRule': True,
                'onlychain': ''
                })
        ret.append(add)
        add = ConfigDict({
                'enabled' : 'on',
                'proto' : '',
                'src_ip' : '',
                'dst_ip' : '',
                'dst_port' : '',
                'target' : 'ALLOW',
                'mac' : '',
                'remark' : '',
                'log' : '',
                'src_dev' : '',
                'dst_dev' : '',
                'application': '',
                'lastRule': False,
                'onlychain': 'PROXYOUTGOINGFW',
                })
        ret.append(add)
        add = ConfigDict({
                'enabled' : 'on',
                'proto' : '',
                'src_ip' : '',
                'dst_ip' : '',
                'dst_port' : '',
                'target' : 'DROP',
                'mac' : '',
                'remark' : '',
                'log' : '',
                'src_dev' : '',
                'dst_dev' : '',
                'application': '',
                'lastRule': True,
                'onlychain': 'OUTGOINGFW',
                })
        ret.append(add)

        # this is necessary to enforce default policy DROP especially when
        # we have a stealth uplink where ZONEFW could allow connections which
        # should be classified OUTGOINGFW
        add = ConfigDict({
                'enabled' : 'on',
                'proto' : '',
                'src_ip' : '',
                'dst_ip' : '',
                'dst_port' : '',
                'target' : 'DROP',
                'mac' : '',
                'remark' : '',
                'log' : '',
                'src_dev' : '',
                'dst_dev' : '',
                'application': '',
                'lastRule': False,
                'onlychain': 'OUTGOINGFW',
                })
        ret.append(add)
        return ret

    def generate_script(self):
        if self.settings == None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE)

        i = 0
        data = {
            'useApplication': False,
            'log': False,
            'applicationAcceptMark': APPLICATION_ACCEPT_MARK,
            'applicationDeferredMark': APPLICATION_DEFERRED_MARK,
            'applicationDropMark': APPLICATION_DROP_MARK,
            'applicationRejectMark': APPLICATION_REJECT_MARK,
            'applicationMask': APPLICATION_MASK,
            }
        self.debug("Generate iptables script")
        for chain in CHAINS:
            script.write(("iptables -F %s\n") % chain)
        for rule in self.get_rules():
            i += 1
            rule.i = i
            if rule.enabled != 'on':
                continue
            if not data['useApplication'] and rule.get('lastRule', False):
                continue
            log = (rule.log == 'on')
            if self.settings['LOG_ACCEPTS'] == 'on':
                if rule.target in ['ACCEPT', 'ALLOW']:
                    log = True
            if self.settings.get('DISABLE_FIREWALL_LOGS','off') == 'on':
                log = False
            data['log'] = log
            # ICMP hack
            if rule.proto == 'icmp':
               rule.dst_port = '8&30'
            if rule.dst_dev == '':
                rule.dst_dev = 'RED'
            if self.substitute_values(rule) == None:
                continue
            for item in self.explode_rules(rule, ['proto', 'src_dev', 'src_ip', 
                                             'dst_dev', 'dst_ip', 'dst_port', 'mac', 'application']):
                try:
                    script.write(self.insert_rule(item, data))
                    script.write("\n")
                except Exception, e:
                    self.debug("Explosion failed", exc_info=True)
                    continue

        script.flush()
        return script

    def save_config(self):
        self.script = self.generate_script()
    
        if not os.path.exists(STATE):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, STATE, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed

    def load_config(self):
        self.settings = get_config(SETTINGS)
        self.settings.update(get_config(ETHERNET_SETTINGS))
        self.settings.update(get_config(HOTSPOT_SETTINGS))
        self.settings.update(get_config(LOG_SETTINGS))
        self.tmpl = Template.compile(file=TMPL)
    
    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False        
        options['force'] = options.get('force', False)
        self.start(options)
        
    @action(name="start",
            depends=["firewall=start"],
            exit_status="start",
            on="startup_done",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces start."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def start(self, options):
        Job.start(self, options)
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        # TODO: check this
        # run('/usr/local/bin/migration_efw-firewall-outgoingfw.py')
        self.info("Restart OUTGOING firewall, force: %s", options.get('force'))
        changed = self.save_config()
    
        if changed or options.get('force'):
            self.debug("Save script to state file '%s'", STATE)
            shutil.copy(self.script.name, STATE)
    
            self.debug("Call iptables script %s", self.script.name)
            iptables(script=self.script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()
            
        if os.path.exists(NEEDRELOAD):
            os.unlink(NEEDRELOAD)

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        
    @action(name="firewall_restart", 
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart setoutgoing")
        options['force'] = True
        self.start(options)
