#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2010 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of the GNU Lesser General Public License as published |
# | by the Free Software Foundation, either version 2.1 of the License, or   |
# | (at your option) any later version.                                      |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the GNU Lesser General Public License |
# | along with endian-core.  If not, see <http://www.gnu.org/licenses/>.     |
# +--------------------------------------------------------------------------+
#

import os
from endian.job.job import Job, action, function
from endian.firewall.iptables import iptables
from endian.data.ds import DataSource
from endian.job.commons import to_bool, get_config, send_cmd_to_engine, run, remove_path

IPTABLES_HOOK_DIR = "/etc/firewall/hooks"

PHYSDEV_ENABLE_MARK = "0x40000"
PHYSDEV_DISABLE_MARK = "0xFFFBFFFF"
PHYSDEV_MASK = "0xFFF80000"
QUEUE_MASK = "0x4"
DEFERRED_MASK = "0x3"

ACCEPT_MARK = "0x0"
DEFERRED_MARK = "0x1"
DROP_MARK = "0x2"
REJECT_MARK = "0x3"

ETHERNET_SETTINGS = "/var/efw/ethernet/settings"
OPENVPN_SETTINGS = "/var/efw/openvpn/settings"
LOGGING_SETTINGS = "/var/efw/logging/settings"
HA_SETTINGS = "/var/efw/ha/settings"
HOTSPOT_SETTINGS = "/var/efw/hotspot/settings"
FIREWALL_SETTINGS = "/var/efw/firewall/settings"


class FirewallJob(Job):

    settings = None

    def load_config(self):
        self.settings = get_config(ETHERNET_SETTINGS)
        for path in [ETHERNET_SETTINGS, OPENVPN_SETTINGS, LOGGING_SETTINGS,
                     HA_SETTINGS, HOTSPOT_SETTINGS, FIREWALL_SETTINGS]:
            self.settings.update(get_config(path))

    def handle_hotspot_drops(self, chain):
        if self.settings is None:
            self.load_config()
        if to_bool(self.settings.get('HOTSPOT_ENABLED')):
            iptables("iptables -A %s -i %s -j DROP" % (
                chain,
                self.settings.get('HOTSPOT_DEV')
            ), logger=self.logger)

    def iptables_setlog(self):
        iptables("iptables -F BADTCP_LOGDROP", logger=self.logger)
        if to_bool(self.settings.get("LOG_BADTCP")) and not to_bool(self.settings.get("DISABLE_FIREWALL_LOGS")):
            self.handle_hotspot_drops("BADTCP_LOGDROP")
            iptables("iptables -A BADTCP_LOGDROP -m limit --limit 10/minute -j NFLOG --nflog-prefix \"BADTCP:DROP\"", logger=self.logger)
        iptables("iptables -A BADTCP_LOGDROP -j DROP", logger=self.logger)

        iptables("iptables -F NEWNOTSYN_LOGDROP", logger=self.logger)
        if to_bool(self.settings.get("LOG_NEWNOTSYN")) and not to_bool(self.settings.get("DISABLE_FIREWALL_LOGS")):
            self.handle_hotspot_drops("NEWNOTSYN_LOGDROP")
            iptables("iptables -A NEWNOTSYN_LOGDROP  -m limit --limit 10/minute -j NFLOG --nflog-prefix \"NEW not SYN?:DROP\"", logger=self.logger)
        iptables("iptables -A NEWNOTSYN_LOGDROP -j DROP", logger=self.logger)

        iptables("iptables -F LOG_INPUT", logger=self.logger)
        iptables("iptables -F LOG_FORWARD", logger=self.logger)
        iptables("iptables -F VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -F ZONEFW_LOGDROP", logger=self.logger)
        iptables("iptables -F INPUTFW_LOGDROP", logger=self.logger)
        iptables("ebtables -t nat -F PHYSDEV_LOGDROP", logger=self.logger)

        if to_bool(self.settings.get("LOG_DROPS")) and not to_bool(self.settings.get("DISABLE_FIREWALL_LOGS")):
            self.handle_hotspot_drops("LOG_INPUT")
            iptables("iptables -A LOG_INPUT   -m limit --limit 10/minute -j NFLOG --nflog-prefix \"INPUT:DROP\"", logger=self.logger)
            self.handle_hotspot_drops("LOG_FORWARD")
            iptables("iptables -A LOG_FORWARD -m limit --limit 10/minute -j NFLOG --nflog-prefix \"FORWARD:DROP\"", logger=self.logger)
            self.handle_hotspot_drops("VPNFW_LOGDROP")
            iptables("iptables -A VPNFW_LOGDROP -m limit --limit 10/minute -j NFLOG --nflog-prefix \"VPNFW:DROP\"", logger=self.logger)
            self.handle_hotspot_drops("ZONEFW_LOGDROP")
            iptables("iptables -A ZONEFW_LOGDROP -m limit --limit 10/minute -j NFLOG --nflog-prefix \"ZONEFW:DROP\"", logger=self.logger)
            self.handle_hotspot_drops("INPUTFW_LOGDROP")
            iptables("iptables -A INPUTFW_LOGDROP -m limit --limit 10/minute -j NFLOG --nflog-prefix \"INPUTFW:DROP\"", logger=self.logger)
            iptables("ebtables -t nat -A PHYSDEV_LOGDROP --limit 10/minute --nflog-prefix \"ZONEFW:DROP\"", logger=self.logger)

        iptables("iptables -A VPNFW_LOGDROP -j DROP", logger=self.logger)
        iptables("iptables -A ZONEFW_LOGDROP -j DROP", logger=self.logger)
        iptables("iptables -A INPUTFW_LOGDROP -j DROP", logger=self.logger)
        iptables("ebtables -t nat -A PHYSDEV_LOGDROP -j DROP", logger=self.logger)

        # allow to handle echo-request and traceroute separately
        iptables("iptables -A ICMP_LOGDROP -j RETURN -p icmp --icmp-type 8", logger=self.logger)
        iptables("iptables -A ICMP_LOGDROP -j RETURN -p icmp --icmp-type 30", logger=self.logger)
        iptables("iptables -A ICMP_LOGDROP -j DROP", logger=self.logger)

    def iptables_newnotsyn(self):
        # Don't drop NEW not SYN packets of the same zone. In the same zone triangle
        # connections could happen where returning packets don't pass the same path
        # and thus cause NEW not SYN packets.

        for inteface in self.get_ifaces():
            iptables("iptables -A NEWNOTSYN -j RETURN -i \"%s\" -o \"%s\"" % (inteface, inteface), logger=self.logger)

        # complex VPN scenarios may also have triangle connections where packets
        # come in through one vpn andpoint and return through another one especially
        # when using a dynamic routing setup.
        iptables("iptables -A NEWNOTSYN -j RETURN -i tap+", logger=self.logger)
        iptables("iptables -A NEWNOTSYN -j RETURN -o tap+", logger=self.logger)
        iptables("iptables -A NEWNOTSYN -j RETURN -i tun+", logger=self.logger)
        iptables("iptables -A NEWNOTSYN -j RETURN -o tun+", logger=self.logger)
        iptables("iptables -A NEWNOTSYN -j RETURN -i openvpntun+", logger=self.logger)
        iptables("iptables -A NEWNOTSYN -j RETURN -o openvpntun+", logger=self.logger)

        # drop NEW not SYN
        iptables("iptables -A NEWNOTSYN -j NEWNOTSYN_LOGDROP", logger=self.logger)

    def iptables_init(self):
        if self.settings is None:
            self.load_config()

        # remove interface registry
        remove_path("/var/lib/ticketregistry/interfaces")

        # Flush all rules and delete all custom chains
        iptables("iptables -F", logger=self.logger)
        iptables("iptables -t nat -F", logger=self.logger)
        iptables("iptables -t mangle -F", logger=self.logger)
        iptables("iptables -X", logger=self.logger)
        iptables("iptables -t nat -X", logger=self.logger)
        iptables("iptables -t mangle -X", logger=self.logger)

        # clear ebtables
        iptables("ebtables -F", logger=self.logger)
        iptables("ebtables -X", logger=self.logger)
        iptables("ebtables -t nat -F", logger=self.logger)
        iptables("ebtables -t nat -X", logger=self.logger)

        # Set up policies
        iptables("iptables -P INPUT DROP", logger=self.logger)
        iptables("iptables -P FORWARD DROP", logger=self.logger)
        iptables("iptables -P OUTPUT ACCEPT", logger=self.logger)

        # Set up ipv6 policies
        run("ip6tables -P INPUT DROP", logger=self.logger)
        run("ip6tables -P FORWARD DROP", logger=self.logger)
        run("ip6tables -P OUTPUT ACCEPT", logger=self.logger)

        # This chain will log, then DROPs packets with certain bad combinations
        # of flags might indicate a port-scan attempt (xmas, null, etc)
        iptables("iptables -N BADTCP_LOGDROP", logger=self.logger)

        # Chain to contain all the rules relating to bad TCP flags
        iptables("iptables -N BADTCP", logger=self.logger)
        if to_bool(self.settings.get("ENABLE_BADTCP")):
            iptables("iptables -A INPUT -j BADTCP", logger=self.logger)
            iptables("iptables -A FORWARD -j BADTCP", logger=self.logger)

        # Disallow packets frequently used by port-scanners
        # nmap xmas
        iptables("iptables -A BADTCP -p tcp --tcp-flags ALL FIN,URG,PSH  -j BADTCP_LOGDROP", logger=self.logger)
        # Null
        iptables("iptables -A BADTCP -p tcp --tcp-flags ALL NONE -j BADTCP_LOGDROP", logger=self.logger)
        # FIN
        iptables("iptables -A BADTCP -p tcp --tcp-flags ALL FIN -j BADTCP_LOGDROP", logger=self.logger)
        # SYN/RST (also catches xmas variants that set SYN+RST+...)
        iptables("iptables -A BADTCP -p tcp --tcp-flags SYN,RST SYN,RST -j BADTCP_LOGDROP", logger=self.logger)
        # SYN/FIN (QueSO or nmap OS probe)
        iptables("iptables -A BADTCP -p tcp --tcp-flags SYN,FIN SYN,FIN -j BADTCP_LOGDROP", logger=self.logger)

        # drop port 0
        iptables("iptables -A BADTCP -p tcp --sport 0 -j BADTCP_LOGDROP", logger=self.logger)
        iptables("iptables -A BADTCP -p udp --sport 0 -j BADTCP_LOGDROP", logger=self.logger)
        iptables("iptables -A BADTCP -p tcp --dport 0 -j BADTCP_LOGDROP", logger=self.logger)
        iptables("iptables -A BADTCP -p udp --dport 0 -j BADTCP_LOGDROP", logger=self.logger)

        # New tcp packets without SYN set - could well be an obscure type of port scan
        # that's not covered above, may just be a broken windows machine
        iptables("iptables -N NEWNOTSYN", logger=self.logger)
        iptables("iptables -N NEWNOTSYN_LOGDROP", logger=self.logger)
        # NEW TCP without SYN
        iptables("iptables -A INPUT -p tcp ! --syn -m state --state NEW -j NEWNOTSYN_LOGDROP", logger=self.logger)
        self.iptables_newnotsyn()

        iptables("iptables -N LOG_INPUT", logger=self.logger)
        iptables("iptables -N LOG_FORWARD", logger=self.logger)
        iptables("iptables -N VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -N ZONEFW_LOGDROP", logger=self.logger)
        iptables("iptables -N INPUTFW_LOGDROP", logger=self.logger)
        iptables("iptables -N ICMP_LOGDROP", logger=self.logger)
        iptables("ebtables -t nat -N PHYSDEV_LOGDROP", logger=self.logger)
        iptables("ebtables -t nat -P PHYSDEV_LOGDROP DROP", logger=self.logger)
        self.iptables_setlog()

        # wrapper target for ACCEPT
        iptables("iptables -N ALLOW", logger=self.logger)
        iptables("iptables -N ALLOW_HOOKS", logger=self.logger)
        iptables("iptables -A ALLOW -j ALLOW_HOOKS", logger=self.logger)
        iptables("iptables -N QUEUEFW", logger=self.logger)
        iptables("iptables -A ALLOW -j QUEUEFW", logger=self.logger)
        iptables("iptables -A ALLOW -j ACCEPT", logger=self.logger)
        iptables("ebtables -N ALLOW", logger=self.logger)
        iptables("ebtables -P ALLOW ACCEPT", logger=self.logger)
        iptables("ebtables -t nat -N ALLOW", logger=self.logger)
        iptables("ebtables -t nat -P ALLOW ACCEPT", logger=self.logger)

        # wrapper target handling ESTABLISHED connections
        iptables("iptables -N HANDLE_ESTABLISHED", logger=self.logger)

        iptables("iptables -A HANDLE_ESTABLISHED -j DROP -m connmark --mark %s/%s" % (DROP_MARK, DEFERRED_MASK), logger=self.logger)
        iptables("iptables -A HANDLE_ESTABLISHED -j REJECT -m connmark --mark %s/%s" % (REJECT_MARK, DEFERRED_MASK), logger=self.logger)
        iptables("iptables -A HANDLE_ESTABLISHED -j RETURN -m connmark --mark %s/%s" % (DEFERRED_MARK, DEFERRED_MASK), logger=self.logger)
        iptables("iptables -A HANDLE_ESTABLISHED -j ALLOW -m connmark ! --mark 0/%s" % QUEUE_MASK, logger=self.logger)
        iptables("iptables -A HANDLE_ESTABLISHED -j ACCEPT", logger=self.logger)

        # wrapper target for REJECT (does not exist in ebtables)
        iptables("ebtables -N REJECT", logger=self.logger)
        iptables("ebtables -P REJECT DROP", logger=self.logger)
        iptables("ebtables -t nat -N REJECT", logger=self.logger)
        iptables("ebtables -t nat -P REJECT DROP", logger=self.logger)

    def get_ifaces(self):
        if self.settings is None:
            self.load_config()
        result = [self.settings["GREEN_DEV"]]
        if self.has_blue() and "BLUE_DEV" in self.settings:
            result.append(self.settings["BLUE_DEV"])
        if self.has_orange() and "ORANGE_DEV" in self.settings:
            result.append(self.settings["ORANGE_DEV"])
        return result

    def has_blue(self):
        if self.settings is None:
            self.load_config()
        return int(self.settings['CONFIG_TYPE']) in [4, 5, 6, 7]

    def has_orange(self):
        if self.settings is None:
            self.load_config()
        return int(self.settings['CONFIG_TYPE']) in [1, 3, 5, 7]

    def iptables_defaultfw(self):
        if self.settings is None:
            self.load_config()

        iptables("iptables -A ZONEFW -i %s -o %s -j ALLOW" % (self.settings['GREEN_DEV'], self.settings['GREEN_DEV']), logger=self.logger)
        iptables("iptables -A INPUTFW -i %s -j ALLOW" % self.settings['GREEN_DEV'], logger=self.logger)

        if self.has_blue():
            iptables("iptables -A ZONEFW -i %s -o %s -j ALLOW" % (self.settings['BLUE_DEV'], self.settings['BLUE_DEV']), logger=self.logger)
            iptables("iptables -A ZONEFW -i %s -o %s -j ALLOW" % (self.settings['GREEN_DEV'], self.settings['BLUE_DEV']), logger=self.logger)
            iptables("iptables -A INPUTFW -i %s -j ALLOW" % self.settings['BLUE_DEV'], logger=self.logger)

        if self.has_orange():
            iptables("iptables -A ZONEFW -i %s -o %s -j ALLOW" % (self.settings['ORANGE_DEV'], self.settings['ORANGE_DEV']), logger=self.logger)
            iptables("iptables -A ZONEFW -i %s -o %s -j ALLOW" % (self.settings['GREEN_DEV'], self.settings['ORANGE_DEV']), logger=self.logger)
            iptables("iptables -A INPUTFW -i %s -j ALLOW" % self.settings['ORANGE_DEV'], logger=self.logger)

    def iptables_zonechains(self):
        if self.settings is None:
            self.load_config()

        iptables("iptables -F VPNTRAFFIC", logger=self.logger)
        iptables("iptables -F ZONETRAFFIC", logger=self.logger)
        iptables("iptables -t mangle -F ZONETRAFFIC", logger=self.logger)
        iptables("iptables -F INPUTTRAFFIC", logger=self.logger)

        # inputtraffic from vpn
        iptables("iptables -A INPUTTRAFFIC -i \"ipsec+\" -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i \"ipsec+\" -j INPUTFW_LOGDROP", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i \"tap+\" -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i \"tap+\" -j INPUTFW_LOGDROP", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i \"tun+\" -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i \"tun+\" -j INPUTFW_LOGDROP", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i \"openvpntun+\" -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i \"openvpntun+\" -j INPUTFW_LOGDROP", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -m physdev --physdev-in \"tap+\" -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -m physdev --physdev-in \"tap+\" -j INPUTFW_LOGDROP", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -m physdev --physdev-in \"tun+\" -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -m physdev --physdev-in \"tun+\" -j INPUTFW_LOGDROP", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -m physdev --physdev-in \"openvpntun+\" -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -m physdev --physdev-in \"openvpntun+\" -j INPUTFW_LOGDROP", logger=self.logger)

        # handles traffic coming from NETKEY IPSEC tunnel
        iptables("iptables -A INPUTTRAFFIC -m policy --pol ipsec --dir in -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -m policy --pol ipsec --dir in -j INPUTFW_LOGDROP", logger=self.logger)

        # l2tp traffic
        iptables("iptables -A INPUTTRAFFIC -i l2tp+ -j INPUTFW", logger=self.logger)
        iptables("iptables -A INPUTTRAFFIC -i l2tp+ -j INPUTFW_LOGDROP", logger=self.logger)

        interfaces = self.get_ifaces()
        if to_bool(self.settings.get('HA_ENABLED')) and self.settings.get('HA_MANAGEMENT_PORT'):
            ha_management_port = self.settings.get('HA_MANAGEMENT_PORT')
            if ha_management_port not in interfaces:
                interfaces.append(ha_management_port)
            iptables("iptables -A INPUTTRAFFIC -p ah -d 224.0.0.18 -i %s -j ACCEPT" % ha_management_port, logger=self.logger)

        for iff in interfaces:
            # zonetraffic
            for off in interfaces:
                iptables("iptables -A ZONETRAFFIC -i \"%s\" -o \"%s\" -j ZONEFW" % (iff, off), logger=self.logger)
                iptables("iptables -A ZONETRAFFIC -i \"%s\" -o \"%s\" -j ZONEFW_LOGDROP" % (iff, off), logger=self.logger)
                iptables("iptables -t mangle -A ZONETRAFFIC -i \"%s\" -o \"%s\" -j ZONEFW" % (iff, off), logger=self.logger)
                iptables("iptables -t mangle -A ZONETRAFFIC -i \"%s\" -o \"%s\" -j RETURN" % (iff, off), logger=self.logger)
            # block ident
            iptables("iptables -A INPUTTRAFFIC -i \"%s\" -p tcp --dport 113 -j REJECT --reject-with icmp-port-unreachable" % iff, logger=self.logger)
            # inputtraffic
            iptables("iptables -A INPUTTRAFFIC -i \"%s\" -j INPUTFW" % iff, logger=self.logger)
            iptables("iptables -A INPUTTRAFFIC -i \"%s\" -j INPUTFW_LOGDROP" % iff, logger=self.logger)

        # inputtraffic from RED
        # XXX: hacky.. should map each uplink interface to INPUTFW. otherwise INPUTTRAFFIC must be the
        #      last rule within INPUT
        iptables("iptables -A INPUTTRAFFIC -j INPUTFW", logger=self.logger)

        # vpntraffic

        # handles traffic coming from or going to IPSEC
        iptables("iptables -A VPNTRAFFIC -o ipsec+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o ipsec+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i ipsec+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i ipsec+ -j VPNFW_LOGDROP", logger=self.logger)

        # handles traffic coming from or going to NETKEY IPSEC tunnel
        iptables("iptables -A VPNTRAFFIC -m policy --pol ipsec --dir in -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m policy --pol ipsec --dir in -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m policy --pol ipsec --dir out -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m policy --pol ipsec --dir out -j VPNFW_LOGDROP", logger=self.logger)

        # l2tp traffic
        iptables("iptables -A VPNTRAFFIC -i l2tp+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i l2tp+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o l2tp+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o l2tp+ -j VPNFW_LOGDROP", logger=self.logger)

        # handles traffic coming from or going to routed openvpn endpoints ending here. (net2net client)
        iptables("iptables -A VPNTRAFFIC -o tap+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o tap+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o tun+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o tun+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o openvpntun+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -o openvpntun+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i tap+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i tap+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i tun+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i tun+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i openvpntun+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -i openvpntun+ -j VPNFW_LOGDROP", logger=self.logger)

        # handles traffic within the openvpn server
        # handles traffic coming from GREEN going to the openvpn server
        # handles traffic coming from GREEN going to the bridged vpn endpoints
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-out tap+ --physdev-is-bridged -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-out tap+ --physdev-is-bridged -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-out tun+ --physdev-is-bridged -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-out tun+ --physdev-is-bridged -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-out openvpntun+ --physdev-is-bridged -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-out openvpntun+ --physdev-is-bridged -j VPNFW_LOGDROP", logger=self.logger)

        # handles traffic within the openvpn server
        # handles traffic coming from the openvpn server going to other zones than green
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-in tap+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-in tap+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-in tun+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-in tun+ -j VPNFW_LOGDROP", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-in openvpntun+ -j VPNFW", logger=self.logger)
        iptables("iptables -A VPNTRAFFIC -m physdev --physdev-in openvpntun+ -j VPNFW_LOGDROP", logger=self.logger)

        # handles openvpn traffic which is bridged to a zone and thus
        # need to be categorized by ips/ip-ranges which can change
        # when openvpn configuration changes.
        iptables("iptables -A VPNTRAFFIC -j VPNFWBRIDGE", logger=self.logger)
        iptables("iptables -t mangle -I ZONETRAFFIC -j VPNFWBRIDGE", logger=self.logger)

    @function(name="set_forward_chain")
    def set_forward_chain(self, options=None):
        """Cleanup and setup the ebtables FORWARD chain."""
        iptables("ebtables -F FORWARD", logger=self.logger)
        iptables("ebtables -A FORWARD -j VPNFW -o tap+", logger=self.logger)
        iptables("ebtables -A FORWARD -j VPNFW -i tap+", logger=self.logger)
        iptables("ebtables -A FORWARD -j VPNFW -o tun+", logger=self.logger)
        iptables("ebtables -A FORWARD -j VPNFW -i tun+", logger=self.logger)
        iptables("ebtables -A FORWARD -j VPNFW -o openvpntun+", logger=self.logger)
        iptables("ebtables -A FORWARD -j VPNFW -i openvpntun+", logger=self.logger)
        iptables("ebtables -A FORWARD -j ZONEFW", logger=self.logger)

        ds = DataSource("HA")
        if to_bool(ds.settings.get("HA_ENABLED")) and not to_bool(ds.settings.get("STP")):
            iptables("ebtables -A FORWARD --logical-in br+ -j DROP", logger=self.logger)

    def ebtables_zonechains(self):
        iptables("ebtables -t nat -F ZONEFW", logger=self.logger)

    @action(name="restart",
            exit_status="start",
            options={"debug": (bool, "Be more verbose.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        self.info("Starting firewall")
        self.iptables_init()

        # Limit Packets- helps reduce dos/syn attacks
        iptables("iptables -A INPUT -p tcp -m tcp --tcp-flags SYN,RST,ACK SYN -m limit --limit 10/sec", logger=self.logger)

        # Fix for braindead ISP's
        iptables("iptables -t mangle -A FORWARD -p tcp --tcp-flags SYN,RST SYN -j TCPMSS --clamp-mss-to-pmtu", logger=self.logger)

        # CUSTOM chains, can be used by the users themselves
        iptables("iptables -N CUSTOMINPUT", logger=self.logger)
        iptables("iptables -A INPUT -j CUSTOMINPUT", logger=self.logger)
        iptables("iptables -N CUSTOMFORWARD", logger=self.logger)
        iptables("iptables -A FORWARD -j CUSTOMFORWARD", logger=self.logger)
        iptables("iptables -N CUSTOMOUTPUT", logger=self.logger)
        iptables("iptables -A OUTPUT -j CUSTOMOUTPUT", logger=self.logger)

        iptables("iptables -t nat -N CUSTOMPREROUTING", logger=self.logger)
        iptables("iptables -t nat -A PREROUTING -j CUSTOMPREROUTING", logger=self.logger)
        iptables("iptables -t nat -N CUSTOMPOSTROUTING", logger=self.logger)
        iptables("iptables -t nat -A POSTROUTING -j CUSTOMPOSTROUTING", logger=self.logger)

        # Drop INVALID
        if to_bool(self.settings.get("ENABLE_BADTCP")):
            iptables("iptables -A INPUT   -m state --state INVALID -j BADTCP_LOGDROP", logger=self.logger)
            iptables("iptables -A FORWARD -m state --state INVALID -j BADTCP_LOGDROP", logger=self.logger)

        # Accept everything connected
        iptables("iptables -A INPUT   -m state --state ESTABLISHED,RELATED -j HANDLE_ESTABLISHED", logger=self.logger)
        iptables("iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j HANDLE_ESTABLISHED", logger=self.logger)

        # Deny ICMP, echo-request and traceroute may be enabled by a specific firewall.
        # all other essential ICMP will be either ESTABLISHED or RELATED, and the rest will be dropped here.
        iptables("iptables -A INPUT -p icmp -j ICMP_LOGDROP", logger=self.logger)
        iptables("iptables -A FORWARD -p icmp -j ICMP_LOGDROP", logger=self.logger)

        # localhost and ethernet.
        iptables("iptables -A INPUT   -i lo          -m state --state NEW -j ACCEPT", logger=self.logger)
        iptables("iptables -A INPUT   -s 127.0.0.0/8 -m state --state NEW -j DROP", logger=self.logger)   # Loopback not on lo
        iptables("iptables -A INPUT   -d 127.0.0.0/8 -m state --state NEW -j DROP", logger=self.logger)
        iptables("iptables -A FORWARD -i lo          -m state --state NEW -j ACCEPT", logger=self.logger)
        iptables("iptables -A FORWARD -s 127.0.0.0/8 -m state --state NEW -j DROP", logger=self.logger)
        iptables("iptables -A FORWARD -d 127.0.0.0/8 -m state --state NEW -j DROP", logger=self.logger)

        # HA/LVS chains (allow management ips)
        iptables("iptables -N HAFORWARD", logger=self.logger)
        iptables("iptables -A FORWARD -j HAFORWARD", logger=self.logger)

        # Openvpn chains
        iptables("iptables -N OPENVPNDHCP", logger=self.logger)
        iptables("iptables -N OPENVPNCLIENTDHCP", logger=self.logger)
        iptables("iptables -I FORWARD -j OPENVPNDHCP", logger=self.logger)
        iptables("iptables -I FORWARD -j OPENVPNCLIENTDHCP", logger=self.logger)
        iptables("iptables -t nat -N OPENVPNCLIENT", logger=self.logger)
        iptables("iptables -t nat -A POSTROUTING -j OPENVPNCLIENT", logger=self.logger)

        # Red may use DHCP
        iptables("iptables -N REDINPUT", logger=self.logger)
        iptables("iptables -I INPUT -j REDINPUT", logger=self.logger)

        # always allow l2tp traffic to concentrator if within ipsec tunnel
        iptables("iptables -I INPUT -m policy --dir in --pol ipsec -p udp --dport 1701 -j ACCEPT", logger=self.logger)

        # PORTFWACCESS chain, used for portforwarding
        iptables("iptables -N PORTFWACCESS", logger=self.logger)
        iptables("iptables -A FORWARD -m state --state NEW -j PORTFWACCESS", logger=self.logger)

        # vpn filtering
        iptables("iptables -N VPNFW", logger=self.logger)
        iptables("iptables -N VPN_AS", logger=self.logger)  # access server chain
        iptables("iptables -A VPNFW -j VPN_AS", logger=self.logger)
        iptables("iptables -A VPNFW -j ALLOW", logger=self.logger)
        iptables("iptables -N VPNFWDST", logger=self.logger)
        iptables("iptables -t mangle -N VPNFWDST", logger=self.logger)
        iptables("iptables -N VPNFWBRIDGE", logger=self.logger)
        iptables("iptables -t mangle -N VPNFWBRIDGE", logger=self.logger)
        iptables("iptables -N VPNTRAFFIC", logger=self.logger)
        iptables("iptables -A FORWARD -j VPNTRAFFIC", logger=self.logger)

        # chain for outgoing firewall
        iptables("iptables -N OUTGOINGFW", logger=self.logger)
        iptables("iptables -A FORWARD -j OUTGOINGFW", logger=self.logger)

        # chain for incoming firewall
        iptables("iptables -N INCOMINGFW", logger=self.logger)
        iptables("iptables -A FORWARD -j INCOMINGFW  -m state --state NEW", logger=self.logger)

        # handles ipsec connection in order that they will not bet NATed
        iptables("iptables -t nat -A POSTROUTING -m policy --pol ipsec --dir out -j ACCEPT", logger=self.logger)

        iptables("iptables -t nat -N SOURCENAT", logger=self.logger)
        iptables("iptables -t nat -A POSTROUTING -j SOURCENAT", logger=self.logger)

        # zone filtering chain. it's for zones to talk with each other
        iptables("iptables -N ZONEFW", logger=self.logger)
        iptables("iptables -N ZONETRAFFIC", logger=self.logger)
        iptables("iptables -A FORWARD -j ZONETRAFFIC", logger=self.logger)
        iptables("iptables -t mangle -N ZONEFW", logger=self.logger)
        iptables("iptables -t mangle -N ZONETRAFFIC", logger=self.logger)
        iptables("iptables -t mangle -A FORWARD -j ZONETRAFFIC -m state --state NEW -m mark --mark 0/%s" % PHYSDEV_MASK, logger=self.logger)

        # don't block packets of established or related connections
        # this allows returning packets, otherwise ebtables would drop them
        iptables("iptables -t mangle -A FORWARD -m state --state ESTABLISHED,RELATED -j MARK --and-mark %s" % PHYSDEV_DISABLE_MARK, logger=self.logger)

        # chains for proxy outgoing firewall
        iptables("iptables -N PROXYOUTGOINGFW", logger=self.logger)
        iptables("iptables -N PROXYIN", logger=self.logger)
        iptables("iptables -N PROXYOUT", logger=self.logger)
        iptables("iptables -A INPUT -j PROXYIN", logger=self.logger)
        iptables("iptables -A OUTPUT -j PROXYOUT", logger=self.logger)

        # input filtering chain. it's for traffic going to the firewall itself
        iptables("iptables -N INPUTFW", logger=self.logger)
        iptables("iptables -N INPUTTRAFFIC", logger=self.logger)
        iptables("iptables -A INPUT -j INPUTTRAFFIC -m state --state NEW", logger=self.logger)

        # physdev-out ebtables filtering
        iptables("ebtables -t nat -N ZONEFW", logger=self.logger)
        iptables("ebtables -t nat -P ZONEFW RETURN", logger=self.logger)

        iptables("ebtables -t nat -N PHYSDEV", logger=self.logger)
        iptables("ebtables -t nat -P PHYSDEV DROP", logger=self.logger)

        # examine in depth when the examination flag is set.
        iptables("ebtables -t nat -I POSTROUTING -j PHYSDEV --mark %s/%s" % (PHYSDEV_ENABLE_MARK, PHYSDEV_ENABLE_MARK), logger=self.logger)

        iptables("ebtables -t nat -A PHYSDEV -j ZONEFW", logger=self.logger)
        iptables("ebtables -t nat -A PHYSDEV -j PHYSDEV_LOGDROP", logger=self.logger)

        # bridge filtering
        iptables("ebtables -N VPNFW", logger=self.logger)
        iptables("ebtables -P VPNFW ACCEPT", logger=self.logger)
        iptables("ebtables -N ZONEFW", logger=self.logger)
        iptables("ebtables -P ZONEFW RETURN", logger=self.logger)
        self.set_forward_chain()

        iptables("ebtables -N INPUTFW", logger=self.logger)
        iptables("ebtables -P INPUTFW RETURN", logger=self.logger)
        iptables("ebtables -A INPUT -j INPUTFW", logger=self.logger)

        self.iptables_zonechains()
        self.ebtables_zonechains()
        self.iptables_defaultfw()

        iptables("iptables -t nat -N PROXIES", logger=self.logger)
        iptables("iptables -t nat -A PREROUTING -j PROXIES", logger=self.logger)
        iptables("iptables -t nat -N PORTFW", logger=self.logger)
        iptables("iptables -t nat -A PREROUTING -j PORTFW", logger=self.logger)
        iptables("iptables -t nat -A OUTPUT -j PORTFW", logger=self.logger)

        # We don't need to mark any packet coming from or going to localhost
        iptables("iptables -t mangle -A PREROUTING -i lo -j ACCEPT", logger=self.logger)
        iptables("iptables -t mangle -A INPUT -i lo -j ACCEPT", logger=self.logger)
        iptables("iptables -t mangle -A OUTPUT -o lo -j ACCEPT", logger=self.logger)

        # Custom postrouting chain (for port forwarding)
        iptables("iptables -t nat -N POSTPORTFW", logger=self.logger)
        iptables("iptables -t nat -A POSTROUTING -j POSTPORTFW", logger=self.logger)

        #
        # ROUTING STUFF
        #

        #
        # We have here the following cases to handle:
        #
        # A) Simple POLICY ROUTING. Packets come in, get marked and go out through
        #    a special interface determined by the routing decision based on the mark.
        #
        # B) LOAD BALANCING. Connections with the same parameters will not always go
        #    out through the same interface, but packets of the same connections need
        #    to go out through the same interface. The solution is to use stateful marks.
        #
        # C) PORT FORWARDINGS which come in through an interface through which the default
        #    gateway does *NOT* go out. Returning packets need to go out through the same
        #    interface and not through the default gateway interface.
        #    (This probably is not an issue which we need to handle here)
        #

        #
        # First of all. It's always simply policy routing and it always needs to be
        # stateful.
        #
        # Due to the statefulness, there is another issue to handle:
        #
        # Basically, packets of a NEW connection from A to B will be marked, which is fine.
        # (Task 1)
        #
        # So all packets going from A to B which belong to this connection need also to be
        # marked. This can be achieved by restoring the mark from the connection, fine.
        # (Task 2)
        #
        # But, that will also restore the marks of the returning packets from B to A which
        # belong to the same connection. That will cause to route out the replies through the
        # same interface as they came in, which is not what we want.
        #      So they need to be unmarked if they don't come in through the same interface
        # as the first packet which has created the connection (status NEW).
        # (Task 3)
        #
        # In order to know through which interface the connection has been created it is
        # necessary to store that information with another CONNMARK.
        #     Since we have only one field for marks, we need to mask them.
        # (Task 4)
        #

        #
        # nfmark Bitfield allocation:
        # 31..0  full size
        # bits  | width   | hex    | mask        | description
        # ------+---------+--------+-------------+--------------------------------------------
        # 0-1   |  2 bits | 0x2    | 0x3         | application firewall
        # 2-2   |  1 bit  | 0x1    | 0x4         | QUEUE/NFQUEUE for snort
        # 3-10  |  8 bits | 0xFF   | 0x7F8       | Policy Routing
        # 11-17 |  7 bits | 0x7F   | 0x3F800     | Interface mark
        # 18-18 |  1 bits | 0x1    | 0x40000     | physdev-out ebtables check enable/disable
        # 19-28 | 10 bits | 0x1FFF | 0x1FF80000  | physdev-out ebtables match
        # 29-29 |  1 bits | 0x1    | 0x20000000  | TPROXY
        # 29-31 |  2 bits | 0x2    | 0xC0000000  | reserved
        # ------+---------+--------+-------------+--------------------------------------------
        #

        # 00000000 00000000 00000000 00000000    | 0x0
        # 00000000 00000000 00000000 00000011    | 0x3
        # 00000000 00000000 00000000 00000100    | 0x4
        # 00000000 00000000 00000111 11111000    | 0x7F8
        # 00000000 00000011 11111000 00000000    | 0x3F800
        # 00000000 00000100 00000000 00000000    | 0x40000
        # 00011111 11111000 00000000 00000000    | 0x1FF80000
        # 00100000 00000000 00000000 00000000    | 0x20000000
        # 11000000 00000000 00000000 00000000    | 0xC0000000

        #
        # Mask is hardcoded in:
        #
        # type            | package                 | location
        # ----------------+-------------------------+--------------------------------------
        # Application fw  | efw-firewall            | firewall.py
        # QUEUE for snort | efw-firewall            | firewall.py queuefw/rules.tmpl
        # Policy routing  | efw-network             | setpolicyrouting.py
        # Policy routing  | efw-network             | uplinks/generic/route.sh
        # Policy routing  | efw-network             | setinterfacemark.py
        # Interface mark  | efw-network             | setinterfacemark.py
        # physdev-out     | efw-firewall            | setzonefw.py and rules.tmpl and rc.firewall on top
        #

        iptables("iptables -t mangle -N INCOMINGMARK", logger=self.logger)
        iptables("iptables -t mangle -N LOCALMARK", logger=self.logger)
        iptables("iptables -t mangle -N CHECKIIF", logger=self.logger)
        iptables("iptables -t mangle -N MARKIIF", logger=self.logger)

        iptables("iptables -t mangle -N ROUTING", logger=self.logger)
        iptables("iptables -t mangle -A PREROUTING -j ROUTING", logger=self.logger)

        # Local processes don't start going through PREROUTING, only through OUTGOING.
        # BUT responses go through PREROUTING, so the rules within ROUTING chain should
        # do their work also for connections starting from local. In this case iifmark is
        # left to 0.
        iptables("iptables -t mangle -N LOCALROUTING", logger=self.logger)
        iptables("iptables -t mangle -A OUTPUT -j LOCALROUTING", logger=self.logger)

        # exclude interfaces to which policy routing makes no sense
        iptables("iptables -t mangle -A ROUTING -j RETURN -i lo", logger=self.logger)
        iptables("iptables -t mangle -A ROUTING -j RETURN -o lo", logger=self.logger)
        iptables("iptables -t mangle -A LOCALROUTING -j RETURN -i lo", logger=self.logger)
        iptables("iptables -t mangle -A LOCALROUTING -j RETURN -o lo", logger=self.logger)

        # Task 2
        iptables("iptables -t mangle -A ROUTING -m state ! --state NEW -m connmark ! --mark 0x0 -j CONNMARK --restore-mark", logger=self.logger)
        iptables("iptables -t mangle -A LOCALROUTING -m state ! --state NEW -m connmark ! --mark 0x0 -j CONNMARK --restore-mark", logger=self.logger)
        # Task 3
        iptables("iptables -t mangle -A ROUTING -m state ! --state NEW -m connmark ! --mark 0x0 -j CHECKIIF", logger=self.logger)
        iptables("iptables -t mangle -A LOCALROUTING -m state ! --state NEW -m connmark ! --mark 0x0 -j CHECKIIF", logger=self.logger)
        # Task 4
        iptables("iptables -t mangle -A ROUTING -m state --state NEW -j MARKIIF", logger=self.logger)
        iptables("iptables -t mangle -A LOCALROUTING -m state --state NEW -j MARKIIF", logger=self.logger)
        # Task 1
        iptables("iptables -t mangle -A ROUTING -m state --state NEW -j INCOMINGMARK", logger=self.logger)
        iptables("iptables -t mangle -A LOCALROUTING -m state --state NEW -j LOCALMARK", logger=self.logger)

        # Example entries for CHECKIIF
        #  iptables("iptables -t mangle -A CHECKIIF -i br0  -m connmark ! --mark 0x100/0x3F800 -j MARK --and-mark 0xFFFFFF00", logger=self.logger)
        #  iptables("iptables -t mangle -A CHECKIIF -i eth3 -m connmark ! --mark 0x200/0x3F800 -j MARK --and-mark 0xFFFFFF00", logger=self.logger)

        # Example entries for MARKIIF
        #  iptables("iptables -t mangle -A MARKIIF -i br0  -j CONNMARK --set-mark 0x100/0x3F800", logger=self.logger)
        #  iptables("iptables -t mangle -A MARKIIF -i eth3 -j CONNMARK --set-mark 0x200/0x3F800", logger=self.logger)

        # Those need to be created by a python script which searches all interfaces and registers
        # them assigning the mark value as a ticket.

        # creates chain for policy routing
        iptables("iptables -t mangle -N POLICYROUTING", logger=self.logger)
        iptables("iptables -t mangle -N LOCALPOLICYROUTING", logger=self.logger)
        iptables("iptables -t mangle -A INCOMINGMARK -j POLICYROUTING", logger=self.logger)
        iptables("iptables -t mangle -A LOCALMARK -j LOCALPOLICYROUTING", logger=self.logger)

        # restores the connmark to the packet
        iptables("iptables -t mangle -A INCOMINGMARK -j CONNMARK --restore-mark", logger=self.logger)
        iptables("iptables -t mangle -A LOCALMARK -j CONNMARK --restore-mark", logger=self.logger)

        # run local firewall configuration, if present
        if os.path.exists("/var/efw/inithooks/rc.firewall.local"):
            run("/var/efw/inithooks/rc.firewall.local start")

        # last rule in input and forward chain is for logging.
        iptables("iptables -A INPUT   -j LOG_INPUT", logger=self.logger)
        iptables("iptables -A FORWARD -j LOG_FORWARD", logger=self.logger)

        if not options.get("onboot", False):
            send_cmd_to_engine("emit event(msg:firewall_restart)")

    @action(name="stop",
            options={"debug": (bool, "Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        self.iptables_init()

        # Accept everyting connected
        iptables("iptables -A INPUT   -m state --state ESTABLISHED,RELATED -j HANDLE_ESTABLISHED", logger=self.logger)

        # localhost and ethernet.
        iptables("iptables -A INPUT -i lo -j ACCEPT", logger=self.logger)
        iptables("iptables -A INPUT -i %s -m state --state NEW -j ALLOW" % self.settings["GREEN_DEV"], logger=self.logger)

        iptables("iptables -N REDINPUT", logger=self.logger)
        iptables("iptables -A INPUT -j REDINPUT", logger=self.logger)

        # run local firewall configuration, if present
        if os.path.exists("/etc/rc.d/rc.firewall.local"):
            run("/etc/rc.d/rc.firewall.local stop")

        # last rule in input and forward chain is for logging.
        iptables("iptables -A INPUT   -j LOG_INPUT", logger=self.logger)
        iptables("iptables -A FORWARD -j LOG_FORWARD", logger=self.logger)

    @action(name="reload",
            exit_status="start",
            options={"debug": (bool, "Be more verbose.")}
            )
    def reload(self, options):
        self.info("Reload firewall")
        self.iptables_zonechains()
        self.ebtables_zonechains()
        self.iptables_defaultfw()
        self.iptables_setlog()

        # run local firewall configuration, if present
        if os.path.exists("/etc/rc.d/rc.firewall.local"):
            run("/etc/rc.d/rc.firewall.local reload")

        send_cmd_to_engine("emit event(msg:firewall_restart)")

    @action(name="start",
            on="startup",
            depends=["network", "monit"],
            priority=12,
            options={"debug": (bool, "Be more verbose.")}
            )
    def start(self, options):
        Job.start(self, options)
        options["force"] = True
        self.restart(options)

    @action(name="updatewizard",
            on="updatewizard",
            priority=30,
            exit_status="start",
            options={"debug": (bool, "Be more verbose.")}
            )
    def updatewizard(self, options):
        self.info("Updatewizard firewall")
        self.restart(options)
        send_cmd_to_engine("emit event(msg:firewall_restart)")
