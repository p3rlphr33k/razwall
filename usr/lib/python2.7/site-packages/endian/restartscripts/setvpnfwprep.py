#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2010 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import copy
import iplib
import math
import tempfile
from endian.job.commons import *
from endian.datatypes.network import CIDR
from endian.validators.boolean import to_bool
from endian.core.zones import getZones
from endian.core.settingsfile import SettingsFile
from endian.datatypes.config_dict import ConfigDict

CHAIN = "VPNFWDST"

ETHERNET_SETTINGS = "/var/efw/ethernet/settings"
STATE = "/etc/firewall/vpnfw/iptablesvpnfwprep"
TMPFILE = "/var/tmp/iptableszonefwprep"
TMPL = "/etc/firewall/vpnfw/rulesprep.tmpl"
BRIDGETMPL = "/etc/firewall/vpnfw/rulesvpnbridge.tmpl"
LOG_SETTINGS='/var/efw/logging/settings'


class RuleEntry:
    def __init__(self):
        self._meta = ['enabled', 'log', 'dst_ip', 'proto', 'dst_iprange_start', 'dst_iprange_end']
        self.enabled = 'on'
        self.log = 'off'
        self.proto = ''
        self.dst_ip = '0/0'
        self.dst_iprange_start = ''
        self.dst_iprange_end = ''
        self.dst_port = ''
        self.i = 0


class SetVPNFirewallPreparation(Job):

    settings = None
    tmpl = None
    bridge_tmpl = None
    script = None
    
    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "trace":(bool,"Display iptables shell script trace.")}  
            )    
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False        
        options['force'] = options.get('force', False)
        self.start(options)
        
    @action(name="start",
            depends=["firewall=start"],
            exit_status="start",
            on="startup_done",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces start."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def start(self, options):
        Job.start(self, options)
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        self.load_config()

        self.info("Restart VPN firewall preparation, force: %s", options.get('force'))
        changed = self.save_config()
    
        if changed or options.get('force'):
            self.debug("Save script to state file '%s'", STATE)
            shutil.copy(self.script.name, STATE)
    
            self.debug("Call iptables script %s", self.script.name)
            iptables(script=self.script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        
    def load_config(self):
        self.settings = ConfigDict()
        self.settings.update(SettingsFile('openvpn/settings'))
        self.settings.update({'ZONES': getZones()})
        
        self.tmpl = Template.compile(file=TMPL)
        self.bridge_tmpl = Template.compile(file=BRIDGETMPL)

        self.settings.update(SettingsFile('logging/settings'))
        self.debug(self.settings)

    def insert_rule(self, obj, log=False):
        methods = {}    
        obj.log = log
        cmd = str(self.tmpl(namespaces = [obj, methods]))
        self.debug("Create rule nr %d: %s", obj.i, cmd)
        return cmd.strip()
    
    def explode_rules(self, line, explodefields):
        if line.enabled != 'on':
            return
        rules = []
        rules.append(line)
        for field in explodefields:
            tmprules = []
            fieldval = getattr(line, field)
            if fieldval == '':
                continue
            for value in fieldval.split('&'):
                if value == '':
                    continue
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rulenum = len(rules)
        if rulenum > 1:
            self.debug("Exploded rules to %d", rulenum)
        return rules

    def split_network(self, network, slices):
        cidr = iplib.CIDR(network)
        nr_ips = 2 ** (32 - int(cidr.nm.get_bits()))
        n = nr_ips / slices
        closest_pow = 2 ** int(math.log(n, 2))
        parts = [closest_pow] * (slices-1)
        ips_left = nr_ips - sum(parts)
        if ips_left > closest_pow and ips_left != 2 ** int(math.log(ips_left, 2)):
            ips_left = closest_pow
        parts.append(ips_left)
        nets = []
        base_ip = cidr.ip
        for x in parts:
            nm = int(32 - math.log(x, 2))
            net = '%s/%d' % (base_ip.get(), nm)
            nets.append(net)
            base_ip = base_ip + x
        return nets

    def explode_server_cores(self, config):
        core_confs = []
        name = config['name']
        cores = int(config.get('number_of_cores') or 1)

        purple_ips_begin = []
        purple_ips_end = []
        purple_nets = []
        if config.get('bridged'):
            purple_ip_begin = config['purple_ip_begin']
            purple_ip_end = config['purple_ip_end']
            first_ip = iplib.IPv4Address(purple_ip_begin)
            last_ip = iplib.IPv4Address(purple_ip_end)
            nr_of_ips = int(last_ip - first_ip) + 1
            ips_per_core = nr_of_ips / cores
            cycle_first_ip = iplib.IPv4Address(first_ip.get())
            for x in xrange(cores):
                purple_ips_begin.append(cycle_first_ip.get())
                purple_ips_end.append((cycle_first_ip+ips_per_core-1).get())
                cycle_first_ip = cycle_first_ip+ips_per_core
            purple_ips_end[-1] = last_ip.get()
        else:
            purple_nets = self.split_network(config['purple_net'], cores)

        for core in xrange(cores):
            core_conf = config.copy()
            core_conf['core_nr'] = core
            core_conf['name_core'] = '%s_%s' % (name, core)
            bridged = config.get('bridged')
            if bridged:
                core_conf['purple_ip_begin'] = purple_ips_begin[core]
                core_conf['purple_ip_end'] = purple_ips_end[core]
            if cores > 1:
                if not bridged:
                    core_conf['purple_net'] = purple_nets[core]
            core_confs.append(core_conf)
        return core_confs

    def get_servers(self):
        return [dict(x) for x in DataSource("openvpn").server or []]

    def get_purple_devices(self):
        try:
            from endian.core.pdict import PersistentDict
            pd = PersistentDict('/var/cache/var.efw.vpn.servers')
            purple_devices = set()
            servers = self.get_servers()
            for conf in servers:
                if not conf.get('enabled'):
                    continue
                purple_devs = pd.get(conf.get('id'), {}).get('purple_devices') or []
                for idx, core in enumerate(self.explode_server_cores(conf)):
                    purple_device = purple_devs[idx]
                    val = (purple_device, core.get('bridged'),
                            conf.get('purple_ip_begin'), conf.get('purple_ip_end'),
                            conf.get('purple_net'))
                    purple_devices = purple_devices.union([val])
            return list(purple_devices)
        except Exception, e:
            self.logger.error('error getting the list of PURPLE devices: %s', e)
            return []

    def get_rules(self):
        if self.settings == None:
            self.load_config()
        rules = []
        if self.settings.get('OPENVPN_ENABLED', 'off') != 'on':
            return rules

        for purple_dev, bridged, purple_ip_begin, purple_ip_end, purple_net \
                in self.get_purple_devices():
            add = RuleEntry()
            if bridged:
                add.dst_iprange_start = purple_ip_begin
                add.dst_iprange_end = purple_ip_end
            else:
                add.dst_ip = purple_net
            rules.append(add)
        
        dsts = []
        dsts.extend(self.get_remote_VPN_nets())
        dsts.extend(self.get_VPN_static_ips())
        for net in dsts:
            add = RuleEntry()
            add.dst_ip = net
            rules.append(add)
        return rules

    def generate_script(self):
        if self.settings == None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE)
        
        self.debug("Generate iptables script")
        script.write("iptables -F %s\n" % CHAIN)
        script.write("iptables -t mangle -F %s\n" % CHAIN)
        script.write("iptables -F VPNFWBRIDGE\n")
        script.write("iptables -t mangle -F VPNFWBRIDGE\n")
        self.settings['CORES'] = []
        servers = self.get_servers()

        for conf in servers:
            if not conf.get('enabled'):
                continue
            for core in self.explode_server_cores(conf):
                self.settings['CORES'].append(conf)
    
        cmd = str(self.bridge_tmpl(namespaces = [self.settings]))
        script.write(cmd)

        for i, rule in enumerate(self.get_rules()):
            rule.i = i
            if rule.enabled != 'on':
                continue
            log = (rule.log == 'on')
            if self.settings.get('LOG_ACCEPTS') == 'on':
                if rule.target == 'ACCEPT':
                    log = True
            if self.settings.get('DISABLE_FIREWALL_LOGS','off') == 'on':
                log = False
            # ICMP hack
            if rule.proto == 'icmp':
               rule.dst_port = '8&30'
            for item in self.explode_rules(rule, []):
                try:
                    script.write(self.insert_rule(item, log))
                    script.write("\n")
                except Exception, e:
                    self.warning("Explosion throws error '%s'", e)
                    continue
        script.flush()
        return script
    
    def save_config(self):
        self.script = self.generate_script()
        if not os.path.exists(STATE):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, STATE, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed

    def get_remote_VPN_nets(self, user=None):
        import openvpnutils
        ret = []
    
        list = []
        if user == None:
            list = openvpnutils.getPasswdEntries().itervalues()
        else:
            list.append(openvpnutils.getUser(user))
        for userconf in list:
            for net in userconf['remotenet'].split(","):
                net = net.strip()
                try:
                    ret.append(CIDR(net))
                except:
                    if net != '':
                        self.debug("'%s' is no valid subnet.", net)
                    continue
        return ret
    
    def get_VPN_static_ips(self):
        import openvpnutils
        ret = []
    
        for userconf in openvpnutils.getPasswdEntries().itervalues():
            for ip in userconf.get('static_ip', '').split(','):
                ip = ip.strip()
                if ip == '':
                    continue
                if ip.find('/') == -1:
                    ip = ip+'/32'
                try:
                    ret.append(CIDR(ip))
                except:
                    self.debug("'%s' is no valid ip or subnet.", ip)
                    continue
        return ret
