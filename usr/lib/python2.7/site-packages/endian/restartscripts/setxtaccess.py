#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2010 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import copy
import tempfile
from endian.job.commons import *
from endian.data.container.csvconfig import CsvConfigFile
from endian.core.zones import getZones

CONFIGBASE='/var/efw/'
CHAIN='INPUTFW'

CONFIG='/var/efw/xtaccess/config'
STATE='/etc/firewall/inputfw/iptablesinputfw'
TMPFILE="/var/tmp/iptablesinputfw"
SETTINGS='/var/efw/xtaccess/settings'
ETHERNET_SETTINGS='/var/efw/ethernet/settings'
OPENVPNDIR='/var/efw/openvpnclients/'
OPENVPN_SETTINGS='/var/efw/openvpn/settings'
NEEDRELOAD='/var/efw/xtaccess/needreload'

TMPL='/etc/firewall/inputfw/rules.tmpl'

DEFINITIONS = { }
NEED_BRIDGE = ['68', '67']

LOG_SETTINGS='/var/efw/logging/settings'
HOTSPOT_SETTINGS='/var/efw/hotspot/settings'


class SetXTAccessJob(Job):
    
    settings = None
    script = None
    tmpl = None    
    _uplink_pool = None
    _redInterfacesCache = None
    _openvpnDevicesCache = None
    _zoneCache = None

    def get_uplink_pool(self):
        from uplinksdaemon.uplinks import UplinksPool
        if self._uplink_pool != None:
            return self._uplink_pool
        self._uplink_pool = UplinksPool()
        return self._uplink_pool
    
    def all_red_interfaces(self):
        if self._redInterfacesCache != None:
            return self._redInterfacesCache
        self._redInterfacesCache = []
        try:
            for uplink in self.get_uplink_pool().getActiveUplinks():
                if uplink.getSettings()['RED_TYPE'] == 'NONE':
                    continue
                data = uplink.getData()
                dev = data.get('INTERFACE')
                if uplink.getSettings()['RED_TYPE'] == 'STEALTH':
                    if 'BRIDGE_PORT' in data:
                        dev = "PHYSDEV:%s" % data.get('BRIDGE_PORT')
                    else:
                        continue
                self._redInterfacesCache.append(dev)
        except:
            pass
        return self._redInterfacesCache
    
    def get_interface_by_uplink(self, uplink):
        if uplink != 'ANY':
            ul = self.get_uplink_pool().get(uplink)
            if ul.getSettings()['RED_TYPE'] == 'NONE':
                return []
            data = ul.getData()
            dev = data.get('INTERFACE')
            if 'BRIDGE_PORT' in data:
                dev = "PHYSDEV:%s" % data.get('BRIDGE_PORT')
            if dev != None:
                return [dev]
            return []
        else:
            return self.all_red_interfaces()
 
    def all_openvpn_interfaces(self):
        if self._openvpnDevicesCache != None:
            return self._openvpnDevicesCache
        self._openvpnDevicesCache = []
        for ov in glob.glob(OPENVPNDIR+'/*'):
            dev = self.get_interface_by_openvpn_name(os.path.basename(ov))
            if dev == None:
                continue
            self._openvpnDevicesCache.append(dev)
        return self._openvpnDevicesCache
    
    def get_interface_by_openvpn_name(self, name):
        filename = os.path.join(OPENVPNDIR, name, 'settings')
        if not os.path.exists(filename):
            return None
        conf = get_config(filename)
        if conf.get('DEVICE', '') == '':
            return None
        device = conf['DEVICE']
        if conf.get('ROUTETYPE', 'routed') == 'bridged':
            return "PHYSDEV:%s"%device
        return device
    
    def get_purple_devices(self, server_name=None):
        try:
            from endian.core.pdict import PersistentDict
            pd = PersistentDict('/var/cache/var.efw.vpn.servers')
            servers = DataSource("openvpn").server or []
            purple_devices = set()
            for conf in servers:
                if not conf.get('enabled'):
                    continue
                if server_name is not None and server_name != conf.get('name'):
                    continue
                id_ = conf.get('id')
                if not id_:
                    continue
                purple_dev = pd.get(id_, {}).get('purple_devices') or []
                bridged = conf.get('bridged')
                for pdev in purple_dev:
                    purple_devices = purple_devices.union([(pdev, bridged)])
            return list(purple_devices)
        except Exception, e:
            self.logger.error('error getting the list of PURPLE devices: %s', e)
            return []

    def get_vpn_device(self, conn):
        if conn == 'ANY':
            ov = []
            ov.extend(self.all_openvpn_interfaces())
            ov.append('ipsec+')
            ov.append('l2tp+')
            for device, bridged in self.get_purple_devices():
                if bridged:
                    device = 'PHYSDEV:%s' % device
                ov.append(device)
            return ov
        if conn == 'SERVER':
            res = []
            for device, bridged in self.get_purple_devices():
                if bridged:
                    device = 'PHYSDEV:%s' % device
                res.append(device)
            return res
        if conn and conn.startswith('SERVER:'):
            res = []
            for device, bridged in self.get_purple_devices(server_name=conn.split(':', 1)[1]):
                if bridged:
                    device = 'PHYSDEV:%s' % device
                res.append(device)
            return res
        if conn == 'IPSEC':
            return ['ipsec+']
        if conn == 'L2TP':
            return ['l2tp+']
        ret = []
        tap = self.get_interface_by_openvpn_name(conn)
        if tap != None:
            ret.append(tap)
        return ret
    
    def insert_rule(self, obj, tmpl, log=False):
        methods = {}
    
        obj.log = log
        self.satanize_rule(obj)
        cmd = str(tmpl(namespaces = [obj, methods, DEFINITIONS]))
        self.debug("Create rule nr %d: %s", obj.i, cmd)
        return cmd.strip()
    
    def explode_rules(self, line, explodefields):
        if line.enabled != 'on':
            return
        rules = []
        rules.append(line)
        for field in explodefields:
            tmprules = []
            fieldval = getattr(line, field)
            if fieldval == None:
                continue
            for value in fieldval:
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rulenum = len(rules)
        if rulenum > 1:
            self.debug("Exploded rules to %d", rulenum)
        return rules
    
    def subst_VPN_dev(self, dev, rule=None, item=None):
        if not dev.startswith('VPN:'):
            return [dev]
    
        self.debug("Substitute VPN '%s'", dev)
        openvpnconn = dev.split(':', 1)[1]
        if openvpnconn == '':
            self.debug("Key '%s' contains no value.", dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.get_vpn_device(openvpnconn)
        if len(devlist) <= 0:
            self.debug("Connection '%s' has no Devices.", openvpnconn)
            raise KeyError("Connection '%s' has no Devices."%openvpnconn)
        self.debug("Substituted VPN '%s' to: %s", dev, devlist)
        return devlist
    
    def subst_uplink_dev(self, dev, rule=None, item=None):
        if not dev.startswith('UPLINK:'):
            return [dev]
        self.debug("Substitute UPLINK '%s'", dev)
        uplink = dev.split(':')[1]
        if uplink == '':
            self.debug("Key '%s' contains no value.", dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.get_interface_by_uplink(uplink)
        if len(devlist) <= 0:
            self.debug("Uplink '%s' has no Devices.", uplink)
            raise KeyError("Uplink '%s' has no Devices."%uplink)
        self.debug("Substituted UPLINK '%s' to: %s", dev, devlist)
        return devlist

    def get_zone_cache(self):
        if self._zoneCache is None:
            self._zoneCache = getZones()
        return self._zoneCache

    def subst_zone_no_stealth_uplinks(self, value):
        zone_cache = self.get_zone_cache()
        # If zone is not defined, return XX_DEV
        try:
            members = set(zone_cache[value].members)
        except KeyError:
            return [self.settings['%s_DEV' % value]]
        # Find stealth uplinks
        stealth_uplinks = set()
        for intf in self.all_red_interfaces():
            if intf.startswith("PHYSDEV:"):
                stealth_uplinks.add(intf[8:])
        # If no stealth uplink is member of this zone,
        # return XX_DEV
        members_no_stealth_uplinks = members - stealth_uplinks
        if members_no_stealth_uplinks == members:
            return [self.settings['%s_DEV' % value]]
        # Explode members via PHYSDEV:<device>,
        # avoiding stealth uplinks
        return ["PHYSDEV:%s" % x for x in sorted(members_no_stealth_uplinks)]

    def subst_zones(self, value, rule=None, item=None):
        if value == 'ALL' or value == 'ANY' or value == '':
            return ['']
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED', 'HOTSPOT']:
            return [value]
        self.debug("Substitute ZONE '%s'", value)
        if value != 'RED':
            dev = self.subst_zone_no_stealth_uplinks(value)
            self.debug("Substituted ZONE '%s' to: %s", value, dev)
            return dev
        redifs = self.get_interface_by_uplink('ANY')
        if len(redifs) <= 0:
            self.debug("Substitution of ZONE '%s' failed. No red interface is up!", value)
            raise Exception("No red interface is up")
        self.debug("Substituted ZONE '%s' to: %s", value, redifs)
        return redifs
    
    def split_address_from_device(self, value, rule=None, item=None):
        item['ip'] = None
        if value.find(":") != -1:
            split = value.split(":")
            ip = split[0]
            dev = ":".join(split[1:])
            if is_ipaddress(ip):
                self.debug("Splitted away address '%s' from value '%s'", ip, value)
                item['ip'] = ip
                return [dev]
        self.debug("Don't split address from value '%s'", value)
        return [value]
    
    def subst_iter(self, values, cb, rule=None, iterkey='value'):
        if not values:
            return values
        if cb == None:
            return values
        ret = []
        empty = True
        for i in values:
            if i == None:
                continue
            value = None
            try:
                value = cb(i[iterkey], rule, i)
            except:
                self.debug("Substitution failed", exc_info=True)
                continue
            if value == None or len(value) == 0:
                continue
            for l in value:
                item = copy.deepcopy(i)
                item[iterkey] = l
                ret.append(item)
            empty=False
        if empty:
            self.debug("No suitable value found for substitution of '%s'", values)
            raise Exception("No suitable value found for substitution")
        return ret
    
    def substitute_values(self, rule):
        try:
            rule.src_dev = self.subst_iter(rule.src_dev, self.split_address_from_device)
            rule.src_dev = self.subst_iter(rule.src_dev, self.subst_VPN_dev)
            rule.src_dev = self.subst_iter(rule.src_dev, self.subst_uplink_dev)
            rule.src_dev = self.subst_iter(rule.src_dev, self.subst_zones)
            rule.src_dev = self.subst_iter(rule.src_dev,
                                           self.substL2tpDevice.process)
            return rule
        except:
            self.debug("Could not substitute: ", exc_info=True)
            return None
    
    def split_mac(self, rule):
        if is_macaddress(rule.src_ip['value']):
            rule.mac = rule.src_ip['value']
            rule.src_ip['value'] = ''
    
    def move_if_ip_to_dst(self, rule):
        if rule.src_dev['ip'] != None:
            rule.dst_ip = {'value': rule.src_dev['ip']}
    
    def post_explodes(self, rule):
        self.split_mac(rule)
        self.move_if_ip_to_dst(rule)
    
    def satanize_rule(self, item):
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in=False
        item.physdev_out=False
        if item.src_dev.startswith('PHYSDEV'):
            item.physdev_in=True
            item.src_dev = item.src_dev.split(":")[1]
        item.logtarget = item.target
        if item.target == '':
            item.target = 'ACCEPT'
    
        for e in NEED_BRIDGE:
            if item.dst_port == e:
                item.bridge = True
        if item.proto == 'ether':
            item.bridge = True

        if item.src_ip == '':
            item.src_ip = '0/0'
        if item.dst_ip == '':
            item.dst_ip = '0/0'
        if item.logprefix == '':
            item.logprefix = 'INPUTFW'
        item.ipsecin = False
        item.ipsecout = False
        if item.src_dev == 'ipsec+':
            item.src_dev = ''
            item.ipsecin = True
        return item
    
    def get_rules(self):
        ret = []
        self.debug("Read from '%s'", CONFIG)
        try:
            rules=CsvConfigFile(
                '/usr/lib/efw/xtaccess/config.config',
                CONFIG,
                tolerant=True,
                )
            ret.extend(rules)
        except Exception, e:
            self.error("Could not load config file '%s', because: %s!" % (CONFIG, e))
        return ret
    
    def translate_to_lists(self, rule, keys, delimiter='&'):
        for key in keys:
            tmp = getattr(rule, key)
            list = tmp.split(delimiter)
            if len(list) > 1:
                list = filter(lambda x: x != '', list)
            setattr(rule, key, map(lambda x: {'value': x}, list))
    
    def translate_from_dict(self, rule, explodingKeys):
        for key in explodingKeys:
            value = getattr(rule, key)
            setattr(rule, key, value['value'])

    def generate_script(self):
        if self.settings == None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE)
        
        i = 0
        self.debug("Generate iptables script")
        script.write("iptables -F %s\n" % CHAIN)
        script.write("ebtables -F %s\n" % CHAIN)
        for rule in self.get_rules():
            i += 1
            rule.i = i
            if rule.enabled != 'on':
                continue
            log = (rule.log == 'on')
            if self.settings['LOG_ACCEPTS'] == 'on':
                if rule.target in ['ACCEPT', 'ALLOW']:
                    log = True
            if self.settings.get('DISABLE_FIREWALL_LOGS','off') == 'on':
                log = False
    	    # ICMP hack
            if rule.proto == 'icmp':
    	       rule.dst_port = '8&30'
            explodingKeys = ['proto', 'src_ip', 'dst_ip', 'dst_port', 'src_dev']
            self.translate_to_lists(rule, explodingKeys)
            if self.substitute_values(rule) == None:
                continue
            for item in self.explode_rules(rule, explodingKeys):
                self.post_explodes(item)
                self.translate_from_dict(item, explodingKeys)
                try:
                    script.write(self.insert_rule(item, self.tmpl, log))
                    script.write("\n")
                except Exception, e:
                    self.debug("Explosion failed", exc_info=True)
                    continue
        script.flush()
        return script

    def save_config(self):
        self.script = self.generate_script()
    
        if not os.path.exists(STATE):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, STATE, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed

    def load_config(self):
        from endian.firewall.substitutors.l2tp import SubstL2tpDevice
        self.settings = get_config(SETTINGS)
        self.settings.update(get_config(ETHERNET_SETTINGS))
        self.settings.update(get_config(OPENVPN_SETTINGS))
        self.settings.update(get_config(LOG_SETTINGS))
        self.settings.update(get_config(HOTSPOT_SETTINGS))
        self.tmpl = Template.compile(file=TMPL)
        self.substL2tpDevice = SubstL2tpDevice(self.logger, listSeparator=None)

    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False        
        options['force'] = options.get('force', False)
        self.start(options)
        
    @action(name="start",
            depends=["firewall=start"], 
            exit_status="start",
            on=["system_accessible", "startup_done"],
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces start."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def start(self, options):
        Job.start(self, options)
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        
        self.info("Restart INPUTFW firewall, force: %s", options.get('force'))
        changed = self.save_config()
    
        if changed or options.get('force'):
            self.debug("Save script to state file '%s'", STATE)
            shutil.copy(self.script.name, STATE)
    
            self.debug("Call iptables script %s", self.script.name)
            iptables(script=self.script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()
            
        if os.path.exists(NEEDRELOAD):
            os.unlink(NEEDRELOAD)

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
            
    @action(name="firewall_restart", 
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart setxtaccess")
        options['force'] = True
        self.start(options)

