#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2012-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | efw-ipsec is free software: you can redistribute it and/or modify it     |
# | under the terms of GNU General Public License (GPL) version 2.0          |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | efw-ipsec is distributed in the hope that it will be useful,             |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with efw-ipsec.     |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+

from endian.job.commons import *
from endian.core.logger import *
from endian.ipsec.conf_utils import get_connections
import iplib


CONFIGBASE = '/var/efw/'
VPN_DIR = CONFIGBASE + '/vpn/'
ETHER_SETTINGS = '/var/efw/ethernet/settings'

FIREWALL = "/etc/firewall/inputfw/ipsec.conf"
IPSEC_LOGROTATE = "/etc/logrotate.d/ipsec"

VAR_RUN = "/var/run/"
HA_SETTINGS = '/var/efw/ha/settings'

VAR = "/var/efw/vpn/"
ETC = "/etc/ipsec/"
CONF = "ipsec.conf"
SECRETS = "ipsec.secrets"

HOSTCERT = "/var/efw/vpn/ca/certs/hostcert.pem"
SESSIONS_XAUTH = "/var/efw/access/sessions.ipsec-xauth"
SESSIONS_L2TP = "/var/efw/access/sessions.l2tp"
CONNECTION_RE = re.compile("(.*)\[(\d+)\]:\s*(\w+)\s*(.*),.*")


class IpsecJob(Job):

    config_values = None
    _shouldstart = None

    def has_blue(self):
        if not self.config_values:
            self.load_config()
        return int(self.config_values.get('CONFIG_TYPE')) in [4, 5, 6, 7]

    def has_orange(self):
        if not self.config_values:
            self.load_config()
        return int(self.config_values.get('CONFIG_TYPE')) in [1, 3, 5, 7]

    def ipcidr2netcidr(self, iplist):
        ret = []
        for ips in iplist.split(','):
            try:
                if ips == '':
                    continue
                cidr = iplib.CIDR(ips)
                net = cidr.get_network_ip().get()
                net = cidr.get_network_ip().get()
                bits = cidr.get_netmask().get_bits()
                ret.append("%s/%s" % (net, bits))
            except:
                pass
        return ",".join(ret)

    def save_config(self):
        if not self.config_values:
            self.load_config()
        changed = {}
        write_config(IPSEC_LOGROTATE + ".tmpl", IPSEC_LOGROTATE, self.config_values)
        changed["xtaccess"] = write_config(FIREWALL + ".tmpl",
                                           FIREWALL,
                                           self.config_values)
        if not self.shouldstart():
            return changed
        changed["ipsec"] = write_config(os.path.join(ETC, CONF) +'.tmpl',
                                        os.path.join(ETC, CONF),
                                        self.config_values)
        changed["ipsec"] |= write_config(os.path.join(ETC, SECRETS) + '.tmpl',
                                         os.path.join(ETC, SECRETS),
                                         self.config_values)
        return changed

    def shouldstart(self):
        if self._shouldstart is not None:
            return self._shouldstart
        if not self.config_values:
            self.load_config()
        if self.config_values.get('ENABLED', 'off') == 'on':
            self._shouldstart = True
            return True
        # if service is disabled vpn shouldn't work neither on blue or orange
        # if self.has_blue() and self.config_values.get('ENABLED_BLUE', 'off') == 'on':
        #    self._shouldstart = True
        #    return True
        # if self.has_orange() and self.config_values.get('ENABLED_ORANGE', 'off') == 'on':
        #    self._shouldstart = True
        #    return True
        self._shouldstart = False
        return False

    def load_config(self):
        from endian.ipsec.common import get_debug_options
        ds = DataSource()
        self.config_values = {}
        self.config_values.update(get_config(HA_SETTINGS))
        self.config_values.update(get_config(ETHER_SETTINGS))
        self.config_values.update(ds.vpn.settings)
        self.config_values['DS'] = ds

        self.config_values['CERT_KEY'] = self.config_values.get('CERT_FILENAME', '')[:-8] + "key.pem"
        self.config_values['GREEN_SUBNETS'] = [x for x in self.ipcidr2netcidr(self.config_values.get('GREEN_IPS', '')).split(',') if x]
        self.config_values['BLUE_SUBNETS'] = [x for x in self.ipcidr2netcidr(self.config_values.get('BLUE_IPS', '')).split(',') if x]
        self.config_values['ORANGE_SUBNETS'] = [x for x in self.ipcidr2netcidr(self.config_values.get('ORANGE_IPS', '')).split(',') if x]
        self.config_values['DEBUG_OPTIONS'] = get_debug_options()

        self.config_values['CONNECTIONS'] = get_connections()

    @action(name="start",
            on="startup",
            depends=["system_accessible=start"],
            exit_status="start",
            priority=81,
            options={"debug": (bool, "Be more verbose.")}
            )
    def start(self, options):
        Job.start(self, options)
        options['force'] = True
        return self.restart(options)

    @action(name="stop",
            options={"debug": (bool, "Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        remove_glob(SESSIONS_XAUTH)
        remove_glob(SESSIONS_L2TP)
        if options.get("onboot") or (self.status == 'stop' and self.sub == 'ok'):
            return EXIT_STATUS_STOP
        self.info("Stopping ipsec...")
        monit("stop ipsec", logger=self.logger)
        send_cmd_to_engine("restart setxtaccess")
        return EXIT_STATUS_STOP

    @action(name="restart",
            depends=["system_accessible=start"],
            exit_status="start",
            options={"debug": (bool, "Be more verbose."),
                     "force": (bool, "Forces restart.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        self.configure_local_certs()

        if not self.config_values:
            self.load_config()

        changed = self.save_config()
        if not self.shouldstart():
            self.debug("ipsec should not start. Don't start ipsec")
            return self.stop(options)
        if options.get('force', False):
            set_all_true(changed)
        reload_service("ipsec",
                       logger=self.logger,
                       changed=changed,
                       can_reload=False)
        if changed["xtaccess"] and not options.get('onboot', False):
            send_cmd_to_engine("restart setxtaccess")
        return EXIT_STATUS_START

    @action(name="updatewizard",
            on="updatewizard",
            priority=40,
            exit_status=DONT_CHANGE_STATUS,
            options={"debug": (bool, "Be more verbose.")}
            )
    def updatewizard(self, options):
        self.info("Updatewizard ipsec")
        settings = DataSource("ha").settings
        if to_bool(settings.get('HA_ENABLED', 'off')):
            options['force'] = True
            self.restart(options)

    @function(name="reload")
    def reload(self, options):
        """ Write the IPSec configuration and reload the whole configuration on the running daemons """
        if not self.config_values:
            self.load_config()
        changed = self.save_config()
        if changed["xtaccess"]:
            send_cmd_to_engine("restart setxtaccess")
        run("/usr/sbin/ipsec reload", suppress_output=True, logger=self.logger)
        # flushes and rereads all secrets, certificate, CRLs
        run("/usr/sbin/ipsec rereadall", suppress_output=True, logger=self.logger)
        return "OK"

    @function(name="connections")
    def connections(self, options):
        """ Return the list of the open connections """
        result = []
        output = subprocess.Popen(["/usr/sbin/ipsec", "status"], stdout=subprocess.PIPE).communicate()[0]
        lines = [x.strip() for x in output.split('\n')[1:] if x.strip()]  # ignore the first headers line
        for line in lines:
            match = CONNECTION_RE.match(line)
            if match:
                name = match.group(1)
                status = match.group(3) # CONNECTING, ESTABLISHED, ... ?
                since = match.group(4)
                result.append("%s %s %s" % (name, status, since))
        return result

    @function(name="reset_connection",
              options={"name":(str,"Connection name")})
    def reset_connection(self, options):
        """ Closes and reopen a IPsec connection """
        if not options.get('name'):
            raise Exception("Missing parameter name")
        self.debug(subprocess.Popen(["/usr/sbin/ipsec", "down", options.get("name")], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()[0])
        self.debug(subprocess.Popen(["/usr/sbin/ipsec", "stroke", "up-nb", options.get("name")], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).communicate()[0])
        return "OK"

    @function(name="status",
              options={"name":(str,"Connection name")})
    def status(self, options):
        """ Return the IPsec status """
        if options.get('name'):
            output = subprocess.Popen(["/usr/sbin/ipsec", "status", options.get('name')], stdout=subprocess.PIPE).communicate()[0]
        else:
            output = subprocess.Popen(["/usr/sbin/ipsec", "status",], stdout=subprocess.PIPE).communicate()[0]
        return output.split("\n")

    @action(name="reload_crls",
            on="crl_changed",
            exit_status=DONT_CHANGE_STATUS,
            options={"debug": (bool, "Be more verbose.")})
    def reload_crls(self, options):
        run("/usr/sbin/ipsec rereadcrls", suppress_output=True, logger=self.logger)

    def configure_local_certs(self):
        if DataSource('vpn').settings.get('ENABLED', 'off') == 'on':
            send_cmd_to_engine("call authentication.configure_local_certs --service vpn")
