#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

"""
.. mod:: GetBlackholeDNSJob - Contains the GetBlackholeDNSJob job.

.. synopsis:: Contains the GetBlackholeDNSJob job.

.. automodule:: dansguardianlistsupdate

Contains the GetBlackholeDNSJob.

.. moduleauthor:: Alber Maximilian
"""
__all__ = [
    'GetBlackholeDNSJob'
]

import os
import csv
import gzip
import urlparse
from endian.data import DataSource
from endian.job.commons import Job, action, is_valid_domain, write_config, monit
from endian.job.generic.downloadjob import DownLoadJob

DNSMASQ_CONFIG = "/var/efw/dnsmasq/settings"
ETC = "/etc/dnsmasq/"
CONF = "blackholedns.conf"

BLACKLIST_SETTING_URL = "DNSMASQ_BLACKHOLE_URL"
BLACKLIST_SETTING_ETAG = "DNSMASQ_BLACKHOLE_ETAG"
BLACKLIST_LOCATION = "/var/signatures/dnsmasq/"
BLACKLIST_FILENAME = 'phishtank.csv'


class GetBlackholeDNSJob(DownLoadJob, Job):
    """
    .. autoclass:: GetBlackholeDNSJob

    Downloads from the configured url the
    dnsmasq spywaredomains zones.
    """

    settings_file_name = DNSMASQ_CONFIG
    urls = [{"url_key": BLACKLIST_SETTING_URL,
             "etag_key": BLACKLIST_SETTING_ETAG,
             "location": BLACKLIST_LOCATION,
             "uncompress": False}]

    def get_domain_list_from_settings(self, field):
        domain_string = DataSource('dnsmasq').get('settings', {})[field]
        domain_list = domain_string.split('&')
        return domain_list

    def get_domain_list(self, filename, parse=None):
        if not os.path.exists(filename):
            return set()
        lines = []
        try:
            fd = open(filename, 'r')
            for line in fd:
                line = line.strip()
                if len(line) <= 0:
                    continue
                if line[0] == '#':
                    continue
                if parse is not None:
                    line = parse(line)
                line = line.strip()
                if line == '':
                    continue
                if not is_valid_domain(line):
                    continue
                lines.append(line)
            fd.close()
        except Exception:
            self.error("Could not read spywaredomains zonefile %s!" % filename)
            lines = []
        self.debug("Read %s lines" % len(lines))
        return set(lines)

    def save_config(self):
        def parse(s):
            try:
                csv_entry = csv.reader([s])
                parsed = urlparse.urlparse(csv_entry.next()[1])
                # Only consider sites that contain phishing at the root.
                if parsed[2] not in ('/', ''):
                    return ''
                url = parsed[1].lower()
                # Also excludes URLs with credentials.
                if '@' in url:
                    return ''
                # Prevent parsing of wrong lines.
                if url in ('www.phishtank.com', 'phishtank.com'):
                    return ''
                return url
            except Exception, e:
                self.logger.debug('Unable to parse CSV entry - %s - %s', s, e)
                return ""

        dest_csv = os.path.join(BLACKLIST_LOCATION, BLACKLIST_FILENAME)

        self.debug("Create config")
        whitelist = self.get_domain_list_from_settings("DNSMASQ_WHITELIST_DOMAINS")
        customlist = self.get_domain_list_from_settings("DNSMASQ_BLACKLIST_DOMAINS")
        blacklist = self.get_domain_list(dest_csv, parse)

        blacklist.difference_update(whitelist)
        blacklist.update(customlist)

        configfile = os.path.join(ETC, CONF)
        target = os.path.join(BLACKLIST_LOCATION, CONF)

        self.config_values['spywaredomains'] = blacklist

        return write_config(configfile + ".tmpl", target, self.config_values)

    def post(self, tmp_dir, urls):
        """
        .. autofunction:: post

        Post hook, is triggered after the
        download and the possible uncompressing.

        In the default implementation the content of urls with a
        location key in the urls parameter will be
        moved to this location.

        :param tmp_dir: The temporary directory for
          the downloads.
        :type tmp_dir: String
        :param urls: The urls to downloaded.
        :type urls: list of dicts
        """
        if not self.options.get('update', False):  # backward compatibility
            DownLoadJob.post(self, tmp_dir, urls)

        for url in urls:
            downloaded_filename = os.path.basename(url.get('tmp_file', ''))
            downloaded_filepath = os.path.join(BLACKLIST_LOCATION, downloaded_filename)
            if not os.path.isfile(downloaded_filepath):
                self.logger.error('Unable to find downloaded file: %s',
                                  downloaded_filepath)
                return
            dest_csv = os.path.join(BLACKLIST_LOCATION, BLACKLIST_FILENAME)
            gunzip_success = True
            try:
                fd_in = gzip.open(downloaded_filepath, 'rb')
                fd_out = open(dest_csv, 'w')
                for line in fd_in:
                    fd_out.write(line)
                fd_in.close()
                fd_out.close()
            except Exception, e:
                gunzip_success = False
                self.logger.error('Unable to gunzip file %s to %s: %s',
                                  downloaded_filepath, dest_csv, e)
            try:
                os.remove(downloaded_filepath)
            except Exception, e:
                self.logger.error('Unable to remove temporary file: %s: %s',
                                  downloaded_filepath, e)
            if not gunzip_success:
                return

        changed = self.save_config()
        if changed:
            self.debug("Config changed, restart dnsmasq")
            monit("restart dnsmasq", logger=self.logger)

        elif self.options.get('force'):
            self.debug("Force restart dnsmasq")
            monit("restart dnsmasq", logger=self.logger)

        else:
            monit("start dnsmasq", logger=self.logger)

    @action(name="start",
            depends=["emi=start"],
            exit_status="stop",
            options={"debug": (bool, "Be more verbose."),
                     "force": (bool, "Forces restart."),
                     "update": (bool, "Do not download blacklists.")}
            )
    def start(self, options):
        """
        .. autofunction:: start

        Starts the download jobs.

        :param options: A dict with options.
        :type options: dict
        """

        if options.get('update', False):
            if not (hasattr(self, 'config_values') and self.config_values):
                self.load_config()
            changed = self.save_config()
            if changed:
                monit("restart dnsmasq", logger=self.logger)
            return
        DownLoadJob.start(self, options)

    @action(name="restart",
            depends=["emi=start"],
            exit_status="stop",
            options={"debug": (bool, "Be more verbose."),
                     "force": (bool, "Forces restart."),
                     "update": (bool, "Do not download blacklists.")}
            )
    def restart(self, options):
        """
        .. autofunction:: restart

        Starts the job.
        :param options: A dict with options.
        :type options: dict
        """
        DownLoadJob.restart(self, options)
