#!/usr/bin/python
#
# +--------------------------------------------------------------------------+
# | Endian Authentication Layer                                              |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | eal is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | eal is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with eal.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import os
from endian.data import DataSource
from endian.job.commons import Job, action, function, reload_service, monit, write_config, \
        file_exists, remove_path, EXIT_STATUS_START, EXIT_STATUS_STOP, DONT_CHANGE_STATUS
try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper

LOGROTATE = "/etc/logrotate.d/authentication"
LOCAL_USER_DB = "/var/efw/access/user"
OPENVPN_PASSWDFILE = "/var/efw/openvpn/passwd"

class AuthenticationJob(Job):

    config_values = None

    @action(name="restart",
            depends=["monit=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Force restart.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        changed = self.save_config()
        self.check_auth_provider()

        if not self.shouldstart():
            return self.stop(options)

        self.info("Starting Endian Authentication Layer...")
        reload_service("authentication",
                       logger=self.logger,
                       changed=changed,
                       can_reload=False,
                       blocking=True)
        return EXIT_STATUS_START

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        if options.get("onboot"):
            return EXIT_STATUS_STOP
        self.info("Stopping Endian Authentication Layer...")
        monit("stop authentication", logger=self.logger)
        return EXIT_STATUS_STOP

    @action(name="start",
            on="startup",
            depends=["monit=start"],
            priority=5,
            options={"debug":(bool,"Be more verbose.")}
            )
    def start(self, options):
        Job.start(self, options)
        self.migrate()
        result = self.restart(options)
        return result

    def load_config(self):
        self.config_values = {}
        self.config_values['DS'] = DataSource()

    def save_config(self):
        if self.config_values == None:
            self.load_config()
        write_config(LOGROTATE + ".tmpl",
                     LOGROTATE,
                     self.config_values)
        return True

    def shouldstart(self):
        if self.config_values == None:
            self.load_config()
        return True

    @action(name="updatewizard",
            on="updatewizard",
            priority=5,
            exit_status=DONT_CHANGE_STATUS,
            options={"debug":(bool,"Be more verbose.")}
            )
    def updatewizard(self, options):
        self.info("Updatewizard authentication layer")
        options['force'] = True
        return self.restart(options)

    @function(name="update_ca")
    def update_ca(self, options={}):
        """
        Regenerate the CRL file and update the index
        """
        from endian.authentication.auth_client import update_index, generate_crl
        try:
            generate_crl()
            update_index()
        except:
            pass
        return "OK"

    @staticmethod
    def string_to_list(l):
        if not l:
            return []
        elif isinstance(l, list):
            return l
        else:
            return l.split(",")

    @staticmethod
    def _migration_read_openvpn_users():
        """
        Read the old OpenVPN passwd entries from a file and return a dictionary
        """
        entries = {}
        pwdfile = open(OPENVPN_PASSWDFILE)
        for line in pwdfile.readlines():
            line = line.strip().split(":")
            if len(line) >= 2:
                user = {}
                try:
                    user['password'] = line[1]
                    user['enabled'] = line[2]
                    user['red'] = line[3]
                    user['orange'] = line[4]
                    user['blue'] = line[5]
                    user['remotenet'] = line[6]
                    user['dont_push_routes'] = line[7]
                    user['explicit_routes'] = line[8]
                    user['static_ip'] = line[9]
                    user['dns'] = line[10]
                    user['domain'] = line[11]
                    user['push_dns'] = line[12]
                    user['push_domain'] = line[13]
                except:
                    pass
                entries[line[0]] = user
        pwdfile.close()
        return entries

    def migrate(self):
        """ Migrate the OpenVPN users to the authentication layer """
        try:
            if not file_exists(OPENVPN_PASSWDFILE) or os.path.getsize(OPENVPN_PASSWDFILE) == 0:
                return

            self.info("Migrating OpenVPN users to Authentication Layer")
            import yaml

            # Get the first id for the imported users
            try:
                i = max(yaml.load(file(LOCAL_USER_DB), Loader=Loader).keys()) + 1
            except:
                i = 1

            # Convert the openvpn users
            users = {}
            for name, entry in self._migration_read_openvpn_users().iteritems():
                user = { 'ID': i,
                         'name': name,
                         'enabled': entry.get('enabled') == 'enabled',
                         'password': entry.get('password') and entry.get('password') or '',
                         'password_type': entry.get('password') and 'crypt' or '',
                         'vpn_red': entry.get('red') == 'setred',
                         'vpn_orange': entry.get('orange') == 'setorange',
                         'vpn_blue': entry.get('blue') == 'setblue',
                         'vpn_remote_nets': self.string_to_list(entry.get('remotenet')),
                         'vpn_explicit_routes': self.string_to_list(entry.get('explicit_routes')),
                         'vpn_static_ips': self.string_to_list(entry.get('static_ip')),
                         'vpn_custom_dns': self.string_to_list(entry.get('dns')),
                         'vpn_domain': self.string_to_list(entry.get('domain')),
                         'vpn_dont_push_routes': entry.get('dont_push_routes') == 'on',
                         'vpn_push_custom_dns': entry.get('push_dns') == 'on',
                         'vpn_push_domain': entry.get('push_domain') == 'on',
                          }
                users[i] = user
                i = i + 1

            # Copy the users on the new file
            f = open(LOCAL_USER_DB, 'a+')
            f.write(yaml.dump(users, Dumper=Dumper))
            f.write('\n')
            f.close()

            # Remove the migrated file
            remove_path(OPENVPN_PASSWDFILE)
            self.info("OpenVPN users migration completed")

        except Exception, ex:
            self.error("Error migrating OpenVPN users: %s", str(ex))
            return

    def create_ca(self):
        from endian.authentication import auth_client
        result = auth_client.create_certificate_authority(
                cert_name="efw CA",
                cert_organization="efw",
                cert_country="IT",
                cert_filename="ca")
        self.info("CA certificate creation: %s" % str(result))
        return os.path.basename(result['cert_filename'])

    def create_host_cert(self):
        from endian.authentication import auth_client
        result = auth_client.create_certificate(
                cert_name = self.get_active_uplink_ip() or "127.0.0.1",
                cert_organization="efw",
                cert_country="IT",
                cert_type="server")
        self.info("Host certificate creation: %s" % str(result))
        return os.path.basename(result['cert_filename'])

    def get_active_uplink_ip(self):
        """ Return the IP of the active RED interface, or None """
        import endian.uplinksdaemon.status
        for uplink in endian.uplinksdaemon.status.getUplinksData().get('uplinks', []):
            if uplink.get('isLinkActive'):
                ip = uplink.get('data', {}).get('ip')
                if ip:
                    return ip
        return None

    def get_host_certificate(self, cert_filename):
        from endian.authentication.handlers.ca import CA_CERTS_DIR
        candidates = [cert_filename]
        try:
            candidates.append(DataSource('vpn').settings.ROOTCERT_HOSTNAME)
        except:
            pass
        candidates.append(self.get_active_uplink_ip())
        candidates.append("127.0.0.1")
        candidates = ["%s%s" % (x, (not x.endswith('cert.pem')) and 'cert.pem' or '') for x in candidates if x]
        for candidate in candidates:
            if os.path.exists(os.path.join(CA_CERTS_DIR, candidate)):
                return candidate
        return None

    @function(name="configure_local_certs",
              options={"service":(str, "Service vpn (IPsec) or openvpn (OpenVPN)")})
    def configure_local_certs(self, options):
        """
        Create the CA and host certificate for IPsec or OpenVPN if they does not exist and update the settings file
        """
        from endian.authentication.handlers.ca import CA_CACERTS_DIR, CA_CERT
        if options.get('service') not in ['vpn', 'openvpn', 'reverseproxy']:
            raise Exception("Invalid or missing parameter service")

        settings = DataSource(options.get('service')).settings

        # Create the CA certificate if it does not exist
        ca_filename = settings.get('CA_FILENAME')
        if ca_filename:
            ca_fullname = os.path.join(CA_CACERTS_DIR, ca_filename)
        else:
            ca_fullname = CA_CERT # default CA
            ca_filename = os.path.basename(ca_fullname)
        if not os.path.exists(ca_fullname):
            settings['CA_FILENAME'] = self.create_ca()
        else:
            settings['CA_FILENAME'] = ca_filename

        # Create the host certificate if it does not exist
        cert_filename = self.get_host_certificate(settings.get('CERT_FILENAME'))
        if not cert_filename:
            settings['CERT_FILENAME'] = self.create_host_cert()
        else:
            settings['CERT_FILENAME'] = cert_filename
        settings.write()
        return "OK"

    def check_auth_provider(self):
        from endian.emi.storage.yamlstorage import YamlStorage
        changed = False
        provider_storage = YamlStorage(namespace="access.provider")
        # Create the apache provider if it does not exist
        if not provider_storage.select(name='apache'):
            provider_storage.store({ 'name': 'apache',
                                     'provider_type': 'apache',
                                     'enabled': True })
            changed = True
        return changed

