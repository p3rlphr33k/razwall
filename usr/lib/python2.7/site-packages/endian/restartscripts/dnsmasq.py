#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import glob
from endian.data import DataSource
from endian.job.commons import Job, action, get_config, write_config, get_bypasses,\
        monit, send_cmd_to_engine, run, reload_service, touch, chown, chgrp, \
        EXIT_STATUS_STOP, EXIT_STATUS_START, DONT_CHANGE_STATUS
from endian.core.zones import getZones

VAR="/var/efw/dnsmasq/"
ETC="/etc/dnsmasq/"
CONF="dnsmasq.conf"
CONFIG=VAR+"local_nameserver"

FIREWALL="/etc/firewall/inputfw/dnsmasq.conf"
ROUTING="/etc/firewall/routing/dnsmasq.conf"
PROXIES="/etc/firewall/proxies/dnsmasq.conf"
HOSTS="/etc/hosts"
DEFAULTHOSTS="/etc/dnsmasq/hosts.d/default.conf"
RESOLV="/etc/dnsmasq/resolv.conf"
RESOLVER_HOOK="/etc/dnsmasq/custom-resolvers*.conf"

#TRANSPARENT_SOURCE_BYPASS = "/var/efw/dnsmasq/source_bypass"
#TRANSPARENT_DESTINATION_BYPASS  = "/var/efw/dnsmasq/destination_bypass"

NETWORK_SETTINGS = '/var/efw/ethernet/settings'


class RuleEntry(object):

    def __init__(self):
        self._meta = ['enabled', 'domain', 'ip', 'remark']
        self.enabled = 'on'
        self.domain = ''
        self.ip = ''
        self.remark = ''


class DNSMasqJob(Job):

    config_values = None

    def save_config(self):
        if self.config_values == None:
            self.load_config()
        changed = {}
        changed['firewall'] = write_config(FIREWALL+".tmpl", FIREWALL, self.config_values)
        changed['routing'] = write_config(ROUTING+".tmpl", ROUTING, self.config_values)
        changed['redirect'] = write_config(PROXIES+".tmpl", PROXIES, self.config_values)
        write_config(DEFAULTHOSTS+".tmpl", DEFAULTHOSTS, self.config_values)
        write_config(HOSTS+".tmpl", HOSTS, self.config_values)
        changed['dnsmasq'] = write_config(os.path.join(ETC, CONF+".tmpl"), os.path.join(ETC, CONF), self.config_values)
        changed['dnsmasq'] |= write_config(RESOLV+".tmpl", RESOLV, self.config_values)
        return changed

    def load_config(self):
        self.config_values = {}
        self.config_values.update(DataSource('ethernet').get('settings', {}))
        self.config_values.update(DataSource('dnsmasq').get('settings', {}))
        # Fixing vars which are not supposed to be overwritten by settings,
        # as they cannot be modified with the GUI
        defaults = get_config(VAR+"/default/settings")
        self.config_values.update({'DNSMASQ_BLACKHOLE_URL': defaults['DNSMASQ_BLACKHOLE_URL'],
                              'DNSMASQ_BLACKHOLE_REDIRECT': defaults['DNSMASQ_BLACKHOLE_REDIRECT']})
        self.config_values['UPLINKS'] = self.get_uplinks()
        extradns = self.config_values.get('EXTRA_EXTERNAL_DNS', '').split(',')
        self.config_values['ZONES'] = [x.upper() for x in getZones()]
        self.config_values['EXTRADNS'] = filter(lambda x: x != '', extradns)
        self.config_values['EXTRADNS'].extend(self.get_hooked_resolvers())
        self.config_values['TRANSPARENT_ZONES'] = self.get_enabled_zones()

        source_list = self.config_values["DNSMASQ_TRANSPARENT_SOURCE_BYPASS"].split('&')
        destination_list = self.config_values["DNSMASQ_TRANSPARENT_DESTINATION_BYPASS"].split('&')

        self.config_values['BYPASSRULES'] = get_bypasses(source_list, destination_list)

        if self.config_values.get('LOG_FIREWALL', 'off') == '1':
            self.config_values['LOG_FIREWALL'] = 'on'
        self.debug(self.config_values)
        self.config_values['DS'] = DataSource()

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        if options.get("onboot"):
            return EXIT_STATUS_STOP
        self.debug("Stopping dnsmasq...")
        monit("stop dnsmasq", logger=self.logger)
        return EXIT_STATUS_STOP

    @action(name="start",
            on="startup",
            depends=["monit=start", "base=start"],
            exit_status="start",
            priority=10,
            options={"debug":(bool,"Be more verbose.")}
            )
    def start(self, options):
        Job.start(self, options)
        options['force'] = True
        return self.restart(options)

    @action(name="resolvonly",
            depends=["monit=start"],
            exit_status=None,
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces resolve.")}
            )
    def resolvonly(self, options):
        if self.config_values == None:
            self.load_config()
        self.debug("Recreate resolv.conf and policy routing rules")
        write_config(ROUTING+".tmpl", ROUTING, self.config_values)
        send_cmd_to_engine("restart setpolicyrouting")

        changed = write_config(RESOLV+".tmpl", RESOLV, self.config_values)
        if changed or options.get('force'):
            self.debug("resolv.conf has been changed. Reload dnsmasq")
            run("/etc/init.d/dnsmasq reload")

    @action(name="restart",
            depends=["monit=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "resolvonly":(bool,"Rebuild only resolv.conf.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        self.prepare()
        if self.config_values == None:
            self.load_config()
        if options.get('resolvonly'):
            self.resolvonly(options)
            return EXIT_STATUS_START

        self.prepare()
        changed = self.save_config()
        if options.get('force'):
            changed['dnsmasq'] = True
        reload_service("dnsmasq",
                       logger=self.logger,
                       can_reload=False,
                       changed=changed['dnsmasq'])

        if changed['routing'] and not options.get('onboot', False):
            send_cmd_to_engine("restart setpolicyrouting")

        if changed['firewall'] and not options.get('onboot', False):
            send_cmd_to_engine("restart setxtaccess")

        if changed['redirect'] and not options.get('onboot', False):
            send_cmd_to_engine("restart setredirect")

        return EXIT_STATUS_START


    @action(name="updatewizard",
            on="updatewizard",
            priority=40,
            exit_status=DONT_CHANGE_STATUS,
            options={"debug":(bool,"Be more verbose.")}
            )
    def updatewizard(self, options):
        self.info("Updatewizard dnsmasq")
        return self.restart(options)

    def get_uplinks(self):
        from uplinksdaemon.uplinks import UplinksPool
        ret = []
        u = UplinksPool()
        for ul in u.getActiveUplinks():
            item = {}
            try:
                item['uplinkname'] = ul.uplinkname
                item['nameserver'] = ul.getNameserver().split()
            except:
                continue
            ret.append(item)
        self.debug("Get nameservers for %s uplinks" % len(ret))
        return ret

    def get_hooked_resolvers(self):
        ret = []
        for f in glob.glob(RESOLVER_HOOK):
            self.debug("Read resolver hook %s"%f)
            try:
                fd = open(f, "r")
                ret.extend(map(lambda x: x.strip(), fd.readlines()))
                fd.close()
            except Exception, e:
                self.error("Error reading resolver hook '%s', s()"%(f, e))
                pass
        return ret

    def get_enabled_zones(self):
        if self.config_values == None:
            self.load_config()
        ret = []
        if self.config_values['DNSMASQ_TRANSPARENT_GREEN'] == 'on':
            ret.append("GREEN")
        if self.config_values['DNSMASQ_TRANSPARENT_ORANGE'] == 'on':
            ret.append("ORANGE")
        if self.config_values['DNSMASQ_TRANSPARENT_BLUE'] == 'on':
            ret.append("BLUE")
        return ret

    def prepare(self):
        self.debug("Prepare dnsmasq configuration files")
        touch("/var/efw/dnsmasq/hosts")
        touch("/var/efw/dnsmasq/local_nameserver")
        chown("/var/efw/dnsmasq/hosts", "nobody")
        chgrp("/var/efw/dnsmasq/hosts", "nogroup")
        chown("/var/efw/dnsmasq/local_nameserver", "nobody")
        chgrp("/var/efw/dnsmasq/local_nameserver", "nogroup")
        touch('/var/signatures/dnsmasq/blackholedns.conf')
        if os.path.exists('/etc/openvpn'):
            touch('/etc/openvpn/dnsmasq.hosts.conf')

