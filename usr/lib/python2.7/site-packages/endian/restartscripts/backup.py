#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2010 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

from endian.core import runner
from endian.job.commons import *

S_SETTINGS="/var/efw/backup/settings"

SCRIPT="/usr/lib/cron/autobackup.sh"
LOGROTATE = "/etc/logrotate.d/backupusb"

class BackupJob(Job):

    config_values = None

    def load_config(self):
        self.config_values = {}
        self.config_values['DS'] = DataSource()

    @action(name="backup",
            exit_status=DONT_CHANGE_STATUS,
            use_notifications=True,
            options={"debug": (bool, "Be more verbose."),
                     "settings": (bool, ""),
                     "dbdumps": (bool, ""),
                     "logs": (bool, ""),
                     "logarchives": (bool, ""),
                     "hwdata": (bool, ""),
                     "virtualmachines": (bool, ""),
                     "message": (str, ""),
                     "gpgkey": (str, ""),
                     "usb": (bool, ""),
                    })
    def backup(self, options):
        args = []
        if options.get("settings", False):
            args.append("--settings")
        if options.get("dbdumps", False):
            args.append("--dbdumps")
        if options.get("logs", False):
            args.append("--logs")
        if options.get("logarchives", False):
            args.append("--logarchives")
        if options.get("hwdata", False):
            args.append("--hwdata")
        message = options.get("message", "")
        if message:
            args.append(" --message=\"%s\"" % message.replace('"', ' '))
        gpgkey = options.get("gpgkey", "")
        if gpgkey:
            args.append(" --gpgkey=%s" % gpgkey)
        if options.get('usb', False):
            if options.get("virtualmachines", False):
                args.append("--virtualmachines")
            cmd = '/usr/local/bin/efw-backupusb --runbackup %s' % " ".join(args)
        else:
            cmd = '/usr/local/bin/backup-create.sh %s' %  " ".join(args)

        # Create the backup
        self.debug(cmd)
        (status, output) = getstatusoutput(cmd)

        # Force HA syncronization
        send_cmd_to_engine("call base.noop")

        # Check exit status
        if status != 0:
            msg = "%s: %s" % (_('Backup not created'), output)
            self.error(msg)
            raise Exception(msg)
        else:
            self.info("Backup created %s" % output)

    @function(name="do_backup",
            options={"debug": (bool, "Be more verbose."),
                     "settings": (bool, ""),
                     "dbdumps": (bool, ""),
                     "logs": (bool, ""),
                     "logarchives": (bool, ""),
                     "hwdata": (bool, ""),
                     "virtualmachines": (bool, ""),
                     "message": (str, ""),
                     "gpgkey": (str, ""),
                     "usb": (bool, ""),
                    })
    def do_backup(self, options):
        settings = options.get("settings", False)
        dbdumps = options.get("dbdumps", False)
        logs = options.get("logs", False)
        logarchives = options.get("logarchives", False)
        hwdata = options.get("hwdata", False)
        virtualmachines = options.get("virtualmachines", False)
        if not settings and not dbdumps and not logs and not logarchives and not hwdata and not virtualmachines:
            raise Exception("Include at least something to backup!")
        send_cmd_to_engine("request sync backup.start")
        send_cmd_to_engine("request backup.backup", options=options)
        return "OK"

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")})
    def stop(self, options):
        Job.stop(self, options)
        if options.get("onboot"):
            return EXIT_STATUS_STOP
        remove_glob("/etc/cron.*/autobackup")
        return EXIT_STATUS_STOP

    @action(name="start",
            on="startup",
            depends=["emi"],
            exit_status="start",
            priority=80,
            options={"debug":(bool,"Be more verbose.")}
            )
    def start(self, options):
        Job.start(self, options)
        options['force'] = True
        return self.restart(options)

    @action(name="restart",
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        self.info("Saving backup configuration")
        self.stop(options)
        self.save_config()
        return EXIT_STATUS_START

    def save_config(self):
        if self.config_values == None:
            self.load_config()

        s_conf = get_config(S_SETTINGS)

        write_config(LOGROTATE + ".tmpl",
                     LOGROTATE,
                     self.config_values)

        if s_conf['BACKUP_ENABLED'] != 'on':
            return

        if s_conf['BACKUP_SCHEDULE'] in ['hourly', 'weekly', 'daily', 'monthly']:
            remove_glob("/etc/cron.*/autobackup")
            target = os.path.join("/etc/cron." + s_conf['BACKUP_SCHEDULE'], "autobackup")
            os.symlink(SCRIPT, target)
