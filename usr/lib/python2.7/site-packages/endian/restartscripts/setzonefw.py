#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import copy
import os
import shutil
import filecmp
import tempfile
from endian.job.commons import get_config
from endian.firewall.iptables import iptables
from endian.job.job import Job, action
from endian.data.container.csvconfig import CsvConfigFile
from endian.datatypes.config_dict import ConfigDict
from Cheetah.Template import Template

CONFIGBASE = '/var/efw/'
CHAIN = 'ZONEFW'

SETTINGS = '/var/efw/zonefw/settings'
CONFIG = '/var/efw/zonefw/config'
ETHERNET_SETTINGS = '/var/efw/ethernet/settings'
IPTABLES_STATE = '/etc/firewall/zonefw/iptableszonefw'
EBTABLES_STATE = '/etc/firewall/zonefw/ebtableszonefw'
TMPFILE = "/var/tmp/%szonefw"
REGISTRY = '/var/lib/ticketregistry/physdevout'
NEEDRELOAD = '/var/efw/zonefw/needreload'
LOG_SETTINGS = '/var/efw/logging/settings'
HOTSPOT_SETTINGS = '/var/efw/hotspot/settings'

TMPL = '/etc/firewall/zonefw/rules.tmpl'

definitions = {
    'PHYSDEV_BITS': 10,
    'PHYSDEV_ENABLE_BIT': 0x40000,
    'PHYSDEV_MARK': 0x1ff80000
}

BASE_DICT = {
    'enabled': 'on',
    'proto': '',
    'src_ip': '',
    'dst_ip': '',
    'dst_port': '',
    'target': '',
    'mac': '',
    'remark': '',
    'log': '',
}


class SetZoneFw(Job):

    tmpl = None
    settings = {}

    _ticketRegistry = None
    _bridgeConfigCache = None

    def getBridgeConfig(self):
        lastbridge = ""
        cache = {}
        for line in os.popen("brctl show"):
            if line.startswith("bridge"):
                continue
            split = line.split()
            if line.startswith("br"):
                lastbridge = split[0]
                if len(split) > 3:
                    iface = split[3]
                else:
                    iface = ''
            else:
                iface = split[0]
            cache[iface] = lastbridge
        return cache

    def getBridgeByInterface(self, iface):
        if self._bridgeConfigCache is None:
            self._bridgeConfigCache = self.getBridgeConfig()
        return self._bridgeConfigCache[iface]

    def getNextMark(self, hash):
        from endian.firewall.ticket import TicketRegistry
        obj = self._ticketRegistry
        if self._ticketRegistry is None:
            obj = TicketRegistry(REGISTRY, startid=1)
            self.debug("Unregister all of realm %s", CHAIN)
            obj.unregisterAll(CHAIN)
            # mark 1 is reserved for static usage in rc.firewall script
            obj.register(1, 'VPNFWSTATIC')
            self._ticketRegistry = obj
        mark = obj.register(hash, realm=CHAIN)
        self.debug("Got mark %s for hash: '%s'.", mark, hash)
        return mark << definitions['PHYSDEV_BITS']

    def insert_rule(self, obj, tmpl, log=False):
        methods = {}
        methods['getBridgeByInterface'] = self.getBridgeByInterface
        methods['getNextMark'] = self.getNextMark

        obj.log = log
        self.satanize_rule(obj)
        cmd = str(tmpl(namespaces=[obj, methods, definitions]))
        self.debug("Create rule nr %d: %s", obj.i, cmd)
        return cmd.strip()

    def explode_rules(self, line, explodefields):
        if line.enabled != 'on':
            return
        rules = []
        rules.append(line)
        for field in explodefields:
            tmprules = []
            fieldval = getattr(line, field)
            if fieldval == '':
                continue
            for value in fieldval.split('&'):
                if value == '':
                    continue
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rulenum = len(rules)
        if rulenum > 1:
            self.debug("Exploded rules to %d", rulenum)
        return rules

    def substZones(self, value, rule=None):
        if value == 'ALL' or value == 'ANY' or value == '':
            return ''
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED', 'HOTSPOT']:
            return value
        self.debug("Substitute ZONE '%s'", value)
        if value != 'RED':
            dev = self.settings["%s_DEV" % value]
            self.debug("Substituted ZONE '%s' to: %s", value, dev)
            return dev
        return None

    def substIter(self, values, cb, rule=None, delimiter='&'):
        if not values:
            return values
        if cb is None:
            return values
        ret = ''
        empty = True
        for i in values.split(delimiter):
            if i is None:
                continue
            value = None
            try:
                value = cb(i, rule)
            except:
                self.debug("Substitution failed", exc_info=True)
                continue
            if value is None:
                continue
            ret += delimiter + value
            empty = False
        if empty:
            self.debug("No suitable value found for substitution of '%s'", values)
            raise Exception("No suitable value found for substitution")
        if ret == '':
            return ''
        return ret[1:]

    def substitute_values(self, rule):
        try:
            rule.src_dev = self.substIter(rule.src_dev, self.substZones, rule)
            rule.dst_dev = self.substIter(rule.dst_dev, self.substZones, rule)

            # 2.2 migration hack, substitute '-' in port ranges with ':'
            rule.dst_port = rule.dst_port.replace('-', ':')
        except:
            return None
        return rule

    def satanize_rule(self, item):
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in = False
        item.physdev_out = False
        if item.src_dev.startswith('PHYSDEV'):
            item.physdev_in = True
            item.src_dev = item.src_dev.split(":")[1]
        if item.dst_dev.startswith('PHYSDEV'):
            item.physdev_out = True
            item.dst_dev = item.dst_dev.split(":")[1]
        item.logtarget = item.target
        if item.target == '':
            item.target = 'ACCEPT'
        return item

    def getRules(self):
        ret = []
        if self.settings['POLICY'] == 'ALLOW':
            # allow all
            tmp = copy.copy(BASE_DICT)

            tmp.update({'src_dev': 'GREEN', 'dst_dev': 'GREEN&BLUE&ORANGE'})
            add = ConfigDict(tmp)

            tmp.update({'src_dev': 'BLUE', 'dst_dev': 'BLUE'})
            add2 = ConfigDict(tmp)

            tmp.update({'src_dev': 'ORANGE', 'dst_dev': 'ORANGE'})
            add3 = ConfigDict(tmp)

            ret.append(add)
            ret.append(add2)
            ret.append(add3)
            return ret

        self.debug("Read from '%s'", CONFIG)
        try:
            rules = CsvConfigFile(
                '/usr/lib/efw/zonefw/config.config',
                CONFIG,
                tolerant=True,
            )
            ret.extend(rules)
        except Exception, e:
            self.error("Could not load config file '%s', because: %s!" % (CONFIG, e))
        return ret

    def generate_script(self):
        if not self.settings:
            self.load_config()

        iptables_script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE % 'iptables')
        ebtables_script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE % 'ebtables')

        i = 0
        out_rules = [
            "iptables -F %s" % CHAIN,
            "iptables -t mangle -F %s" % CHAIN,
            "ebtables -t nat -F %s" % CHAIN,
            "ebtables -F %s" % CHAIN,
        ]
        self.debug("Generate iptables script")
        for rule in self.getRules():
            i += 1
            rule.i = i
            if rule.enabled != 'on':
                continue
            log = (rule.log == 'on')
            if self.settings['LOG_ACCEPTS'] == 'on':
                if rule.target in ['ACCEPT', 'ALLOW']:
                    log = True
            if self.settings.get('DISABLE_FIREWALL_LOGS', 'off') == 'on':
                log = False
            # ICMP hack
            if rule.proto == 'icmp':
                rule.dst_port = '8&30'
            if self.substitute_values(rule) is None:
                continue
            for item in self.explode_rules(rule, ['proto', 'src_ip', 'dst_ip', 'dst_port', 'mac', 'src_dev', 'dst_dev']):
                try:
                    out_rules.append(self.insert_rule(item, self.tmpl, log))
                except Exception:
                    self.debug("Explosion failed", exc_info=True)
                    continue

        for r in out_rules:
            if r.startswith("iptables"):
                iptables_script.write(r + "\n")
            else:
                ebtables_script.write(r + "\n")
        iptables_script.flush()
        ebtables_script.flush()
        return iptables_script, ebtables_script

    def save_config(self):
        self.iptables_script, self.ebtables_script = self.generate_script()

        if not os.path.exists(IPTABLES_STATE):
            iptables_changed = True
        else:
            iptables_changed = not filecmp.cmp(self.iptables_script.name, IPTABLES_STATE, False)

        if not os.path.exists(EBTABLES_STATE):
            ebtables_changed = True
        else:
            ebtables_changed = not filecmp.cmp(self.ebtables_script.name, EBTABLES_STATE, False)

        if iptables_changed or ebtables_changed:
            self.debug("Scripts are changed!")
        else:
            self.debug("Scripts are not changed!")
        return iptables_changed, ebtables_changed

    def load_config(self):
        self.settings = get_config(SETTINGS)
        self.settings.update(get_config(ETHERNET_SETTINGS))
        self.settings.update(get_config(LOG_SETTINGS))
        self.settings.update(get_config(HOTSPOT_SETTINGS))
        self.tmpl = Template.compile(file=TMPL)

    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug": (bool, "Be more verbose."),
                     "force": (bool, "Forces restart."),
                     "trace": (bool, "Display iptables shell script trace.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        self.start(options)

    @action(name="start",
            depends=["firewall=start"],
            exit_status="start",
            on="startup_done",
            options={"debug": (bool, "Be more verbose."),
                     "force": (bool, "Forces start."),
                     "trace": (bool, "Display iptables shell script trace.")}
            )
    def start(self, options):
        # Job.start(self, options)
        self.load_config()

        self.info("Restart ZONE firewall, force: %s", options.get('force', False))
        iptables_changed, ebtables_changed = self.save_config()

        if iptables_changed or options.get('force', False):
            self.debug("Save script to state file '%s'", IPTABLES_STATE)
            shutil.copy(self.iptables_script.name, IPTABLES_STATE)

            self.debug("Call iptables script %s", self.iptables_script.name)
            iptables(script=self.iptables_script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.iptables_script.close()

        if ebtables_changed or options.get('force', False):
            self.debug("Save script to state file '%s'", EBTABLES_STATE)
            shutil.copy(self.ebtables_script.name, EBTABLES_STATE)

            self.debug("Call ebtables script %s", self.ebtables_script.name)
            iptables(script=self.ebtables_script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call ebtables script")
        self.ebtables_script.close()

        if os.path.exists(NEEDRELOAD):
            os.unlink(NEEDRELOAD)

    @action(name="stop",
            options={"debug": (bool, "Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)

    @action(name="firewall_restart",
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug": (bool, "Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart setzonefw")
        options['force'] = True
        self.start(options)
