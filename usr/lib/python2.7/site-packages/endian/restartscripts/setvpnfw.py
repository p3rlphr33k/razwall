#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2015 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

from endian.datatypes.config_dict import ConfigDict
from endian.fw.job import GenericFirewallJob
from endian.job.commons import Job

CHAIN = 'VPNFW'
NAME = 'vpnfw'

EXPLODABLE_FIELDS = [
    'proto',
    'src_ip',
    'dst_ip',
    'dst_port',
    'mac',
    'src_dev',
    'dst_dev',
]

SUBSTITUTIONS = [
    # Mapping
    {                     'substitutor': 'endian.fw.substitutors.openvpn.SubstOpenVPNAnyUser'},
    # Source dev
    { 'field': 'src_dev', 'substitutor': 'endian.fw.substitutors.interfaces.SubstUplinkDev'  },
    { 'field': 'src_dev', 'substitutor': 'endian.fw.substitutors.zones.SubstZonesDev'        },
    { 'field': 'src_dev', 'substitutor': 'endian.fw.substitutors.openvpn.SubstOpenVPNDevice' },
    { 'field': 'src_dev', 'substitutor': 'endian.fw.substitutors.l2tp.SubstL2tpDevice'       },
    # Destination dev
    { 'field': 'dst_dev', 'substitutor': 'endian.fw.substitutors.interfaces.SubstUplinkDev'  },
    { 'field': 'dst_dev', 'substitutor': 'endian.fw.substitutors.zones.SubstZonesDev'        },
    { 'field': 'dst_dev', 'substitutor': 'endian.fw.substitutors.openvpn.SubstOpenVPNDevice' },
    { 'field': 'dst_dev', 'substitutor': 'endian.fw.substitutors.l2tp.SubstL2tpDevice'       },
    # Source IP
    { 'field': 'src_ip',  'substitutor': 'endian.fw.substitutors.openvpn.SubstOpenVPNNets'   },
    # Destination IP
    { 'field': 'dst_ip',  'substitutor': 'endian.fw.substitutors.openvpn.SubstOpenVPNNets'   },
]

NEED_BRIDGE = ['68', '67']

class SetVPNFirewall(GenericFirewallJob, Job):

    firewall_name = NAME
    chain = CHAIN
    explodable_fields = EXPLODABLE_FIELDS
    substitutions = SUBSTITUTIONS

    def post_sanitize_rule(self, item):
        """ This method is executed after sanitize_rule """
        if item.dst_dev.startswith('PHYSDEV'):
            item.physdev_out=True
            item.dst_dev = item.dst_dev.split(":")[1]
        item.bridge = False
        for e in NEED_BRIDGE:
            if item.dst_port == e:
                item.bridge = True
        item.ipsecout = False
        if item.dst_dev == 'ipsec+':
            item.dst_dev = ''
            item.ipsecout = True
        return item

    def post_get_rules(self, rules):
        """
        This method is executed after loading the rules

        :param rules: a list of rules
        :type rules: list
        :return: a list of rules
        :rtype: list
        """
        if self.settings['POLICY'] == 'ALLOW':
            # Allow all
            allow_all = ConfigDict({
                    'enabled' : 'on',  'proto' : '',   'src_ip' : '',  'dst_ip' : '',
                    'dst_port' : '',   'target' : '',  'mac' : '',     'remark' : '',
                    'log' : '',        'src_dev' : '', 'dst_dev' : '',
            })
            rules.data = [ allow_all ]
        return rules

    def pre_generate_script(self, script):
        """ This method is executed before generating the script """
        script.write("iptables -F %s\n" % self.chain)
        if self.settings['POLICY'] == 'ALLOW':
            script.write("iptables -A %s -j VPN_AS\n" % self.chain) 
        script.write("ebtables -F %s\n" % self.chain)

    def post_generate_script(self, script):
        """ This method is executed after generating the script """
        if self.settings['POLICY'] != 'ALLOW':
            script.write("iptables -A %s -j VPN_AS\n" % self.chain) 

