#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2010 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import copy
import tempfile
import iplib
from endian.job.commons import *
from endian.data.container.csvconfig import CsvConfigFile

CONFIGBASE='/var/efw/'
CHAIN='PROXIES'

ETHERNET_SETTINGS='/var/efw/ethernet/settings'
STATE='/etc/firewall/proxies/iptablesproxies'
TMPFILE="/var/tmp/iptablesproxies"
OPENVPNDIR='/var/efw/openvpnclients/'
OPENVPN_SETTINGS='/var/efw/openvpn/settings'
LOG_SETTINGS='/var/efw/logging/settings'
CONFIG='/var/efw/redirect/config'

TMPL='/etc/firewall/proxies/rules.tmpl'


class SetRedirect(Job):

    settings = None
    tmpl = None
    script = None
    _openvpnDevicesCache = None
    _addressCache = None

    def doSplit(self, line):
        line.replace(",", "&")
        line.replace(":", "&")
        return line

    def insert_rule(self, obj, tmpl, log=False):
        methods = {}
        methods['split'] = self.doSplit
        obj.log = log
        self.satanize_rule(obj)
        cmd = str(tmpl(namespaces = [obj, methods]))
        self.debug("Create rule nr %d: %s", obj.i, cmd)
        return cmd.strip()

    def explode_rules(self, line, explodefields):
        if line.enabled != 'on':
            return
        rules = []
        rules.append(line)
        for field in explodefields:
            tmprules = []
            fieldval = getattr(line, field)
            if fieldval == '':
                continue
            for value in fieldval.split('&'):
                if value == '':
                    continue
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rulenum = len(rules)
        if rulenum > 1:
            self.debug("Exploded rules to %d", rulenum)
        return rules

    def subst_zone_no_stealth_uplinks(self, value):
        zone_cache = self.get_zone_cache()
        # If zone is not defined, return XX_DEV
        try:
            members = set(zone_cache[value].members)
        except KeyError:
            return [self.settings['%s_DEV' % value]]
        # Find stealth uplinks
        stealth_uplinks = set()
        for intf in self.all_red_interfaces():
            if intf.startswith("PHYSDEV:"):
                stealth_uplinks.add(intf[8:])
        # If no stealth uplink is member of this zone,
        # return XX_DEV
        members_no_stealth_uplinks = members - stealth_uplinks
        if members_no_stealth_uplinks == members:
            return [self.settings['%s_DEV' % value]]
        # Explode members via PHYSDEV:<device>,
        # avoiding stealth uplinks
        return ["PHYSDEV:%s" % x for x in sorted(members_no_stealth_uplinks)]

    def substZones(self, value, rule=None):
        if self.settings == None:
            self.load_config()
        if value == 'ALL' or value == 'ANY' or value == '':
            return ''
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED']:
            return value
        self.debug("Substitute ZONE '%s'", value)
        if value != 'RED':
            dev = self.settings["%s_DEV"%value]
            self.debug("Substituted ZONE '%s' to: %s", value, dev)
            return dev
        return None

    def substZonesPrimaryIP(self, value, rule=None):
        if self.settings == None:
            self.load_config()
        if value == 'ALL' or value == 'ANY' or value == '':
            return ''
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED']:
            return value
        self.debug("Substitute ZONE '%s'", value)
        if value != 'RED':
            ip = self.settings.get("%s_ADDRESS"%value, "")
            if ip == '':
                return None
            self.debug("Substituted ZONE '%s' to: '%s'", value, ip)
            return ip
        return None

    def substAddressByInterface(self, value, rule=None):
        if is_ipaddress(value):
            return value
        return self.getAddressByInterface(value)

    def getAddressTable(self):
        if self._addressCache != None:
            return self._addressCache
        cmd = "ip -o addr show"
        (status, data) = commands.getstatusoutput(cmd)
        if status != 0:
            return None
        self._addressCache = {'dev':{}, 'ip':{}}

        for line in data.split("\n"):
            tokens = line.split()
            if tokens[2] != 'inet':
                continue
            try:
                dev = tokens[1]
                if self._addressCache['dev'].get(dev, None) != None:
                    continue
                cidr = tokens[3]
                if cidr.find("/") == -1:
                    cidr = "%s/32"%tokens[3]
                ip = iplib.CIDR(cidr).get_ip().get()
                self._addressCache['dev'][dev] = ip
                self._addressCache['ip'][ip] = dev
            except:
                self.debug("Could not determine ip address of interface '%s'" % tokens[1], exc_info=True)
        return self._addressCache

    def getAddressByInterface(self, dev):
        t = self.getAddressTable()
        return t['dev'][dev]

    def substIter(self, values, cb, rule=None, delimiter='&'):
        if not values:
            return values
        if cb == None:
            return values
        ret = ''
        empty = True
        for i in values.split(delimiter):
            if i == None:
                continue
            value=None
            try:
                value = cb(i, rule)
            except:
                self.debug("Error in callback")
                continue
            if value == None:
                continue
            ret+=delimiter+value
            empty=False
        if empty:
            self.debug("No suitable value found for substitution of '%s'", values)
            raise Exception("No suitable value found for substitution")
        if ret == '':
            return ''
        return ret[1:]

    def allOVPNInterfaces(self):
        if self._openvpnDevicesCache != None:
            return self._openvpnDevicesCache
        self._openvpnDevicesCache = []
        for ov in glob.glob(OPENVPNDIR+'/*'):
            dev = self.getInterfaceByOpenvpnName(os.path.basename(ov))
            if dev == None:
                continue
            self._openvpnDevicesCache.append(dev)
        return self._openvpnDevicesCache

    def getInterfaceByOpenvpnName(self, name):
        filename = os.path.join(OPENVPNDIR, name, 'settings')
        if not os.path.exists(filename):
            return None
        conf = get_config(filename)
        if conf.get('DEVICE', '') == '':
            return None
        device = conf['DEVICE']
        if conf.get('ROUTETYPE', 'routed') == 'bridged':
            return "PHYSDEV:%s"%device
        return device

    def get_purple_devices(self, server_name=None):
        try:
            from endian.core.pdict import PersistentDict
            pd = PersistentDict('/var/cache/var.efw.vpn.servers')
            servers = DataSource("openvpn").server or []
            purple_devices = set()
            for conf in servers:
                if not conf.get('enabled'):
                    continue
                if server_name is not None and server_name != conf.get('name'):
                    continue
                id_ = conf.get('id')
                purple_dev = pd.get(id_, {}).get('purple_devices') or []
                if id_ and purple_dev:
                    purple_devices = purple_devices.union(purple_dev)
            return list(purple_devices)
        except Exception, e:
            self.logger.error('error getting the list of PURPLE devices: %s', e)
            return []

    def getVPNDevice(self, conn):
        if self.settings == None:
            self.load_config()
        if conn == 'ANY':
            ov = []
            ov.extend(self.allOVPNInterfaces())
            ov.append('ipsec+')
            ov.append('l2tp+')
            ov.extend(['PHYSDEV:%s' % p for p in self.get_purple_devices()])
            return ov
        if conn == 'SERVER':
            return ['PHYSDEV:%s' % p for p in self.get_purple_devices()]
        if conn and  conn.startswith('SERVER:'):
            return ['PHYSDEV:%s' % p for p in self.get_purple_devices(server_name=conn.split(':', 1)[1])]
        if conn == 'IPSEC':
            return ['ipsec+']
        if conn == 'L2TP':
            return ['l2tp+']
        ret = []
        tap = self.getInterfaceByOpenvpnName(conn)
        if tap != None:
            ret.append(tap)
        return ret

    def substVPNDev(self, dev, rule=None, item=None):
        if not dev.startswith('VPN:'):
            return dev

        self.debug("Substitute VPN '%s'", dev)
        openvpnconn = dev.split(':', 1)[1]
        if openvpnconn == '':
            self.debug("Key '%s' contains no value.", dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.getVPNDevice(openvpnconn)
        if len(devlist) <= 0:
            self.debug("Connection '%s' has no Devices.", openvpnconn)
            raise KeyError("Connection '%s' has no Devices."%openvpnconn)
        self.debug("Substituted VPN '%s' to: %s", dev, devlist)
        return "&".join(devlist)

    def substitute_values(self, rule):
        try:
            rule.src_dev = self.substIter(rule.src_dev, self.substZones, rule)
            rule.src_dev = self.substIter(rule.src_dev, self.substVPNDev, rule)
            rule.src_dev = self.substIter(rule.src_dev,
                                          self.substZoneMembers.process,
                                          rule)
            rule.target_ip = self.substIter(rule.target_ip, self.substZonesPrimaryIP, rule)
            rule.target_ip = self.substIter(rule.target_ip, self.substAddressByInterface, rule)
        except:
            self.debug("Could not substitute: %s", rule)
            return None
        return rule

    def satanize_rule(self, item):
        if item.src_ip == '':
            item.src_ip = '0/0'
        if item.dst_ip == '':
            item.dst_ip = '0/0'
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in=False
        item.physdev_out=False
        if item.src_dev.startswith('PHYSDEV'):
            item.physdev_in=True
            item.src_dev = item.src_dev.split(":")[1]
        item.logtarget = item.target
        if item.target == '':
            item.target = 'DNAT'
        return item

    def getRules(self):
        ret = []
        self.debug("Read from '%s'", CONFIG)
        try:
            rules=CsvConfigFile(
                '/usr/lib/efw/redirect/config.config',
                CONFIG,
                tolerant=True,
                )
            ret.extend(rules)
        except Exception, e:
            self.error("Could not load config file '%s', because: %s!" % (CONFIG, e))
        return ret

    def generate_script(self):
        if self.settings == None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE)
        
        i = 0
        self.debug("Generate iptables script")
        script.write("iptables -t nat -F %s\n" % CHAIN)
        for rule in self.getRules():
            i += 1
            rule.i = i
            if rule.enabled != 'on':
                continue
            log = (rule.log == 'on')
            if self.settings.get('LOG_ACCEPTS', 'off') == 'on':
                if rule.target == 'ACCEPT':
                    log = True
            if self.settings.get('DISABLE_FIREWALL_LOGS','off') == 'on':
                log = False
            # ICMP hack
            if rule.proto == 'icmp':
                rule.dst_port = '8&30'
            if self.substitute_values(rule) == None:
                continue
            for item in self.explode_rules(rule, ['proto', 'src_ip', 'dst_ip', 'dst_port', 'mac', 'src_dev']):
                try:
                    rule_str = self.insert_rule(item, self.tmpl, log)
                    script.write(rule_str)
                    script.write("\n")
                except Exception, e:
                    self.logger.warn("Explosion failed", exc_info=True)
                    continue
        script.flush()
        return script
    
    def save_config(self):
        self.script = self.generate_script()
    
        if not os.path.exists(STATE):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, STATE, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed
    
    def load_config(self):
        from endian.firewall.substitutors.zonemembers import SubstZoneMembers
        self.settings = {}
        self.settings.update(get_config(ETHERNET_SETTINGS))
        self.settings.update(get_config(OPENVPN_SETTINGS))
        self.settings.update(get_config(LOG_SETTINGS))
        self.tmpl = Template.compile(file=TMPL)
        self.substZoneMembers = SubstZoneMembers(self.logger, exclude_stealth=True)
    
    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False        
        options['force'] = options.get('force', False)
        self.start(options)
        
    @action(name="start",
            depends=["firewall=start"],
            exit_status="start",
            on="startup_done",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces start."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def start(self, options):
        Job.start(self, options)
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        self.load_config()

        self.info("Restart redirection rules, force: %s", options.get('force'))
        changed = self.save_config()
    
        if changed or options.get('force'):
            self.debug("Save script to state file '%s'", STATE)
            shutil.copy(self.script.name, STATE)
    
            self.debug("Call iptables script %s", self.script.name)
            iptables(script=self.script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        
    @action(name="firewall_restart", 
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart setredirect")
        options['force'] = True
        self.start(options)
