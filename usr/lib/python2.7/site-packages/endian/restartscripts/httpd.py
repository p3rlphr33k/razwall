#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import socket
import subprocess
from endian.data import DataSource
from endian.validators.boolean import to_bool
from endian.data.container.fileconfig import PlainFile
from endian.core.settingsfile import SettingsFile
from endian.job.commons import (
    Job,
    action,
    function,
    save_old_config,
    write_config,
    chown,
    chgrp,
    monit,
    set_all_true,
    reload_service,
    send_cmd_to_engine,
    EXIT_STATUS_STOP,
    EXIT_STATUS_START,
    EXIT_STATUS_OK
)
from endian.job.generic.apachejob import ApacheJob, DEFAULT_CERTIFICATE, DEFAULT_KEY

# httpd config
HTTPD_PORTS = "/etc/httpd/ports.conf"
HTTPD_PORTS_TMPL = "%s.tmpl" % HTTPD_PORTS
HTTPD_DEFAULT_SITE = "/etc/httpd/sites-available/000-default.conf"
HTTPD_DEFAULT_SITE_TMPL = "%s.tmpl" % HTTPD_DEFAULT_SITE
# httpd init file
INIT = "/etc/init.d/httpd"
# HTTPD user / group files
HTTPD_USERS = "/var/efw/auth/users"
HTTPD_GROUPS = "/etc/httpd/groups"
HTTPD_GROUPS_TMPL = "%s.tmpl" % HTTPD_GROUPS
GROUP_DIR = "/var/efw/auth/group"

LOGROTATE = "/etc/logrotate.d/httpd"
FIREWALL = "/etc/firewall/inputfw/httpd.conf"
SETTINGS = "/var/efw/httpd/settings"

DEFAULT_GROUPS = {
    'admin': ['admin', 'support'],
    'hotspot_admin': ['hotspot']
}

DEFAULT_KEY_SIZE = 2048
DEFAULT_CSR = '/etc/httpd/server.csr'
DEFAULT_CERT_DAYS = 999999


class HttpdJob(ApacheJob, Job):
    mods = {
        'access_compat.load': True, 'alias.load': True, 'auth_basic.load': True,
        'authn_core.load': True, 'authn_file.load': True, 'authz_core.load': True,
        'authz_groupfile.load': True, 'authz_host.load': True, 'authz_user.load': True,
        'cgid.conf': True, 'cgid.load': True, 'dir.conf': True, 'dir.load': True,
        'env.load': True, 'headers.load': True, 'log_config.conf': True,
        'log_config.load': True, 'mime.conf': True, 'mime.load': True,
        'mpm_worker.conf': True, 'mpm_worker.load': True, 'negotiation.conf': True,
        'negotiation.load': True, 'proxy.load': True, 'authnz_external.load': True,
        'proxy_html.load': True, 'proxy_html.conf': True, 'proxy_http.load': True,
        'remoteip.load': True, 'rewrite.conf': True, 'rewrite.load': True,
        'setenvif.conf': True, 'setenvif.load': True, 'socache_dbm.load': True,
        'ssl.conf': True, 'ssl.load': True, 'unixd.load': True, 'xml2enc.load': True,
        'xml2enc.conf': True}

    conf = {}

    sites = {'000-default.conf': True}

    def update_groups(self):
        self.debug("Writing group file %s" % HTTPD_GROUPS)
        groups = dict(DEFAULT_GROUPS)

        # Read the guiusers
        ds = DataSource()
        users = groups.get('admin') or []
        for user in ds.auth.guiuser:
            name = user.get('name')
            if name:
                users.append(name)
        groups['admin'] = users

        # Read the config from GROUP_DIR
        for group in os.listdir(GROUP_DIR):
            if not os.path.isfile("%s/%s" % (GROUP_DIR, group)) or group == 'empty':
                continue
            users = groups.get(group) or []
            try:
                f = open("%s/%s" % (GROUP_DIR, group), 'r')
                for line in f.readlines():
                    line = line.rstrip("\n")
                    if line == "":
                        continue
                    users.append(line)
            finally:
                f.close()
            groups[group] = users

        save_old_config(HTTPD_GROUPS)
        write_config(HTTPD_GROUPS_TMPL, HTTPD_GROUPS, {"GROUPS": groups}, skip_compare_old_config=True)

    def update_users(self):
        try:
            from endian.authentication.utils.htpasswd import HtPasswd
            ht = HtPasswd(HTTPD_USERS)
            ds = DataSource()
            for user in ds.auth.guiuser:
                name = user.get('name')
                if name not in ht.users():
                    try:
                        password = user.get('password')
                        if not to_bool(user.get('enabled')):
                            password = None
                        ht.add_user(name, password)
                    except:
                        pass
            chown(HTTPD_USERS, "nobody")
            chgrp(HTTPD_USERS, "nogroup")
        except:
            pass

    def save_config(self):
        self.update_groups()
        self.update_users()

        # save default file to /var/efw if config file does not yet exist
        auth = PlainFile('auth/users')
        auth.write()
        chown(HTTPD_USERS, "nobody")
        chgrp(HTTPD_USERS, "nogroup")

        # get the hostname
        ds = DataSource()
        try:
            hostname = ds.host.settings.HOSTNAME
            domain_name = ds.host.settings.get("DOMAINNAME")
            if domain_name:
                hostname = "%s.%s" % (hostname, domain_name)
        except:
            hostname = ""
        if not hostname:
            hostname = "localhost.localdomain"

        settings = {
            "HOSTNAME": hostname,
            "USERS": HTTPD_USERS,
            "GROUPS": HTTPD_GROUPS
        }

        settings.update(SettingsFile(SETTINGS))

        ports = [{'ip': '0.0.0.0', 'port': settings['HTTPD_GUI_PORT']}]
        if settings.get('HTTPD_GUI_PORT') == 'on':
            ports.append({'ip': '0.0.0.0', 'port': '80'})

        self.write_httpd_ports('httpd', ports)

        # certificate
        try:
            cert = self.prepare_certificate(settings.get('CERT_FILENAME'))
            settings['CERT'] = cert['certificate_path']
            settings['KEY'] = cert['key_path']
        except:
            # if the certificate does not exist, use the detault certificate
            cert = {}
            cert['certificate_path'] = DEFAULT_CERTIFICATE
            cert['key'] = DEFAULT_KEY
        if not os.path.exists(cert['certificate_path']) or not os.path.exists(cert['key_path']):
            if not os.path.exists(DEFAULT_CERTIFICATE) or not os.path.exists(DEFAULT_KEY):
                self.generate_self_signed_certificate()
            cert = self.prepare_certificate()
            settings['CERT'] = cert['certificate_path']
            settings['KEY'] = cert['key_path']

        settings['DS'] = ds
        save_old_config(HTTPD_PORTS)
        save_old_config(HTTPD_DEFAULT_SITE)
        changed = {}
        write_config(LOGROTATE + ".tmpl",
                     LOGROTATE,
                     settings)
        settings['LISTEN'] = self.listening_ports()
        changed['inputfw'] = write_config(FIREWALL + ".tmpl",
                                          FIREWALL,
                                          settings)
        changed['httpd'] = write_config(HTTPD_PORTS_TMPL,
                                        HTTPD_PORTS,
                                        settings)
        changed['httpd'] |= write_config(HTTPD_DEFAULT_SITE_TMPL,
                                        HTTPD_DEFAULT_SITE,
                                        settings)
        changed['httpd'] |= self.update_apache_links()
        return changed

    def listening_ports(self):
        """Return a list of unique, non-overlapping binding IP:port"""
        from endian.validators.network import BindableIPAddress
        ds = DataSource('httpd')
        httpd_ports = list(ds.httpd_ports)
        httpd_ports = [dict(d) for d in set(tuple(x.items()) for x in httpd_ports)]
        by_port = {}
        for bind in httpd_ports:
            address = bind.get('ip') or '0.0.0.0'
            port = bind['port']
            by_port.setdefault(port, []).append(address)
        ports = []
        for port, addresses in by_port.iteritems():
            try:
                int(port)
            except Exception, e:
                self.logger.info('skipping invalid post "%s": %s', port, e)
                continue
            if '0.0.0.0'in addresses:
                item = {'ip': '0.0.0.0', 'port': port}
                ports.append(item)
            else:
                for ip in addresses:
                    try:
                        BindableIPAddress().to_python(ip)
                        item = {'ip': ip, 'port': port}
                        ports.append(item)
                    except:
                        pass
        return ports

    @function(name="generate_self_signed_certificate")
    def generate_self_signed_certificate(self, options={}):
        hostname = socket.gethostname()
        env = os.environ.copy()
        env['RANDFILE'] = '/root/.rnd'  # set temporary random file

        self.info("Generating https server key.")
        subprocess.call([
            'openssl', 'genrsa',
            '-out', DEFAULT_KEY,
            str(DEFAULT_KEY_SIZE)],
            env=env)

        self.info("Generating CSR")
        p = subprocess.Popen([
            'openssl', 'req', '-new',
            '-key', DEFAULT_KEY,
            '-out', DEFAULT_CSR],
            stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.STDOUT)
        stdout, stderr = p.communicate(input=".\n.\n.\n.\n.\n" + hostname + "\n.\n\n\n")
        if stderr:
            self.info(stdout)
            self.error(stderr)

        self.info("Signing certificate")
        subprocess.call([
            'openssl', 'x509', '-req', '-sha256',
            '-days', str(DEFAULT_CERT_DAYS),
            '-in', DEFAULT_CSR,
            '-signkey', DEFAULT_KEY,
            '-out', DEFAULT_CERTIFICATE],
            env=env)
        try:
            os.unlink(env['RANDFILE'])
        except:
            pass
        return "OK"

    @action(name="stop",
            options={"debug": (bool, "Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        if options.get("onboot"):
            return EXIT_STATUS_STOP
        self.debug("Stopping httpd...")
        monit("stop httpd", logger=self.logger)
        return EXIT_STATUS_STOP

    @action(name="restart",
            depends=["dnsmasq=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "reload":(bool,"Forces reload."),
                     "updategroups":(bool,"Update the httpd groups file.")}
            )
    def restart(self, options):
        Job.restart(self, options)
        if options.get('updategroups', False):
            self.update_groups()
            self.update_users()
            return EXIT_STATUS_OK
        changed = self.save_config()
        if options.get('force', False):
            set_all_true(changed)
        can_reload = False
        # Temporarily disable reload due to CORE-881
        # if options.get('reload'):
        #    can_reload = True
        reload_service("httpd",
                       logger=self.logger,
                       changed=changed,
                       can_reload=can_reload)
        if changed['inputfw'] and not options.get('onboot', False):
            send_cmd_to_engine("restart setxtaccess")
        return EXIT_STATUS_START

    @action(name="start",
            on="startup",
            depends=["dnsmasq=start"],
            exit_status="start",
            priority=11,
            options={"debug": (bool, "Be more verbose.")}
            )
    def start(self, options):
        Job.start(self, options)
        return self.restart(options)
