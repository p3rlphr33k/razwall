#!/usr/bin/python
#
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2010 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import copy
import tempfile
import iplib
from endian.job.commons import *
from endian.data.container.csvconfig import CsvConfigFile

CONFIGBASE='/var/efw/'
CHAIN='PORTFW'

SETTINGS='/var/efw/dnat/settings'
CONFIG='/var/efw/dnat/config'
ETHERNET_SETTINGS='/var/efw/ethernet/settings'
STATE='/etc/firewall/dnat/iptablesdnat'
TMPFILE="/var/tmp/iptablesdnat"
OPENVPNDIR='/var/efw/openvpnclients/'
OPENVPN_SETTINGS='/var/efw/openvpn/settings'
NEEDRELOAD='/var/efw/dnat/needreload'
LOG_SETTINGS='/var/efw/logging/settings'

TMPL='/etc/firewall/dnat/rules.tmpl'


class SetDNAT(Job):

    _openvpn_ips_cache = None
    _uplink_pool = None    
    _red_interfaces_cache = None
    _address_cache = None
    _openvpn_devices_cache = None
    settings = None
    script = None
    tmpl = None
    
    def colon2dash(self, value):
        return value.replace(":", "-")
    
    def insert_rule(self, obj, log=False):
        methods = {}
        methods['colon2dash'] = self.colon2dash
    
        obj.log = log
        self.satanize_rule(obj)
        cmd = str(self.tmpl(namespaces = [obj, methods]))
        
        self.debug("Create rule nr %d: %s", obj.i, cmd)
        return cmd.strip()
    
    def explode_rules(self, line, explodefields):
        if line.enabled != 'on':
            return
        rules = []
        rules.append(line)
        for field in explodefields:
            tmprules = []
            fieldval = getattr(line, field)
            if fieldval == '':
                continue
            for value in fieldval.split('&'):
                if value == '':
                    continue
                for rule in rules:
                    tmp = copy.deepcopy(rule)
                    setattr(tmp, field, value)
                    tmprules.append(tmp)
            rules = tmprules
        rulenum = len(rules)
        if rulenum > 1:
            self.debug("Exploded rules to %d", rulenum)
        return rules
    
    def get_remote_vpn_nets(self, user):
        import openvpnutils
        ret = []
        userconf = openvpnutils.getUser(user)
        for net in userconf['remotenet'].split(","):
            net = net.strip()
            if net == '' or net == 'None':
                continue
            ret.append(net)
        return ret
            
    def all_openvpn_ips(self):
        import openvpnutils.status
        if self._openvpn_ips_cache != None:
            return self._openvpn_ips_cache
        
        self._openvpn_ips_cache = {}
        try:
            alluser = ''
            for ipport, data in openvpnutils.status.Status().iteritems():
                ip = data['virtual_address']
                if ip == '':
                    continue
                if ip == '0/0':
                    continue
                user = data['user']
    
                self._openvpn_ips_cache[user] = []
                self._openvpn_ips_cache[user].append(ip)
                try:
                    self._openvpn_ips_cache[user].extend(self.get_remote_vpn_nets(user))
                except:
                    self.debug("Openvpn user '%s' has no remote networks.", user)
                
        except:
            self.debug("Could not acquire ip address of Openvpn user '%s'. Maybe it is not connected.", user)
        return self._openvpn_ips_cache
    
    def get_openvpn_ip_by_user(self, user):
        if self._openvpn_ips_cache == None:
            self.all_openvpn_ips()
        if user != 'ANY' and user != 'ALL':
            return self._openvpn_ips_cache[user]
        else:
            ret = []
            for user, net in self.all_openvpn_ips().iteritems():
                ret.extend(net)
            return ret
        return []

    def get_uplink_pool(self):
        from uplinksdaemon.uplinks import UplinksPool
        if self._uplink_pool != None:
            return self._uplink_pool
        self._uplink_pool = UplinksPool()
        return self._uplink_pool

    def all_red_interfaces(self):
        if self._red_interfaces_cache != None:
            return self._red_interfaces_cache
        self._red_interfaces_cache = []
        try:
            for uplink in self.get_uplink_pool().getActiveUplinks():
                if uplink.getSettings()['RED_TYPE'] == 'NONE':
                    continue
                self._red_interfaces_cache.append(uplink.getInterface())
        except:
            pass
        return self._red_interfaces_cache
    
    def get_interface_by_uplink(self, uplink):
        if uplink != 'ANY':
            ul = self.get_uplink_pool().get(uplink)
            if ul.getSettings()['RED_TYPE'] == 'NONE':
                return []
            dev = ul.getInterface()
            if dev != None:
                return [dev]
            return []
        else:
            return self.all_red_interfaces()
    
    def all_openvpn_interfaces(self):
        if self._openvpn_devices_cache != None:
            return self._openvpn_devices_cache
        self._openvpn_devices_cache = []
        for ov in glob.glob(OPENVPNDIR+'/*'):
            dev = self.get_interface_by_openvpn_name(os.path.basename(ov))
            if dev == None:
                continue
            self._openvpn_devices_cache.append(dev)
        return self._openvpn_devices_cache
    
    def get_interface_by_openvpn_name(self, name):
        filename = os.path.join(OPENVPNDIR, name, 'settings')
        if not os.path.exists(filename):
            return None
        conf = get_config(filename)
        if conf.get('DEVICE', '') == '':
            return None
        device = conf['DEVICE']
        if conf.get('ROUTETYPE', 'routed') == 'bridged':
            return "PHYSDEV:%s"%device
        return device
    
    def get_purple_devices(self, server_name=None):
        try:
            from endian.core.pdict import PersistentDict
            pd = PersistentDict('/var/cache/var.efw.vpn.servers')
            servers = DataSource("openvpn").server or []
            purple_devices = set()
            for conf in servers:
                if not conf.get('enabled'):
                    continue
                if server_name is not None and server_name != conf.get('name'):
                    continue
                id_ = conf.get('id')
                purple_dev = pd.get(id_, {}).get('purple_devices') or []
                if id_ and purple_dev:
                    purple_devices = purple_devices.union(purple_dev)
            return list(purple_devices)
        except Exception, e:
            self.logger.error('error getting the list of PURPLE devices: %s', e)
            return []

    def get_vpn_device(self, conn):
        if conn == 'ANY':
            ov = []
            ov.extend(self.all_openvpn_interfaces())
            ov.append('ipsec+')
            ov.append('l2tp+')
            ov.extend(['PHYSDEV:%s' % p for p in self.get_purple_devices()])
            return ov
        if conn == 'SERVER':
            return ['PHYSDEV:%s' % p for p in self.get_purple_devices()]
        if conn and  conn.startswith('SERVER:'):
            return ['PHYSDEV:%s' % p for p in self.get_purple_devices(server_name=conn.split(':', 1)[1])]
        if conn == 'IPSEC':
            return ['ipsec+']
        if conn == 'L2TP':
            return ['l2tp+']
        ret = []
        tap = self.get_interface_by_openvpn_name(conn)
        if tap != None:
            ret.append(tap)
        return ret
    
    def subst_openvpn_user_nets(self, user, rule=None):
        if not user.startswith('OPENVPNUSER:'):
            return user
        username = user.split(':')[1]
        nets = self.get_openvpn_ip_by_user(username)
        if len(nets) == 0:
            self.debug("Substitution of OPENVPNUSER '%s' failed. User unknown or not connected.", username)
            return None
        self.debug("Substitute OPENVPNUSER '%s' with '%s'.", username, nets)
        return "&".join(nets)
    
    def subst_openvpn_user_ip(self, user, rule=None):
        if not user.startswith('OPENVPNUSER:'):
            return user
        username = user.split(':')[1]
        nets = self.get_openvpn_ip_by_user(username)
        if len(nets) == 0:
            self.debug("Substitution of OPENVPNUSER '%s' failed. User unknown or not connected.", username)
            return None
        self.debug("Substitute OPENVPNUSER '%s' with '%s'.", username, nets[0])
        return nets[0]
    
    def subst_vpn_dev(self, dev, rule=None):
        if not dev.startswith('VPN:'):
            return dev
    
        self.debug("Substitute VPN '%s'", dev)
        openvpnconn = dev.split(':', 1)[1]
        if openvpnconn == '':
            self.debug("Key '%s' contains no value.", dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.get_vpn_device(openvpnconn)
        if len(devlist) <= 0:
            self.debug("Connection '%s' has no Devices.", openvpnconn)
            raise KeyError("Connection '%s' has no Devices."%openvpnconn)
        self.debug("Substituted VPN '%s' to: %s", dev, devlist)
        return "&".join(devlist)
    
    def subst_uplink_dev(self, dev, rule=None):
        if not dev.startswith('UPLINK:'):
            return dev
        self.debug("Substitute UPLINK '%s'", dev)
        uplink = dev.split(':')[1]
        if uplink == '':
            self.debug("Key '%s' contains no value.", dev)
            raise KeyError("Key '%s' contains no value."%dev)
        devlist = self.get_interface_by_uplink(uplink)
        if len(devlist) <= 0:
            self.debug("Uplink '%s' has no Devices.", uplink)
            raise KeyError("Uplink '%s' has no Devices."%uplink)
        self.debug("Substituted UPLINK '%s' to: %s", dev, devlist)
        return "&".join(devlist)
    
    def subst_zone_dev(self, value, rule=None):
        if value == 'ALL' or value == 'ANY' or value == '':
            return ''
        if value not in ['GREEN', 'BLUE', 'ORANGE', 'RED']:
            return value
        self.debug("Substitute ZONE '%s'", value)
        if value != 'RED':
            dev = self.settings["%s_DEV"%value]
            self.debug("Substituted ZONE '%s' to: %s", value, dev)
            return dev
        return None
    
    def subst_addresses_by_interface(self, value, rule=None):
        if value.find(":") != -1:
            ip = value.split(":")[0]
            if is_ipaddress(ip):
                return ip
        return "&".join(self.get_addresses_by_interface(value))
    
    def get_address_table(self):
        if self._address_cache != None:
            return self._address_cache
        cmd = "ip -o addr show"
        (status, data) = commands.getstatusoutput(cmd)
        if status != 0:
            return None
        self._address_cache = {'dev':{}, 'ip':{}}
        
        for line in data.split("\n"):
            tokens = line.split()
            if tokens[2] != 'inet':
                continue
            try:
                dev = tokens[1]
                if dev not in self._address_cache['dev']:
                    self._address_cache['dev'][dev] = []
                cidr = tokens[3]
                if cidr.find("/") == -1:
                    cidr = "%s/32"%tokens[3]
                ip = iplib.CIDR(cidr).get_ip().get()
                if ip in self._address_cache['dev'][dev]:
                    continue
                self._address_cache['dev'][dev].append(ip)
                self._address_cache['ip'][ip] = dev
            except:
                self.debug("Could not determine ip address of interface '%s'" % tokens[1], exc_info=True)
        return self._address_cache
    
    def get_addresses_by_interface(self, dev):
        t = self.get_address_table()
        return t['dev'][dev]
    
    def subst_iter(self, values, cb, rule=None, delimiter='&'):
        if not values:
            return values
        if cb == None:
            return values
        ret = ''
        empty = True
        for i in values.split(delimiter):
            if i == None:
                continue
            value=None
            try:
                value = cb(i, rule)
            except:
                self.debug("Substitution failed", exc_info=True)
                continue
            if value == None:
                continue
            ret+=delimiter+value
            empty=False
        if empty:
            self.debug("No suitable value found for substitution of '%s'", values)
            raise Exception("No suitable value found for substitution")
        if ret == '':
            return ''
        return ret[1:]

    def substitute_values(self, rule):
        from endian.firewall.substitutors.l2tp import SubstL2tpDevice
        from endian.firewall.substitutors.l2tp import SubstL2tpIp
        try:
            rule.src_dev = self.subst_iter(rule.src_dev, self.subst_vpn_dev, rule)
            rule.src_dev = self.subst_iter(rule.src_dev, self.subst_uplink_dev, rule)
            rule.src_dev = self.subst_iter(rule.src_dev, self.subst_zone_dev, rule)
            rule.src_dev = self.subst_iter(rule.src_dev,
                                           self.substL2tpDevice.process,
                                           rule)
            rule.src_ip = self.subst_iter(rule.src_ip, self.subst_openvpn_user_nets, rule)
    
            rule.dst_dev = self.subst_iter(rule.dst_dev, self.subst_vpn_dev, rule)
            rule.dst_dev = self.subst_iter(rule.dst_dev, self.subst_uplink_dev, rule)
            rule.dst_dev = self.subst_iter(rule.dst_dev, self.subst_zone_dev, rule)
            rule.dst_dev = self.subst_iter(rule.dst_dev,
                                           self.substL2tpDevice.process,
                                           rule)
            rule.dst_ip = self.subst_iter(rule.dst_ip, self.subst_openvpn_user_nets, rule)
    
            if rule.dst_dev == '' and rule.dst_ip == '':
                return None
            if rule.dst_ip == '':
                rule.dst_ip = self.subst_iter(rule.dst_dev, self.subst_addresses_by_interface, rule)
            rule.target_ip = self.subst_iter(rule.target_ip, self.subst_openvpn_user_ip, rule)
            rule.target_ip = self.subst_iter(rule.target_ip,
                                             self.substL2tpIp.process,
                                             rule)
        except:
            self.debug("Substitution failed", exc_info=True)
            return None
        return rule
    
    def satanize_rule(self, item):
        if item.proto:
            item.proto = item.proto.lower()
        item.physdev_in=False
        if item.src_dev.startswith('PHYSDEV'):
            item.physdev_in=True
            item.src_dev = item.src_dev.split(":")[1]
        item.src_range = False
        if item.src_ip.find('-') != -1:
            item.src_range = True
        item.dst_range = False
        if item.dst_ip.find('-') != -1:
            item.dst_range = True
        item.target_range = False
        if item.target_ip.find('-') != -1:
            item.target_range = True
        item.src_mac = False
        if is_macaddress(item.src_ip):
            item.src_mac = True
        item.dst_port = item.dst_port.replace("-", ":")
        item.target_port = item.target_port.replace("-", ":")
        if item.nat_target == '':
            item.nat_target = 'DNAT'
        if item.filter_target == '':
            item.filter_target = 'ACCEPT'
        if item.src_ip == '':
            item.src_ip = '0/0'
        if item.dst_ip == '':
            item.dst_ip = '0/0'
        item.ipsecin = False
        item.ipsecout = False
        if item.src_dev == 'ipsec+':
            item.src_dev = ''
            item.ipsecin = True
        if item.dst_dev == 'ipsec+':
            item.dst_dev = ''
            item.ipsecout = True
        return item

    
    def get_rules(self):
        ret = []
        confs = []
        self.debug("Read from '%s'", CONFIG)
        try:
            rules=CsvConfigFile(
                '/usr/lib/efw/dnat/config.config',
                CONFIG,
                tolerant=True,
                )
            ret.extend(rules)
        except Exception, e:
            self.error("Could not load config file '%s', because: %s!"%(CONFIG, e))
        return ret
    
    def generate_script(self):
        if self.settings == None:
            self.load_config()
        script = tempfile.NamedTemporaryFile(suffix=".sh", prefix=TMPFILE)

        i = 0
        self.debug("Generate iptables script")
        script.write("iptables -t nat -F %s\n" % CHAIN)
        script.write("iptables -F PORTFWACCESS\n")
        script.write("iptables -t nat -F POSTPORTFW\n")
    
        for rule in self.get_rules():
            i += 1
            rule.i = i
            if rule.enabled != 'on':
                continue
            log = (rule.log == 'on')
            if self.settings.get('DISABLE_FIREWALL_LOGS','off') == 'on':
                log = False
            # ICMP hack
            if rule.proto == 'icmp':
                rule.dst_port = '8&30'
            
            # start explode rule for multiple external access rules
            rules = []
            # need to split into 2 rules if src_dev and src_ip are both set
            fields = ['src_dev', 'src_ip']
            for field in fields:
                tmp = copy.deepcopy(rule)
                # skip if field is empty 
                if getattr(tmp, field) == "":
                    continue
                for delete in fields:
                    if delete == field:
                        continue
                    setattr(tmp, delete, "")
                # split by | to get a rule for every external access source
                for value in getattr(tmp, field).split("|"):
                    tmptmp = copy.deepcopy(tmp)
                    # any must be replaced with empty string in order to 
                    # get a valid iptables rule
                    if value == "any":
                        value = ""
                    setattr(tmptmp, field, value)
                    rules.append(tmptmp)
            
            # if src_dev and src_ip are empty (any)
            if rules == []:
                rules.append(rule)
            for rule in rules:
                if self.substitute_values(rule) == None:
                    continue
                for item in self.explode_rules(rule, ['proto', 'src_dev', 'src_ip', 
                                                 'dst_ip', 'dst_port']):
                    try:
                        script.write(self.insert_rule(item, log))
                        script.write("\n")
                    except Exception, e:
                        self.debug("Explosion failed", exc_info=True)
                        continue
        script.flush()
        return script
    
    def save_config(self):
        self.script = self.generate_script()
    
        if not os.path.exists(STATE):
            self.debug("Script is new!")
            changed = True
        else:
            changed = not filecmp.cmp(self.script.name, STATE, False)
            if changed:
                self.debug("Script has changed!")
            else:
                self.debug("Script has NOT been changed!")
        return changed
    
    def load_config(self):
        from endian.firewall.substitutors.l2tp import SubstL2tpDevice
        from endian.firewall.substitutors.l2tp import SubstL2tpIp
        self.settings = get_config(SETTINGS)
        self.settings.update(get_config(ETHERNET_SETTINGS))
        self.settings.update(get_config(LOG_SETTINGS))
        self.tmpl = Template.compile(file=TMPL)
        self.substL2tpDevice = SubstL2tpDevice(self.logger)
        self.substL2tpIp = SubstL2tpIp(self.logger)
    
    @action(name="restart",
            depends=["firewall=start"],
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces restart."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def restart(self, options):
        Job.restart(self, options)
        # Add the force option if missing; default value=False        
        options['force'] = options.get('force', False)
        self.start(options)
        
    @action(name="start",
            depends=["firewall=start"],
            on="startup_done",
            exit_status="start",
            options={"debug":(bool,"Be more verbose."),
                     "force":(bool,"Forces start."),
                     "trace":(bool,"Display iptables shell script trace.")}
            )    
    def start(self, options):
        Job.start(self, options)
        # Add the force option if missing; default value=True
        options['force'] = options.get('force', True)
        self.info("Restart DNAT firewall, force: %s", options.get('force'))
        changed = self.save_config()
    
        if changed or options.get('force'):
            self.debug("Save script to state file '%s'", STATE)
            shutil.copy(self.script.name, STATE)
    
            self.debug("Call iptables script %s", self.script.name)
            iptables(script=self.script.name, trace=options.get('trace'), logger=self.logger)
        else:
            self.debug("Did not call iptables script")
        self.script.close()
            
        if os.path.exists(NEEDRELOAD):
            os.unlink(NEEDRELOAD)

    @action(name="stop",
            options={"debug":(bool,"Be more verbose.")}
            )
    def stop(self, options):
        Job.stop(self, options)
        
    @action(name="firewall_restart", 
            on="firewall_restart",
            priority=0,
            exit_status="start",
            options={"debug":(bool,"Be more verbose.")}
            )
    def firewall_restart(self, options):
        self.info("Firewall restart setdnat")
        options['force'] = True
        self.start(options)
