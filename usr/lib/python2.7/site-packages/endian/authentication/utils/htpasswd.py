#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from endian.core import logger
from endian.authentication.utils.md5crypt import md5crypt

__all__ = ['HtPasswd']

class HtPasswd(object):

    def __init__(self, path):
        self.path = path
        self._entry_order = []
        self._entry_map = {}
        try:
            f = None
            try:
                f = open(self.path)
                for line in f:
                    if not line.startswith('#'):
                        try:
                            key, value = line.rstrip().split(':')
                            self._add(key, value)
                        except:
                            pass
            finally:
                if f is not None:
                    f.close()
        except Exception, ex:
            logger.error("Error loading apache password file '%s': %s" % (self.path, str(ex)))

    def _add(self, key, value):
        if key not in self._entry_order:
            self._entry_order.append(key)
        self._entry_map[key] = value

    def users(self):
        """
            Return the users names

            :return: a list of the loaded users names
            :rtype: list of string
        """
        return self._entry_order

    def verify_password(self, user, password):
        """
            Verify a password

            :param user: username
            :type user: string
            :param password: cleartext password
            :type password: string
            :return: True is the password is corrent, False otherwise
            :rtype: boolean
        """
        try:
            hash = self._entry_map.get(user)
            if password and password.startswith("$apr1$"):
                return password == hash
            elif hash.startswith("$apr1$"): # MD5 password, apache style
                magic, salt = hash[1:].split('$')[:2]
                magic = '$' + magic + '$'
                return md5crypt(password, salt, magic) == hash
            else:
                return False
        except:
            return False

    def change_password(self, user, password):
        """
            Add a new user (or change password for an exhisting user)
            If password is None, disable the user

            :param user: username
            :type user: string
            :param password: cleartext password
            :type password: string
        """
        if user in self._entry_order:
            self.add_user(user, password)
        else:
            raise Exception('user not found')

    def add_user(self, user, password):
        """
            Add a new user (or change password for an exhisting user)
            If password is None, disable the user

            :param user: username
            :type user: string
            :param password: cleartext password
            :type password: string
        """
        if password is None:
            password = "disabled"
        elif not password.startswith("$apr1$"):
            password = md5crypt(password, magic="$apr1$")
        self._add(user, password)
        self.write()

    def delete_user(self, user):
        """
            Remove an user

            :param user: username
            :type user: string
            :param password: cleartext password
        """
        try:
            self._entry_order.remove(user)
        except:
            pass
        try:
            del self._entry_map[user]
        except:
            pass
        self.write()

    def write(self):
        """
            Write the password file
        """
        if self.path:
            f = None
            try:
                data = str(self)
                f = open(self.path, "w")
                f.write(data)
            finally:
                if f is not None:
                    f.close()

    def __str__(self):
        result = [ "%s:%s" % (user, self._entry_map.get(user,'')) for user in self._entry_order]
        return "\n".join(result) + "\n"

class HtGroups(object):

    def __init__(self, path):
        self.path = path
        self._groups_map = {}
        self._users_map = {}
        try:
            f = open(self.path)
            for line in f:
                if not line.startswith('#'):
                    try:
                        group, members = line.rstrip().split(':')
                        members = members.split()
                        self._groups_map[group] = members
                        for member in members:
                            self._users_map.setdefault(member, []).append(group)
                    except:
                        pass
            f.close()
        except Exception, ex:
            logger.error("Error loading apache groups file '%s': %s" % (self.path, str(ex)))

    def get_groups_by_user(self, user):
        """
            Return the groups of an user

            :return: a list of the groups names
            :rtype: list of string
        """
        return self._users_map.get(user, [])

    def get_members_by_group(self, user):
        """
            Return the members of a group

            :return: a list of the user names
            :rtype: list of string
        """
        return self._groups_map.get(user, [])

    def __str__(self):
        result = [ "%s: %s" % (group, " ".join(members)) for group, members in self._groups_map.iteritems()]
        return "\n".join(result) + "\n"

