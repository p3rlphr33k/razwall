#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import pwd
import grp
import base64
from Crypto.PublicKey import RSA
from Crypto import Random
from endian.core.logger import info, error

RSA_SALT_SIZE = 32
# Private key is used for password decoding
RSA_PRIVATE_KEY_PATH = "/var/efw/access/rsa"
# Public key is used for password encoding
RSA_PUBLIC_KEY_PATH = "/var/efw/access/rsa.pub"

__all__ = ['RSAPasswordDecoder',
           'RSAPasswordEncoder']

class RSAPasswordDecoder(object):
    """
    Decode a password with the RSA private key
    """

    _rsa_private_key = None

    def __init__(self):
        try:
            if os.path.exists(RSA_PRIVATE_KEY_PATH):
                # read the secret key
                with open(RSA_PRIVATE_KEY_PATH, 'r') as f:
                    self._rsa_private_key = RSA.importKey(f.read())
            else:
                # generate a random secret key
                info("Generating RSA key...")
                rng = Random.new().read
                self._rsa_private_key = RSA.generate(1024, rng)
                with open(RSA_PRIVATE_KEY_PATH, 'w') as f:
                    f.write(self._rsa_private_key.exportKey())
                with open(RSA_PUBLIC_KEY_PATH, 'w') as f:
                    f.write(self._rsa_private_key.publickey().exportKey())
        except Exception, ex:
            error(ex)
            raise Exception("Error creating the RSA private key %s" % RSA_PRIVATE_KEY_PATH)
        try:
            os.chmod(RSA_PRIVATE_KEY_PATH, 0400)
            os.chmod(RSA_PUBLIC_KEY_PATH, 0444)
            uid = pwd.getpwnam('nobody').pw_uid
            gid = grp.getgrnam('nogroup').gr_gid
            os.chown(RSA_PRIVATE_KEY_PATH, uid, gid)
            os.chown(RSA_PUBLIC_KEY_PATH, uid, gid)
        except:
            pass

    def __call__(self, e):
        try:
            result = self._rsa_private_key.decrypt(base64.b64decode(e))[RSA_SALT_SIZE:]
        except Exception, ex:
            error(ex)
            return "\0"
        try:
            result = result.decode("utf-8")
        except Exception, ex:
            pass
        return result


class RSAPasswordEncoder(object):
    """
    Encode a password with the RSA public key
    """
    _rsa_public_key = None

    def __call__(self, s, salt=None):
        if self._rsa_public_key is None:
            try:
                with open(RSA_PUBLIC_KEY_PATH, 'r') as f:
                    self._rsa_public_key = RSA.importKey(f.read())
            except Exception:
                raise Exception("Cannot import RSA Public key %s" % RSA_PUBLIC_KEY_PATH)
        if salt is None:
            salt = os.urandom(RSA_SALT_SIZE)
        elif len(salt) != RSA_SALT_SIZE:
            raise Exception("Wrong salt length (must be %d chars)" % RSA_SALT_SIZE)
        s = s.encode("utf-8")
        return base64.b64encode(self._rsa_public_key.encrypt(salt + s, None)[0])

if __name__ == "__main__":
    decode_password = RSAPasswordDecoder()
    encode_password = RSAPasswordEncoder()

    a = encode_password(u'ciao')
    print a
    b = encode_password('ciao')
    print b
    c = decode_password(a)
    print c
    d = decode_password(b)
    print d
