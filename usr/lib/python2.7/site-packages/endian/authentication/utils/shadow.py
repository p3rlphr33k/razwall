#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import crypt

from endian.authentication.utils.md5crypt import md5crypt

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2010-08-23"


SHADOW_PASWORD_FILE = "/etc/shadow"

def get_encrypted_password(username):
    """
    Return the password for the given user name.
    """
    # /etc/shadow contains the encrypted password information for user's accounts and optional the password aging information.
    # All fields are separated by a ':' symbol.
    #
    # Fields:
    # 1 - login name
    # 2 - encrypted password
    # 3 - days since Jan 1, 1970 that password was last changed
    # 4 - days before password may be changed
    # 5 - days after which password must be changed
    # 6 - days before password is to expire that user is warned
    # 7 - days after password expires that account is disabled
    # 8 - days since Jan 1, 1970 that account is disabled
    # 9 - a reserved field
    f = None
    try:
        f = open(SHADOW_PASWORD_FILE)
        for line in f:
            fields = line.strip().split(':')
            if fields[0] == username:
                return fields[1]
    except Exception:
        pass
    if f:
        f.close()

    # Not found
    return "!!"

def authenticate(username, password):
    """
    ... autofunction::: authenticate
        Returns True if the given username and password authenticate again /etc/shadow.
        :param username: the username to authenticate
        :type username: string
        :param password: the password in plain text
        :type password: string
        :return: Returns True if the given username and password authenticate, False otherwise
        :rtype: boolean
    """
    encrypted_password = get_encrypted_password(username)
    if (not encrypted_password or encrypted_password == "!") and not password: # Empty password
        return True
    if "!" in encrypted_password or "*" in encrypted_password: # Locked account
        return False

    # The glibc2 version of crypt function supports additional encryption algorithms.
    # If salt is a character string starting with the characters "$id$" followed by
    # a string terminated by "$":
    #
    #        $id$salt$encrypted
    #
    # then instead of using the DES machine, id identifies the encryption method
    # used and this then determines how the rest of the password string is
    # interpreted.  The following values of id are supported:
    #        ID  | Method
    #        ---------------------------------------------------------
    #        1   | MD5
    #        2a  | Blowfish (not in mainline glibc; added in some
    #            | Linux distributions)
    #        5   | SHA-256 (since glibc 2.7)
    #        6   | SHA-512 (since glibc 2.7)
    if crypt.crypt(password, encrypted_password) == encrypted_password:
        return True

    if encrypted_password.startswith("$1$"): # MD5 password, if crypt does not work well (e.g. on mac)
        magic, salt = encrypted_password[1:].split('$')[:2]
        magic = '$' + magic + '$'
        return md5crypt(password, salt, magic) == encrypted_password

    return False

__all__ = ['authenticate', 'get_encrypted_password']
