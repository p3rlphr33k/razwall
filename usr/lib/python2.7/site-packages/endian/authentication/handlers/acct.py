#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-11-24"

import threading
import time
from endian.core.pdict import PersistentDict, FORMAT_PICKLE
from endian.core import logger
from endian.emi.acl import AuthException

__all__ = ['HANDLER_CLASS',
           'EndianAuthenticationLayerAccounting']

HANDLER_CLASS = 'EndianAuthenticationLayerAccounting'
SESSION_PREFIX = "/var/efw/access/sessions."

# Accounting
class EndianAuthenticationLayerAccounting(object):

    ACTIONS = ['open_session',
               'close_session',
               'list_open_sessions']

    def __init__(self, eal):
        self._lock = threading.Lock()
        self.eal = eal
        self.scopes_sessions = {}

    def open_session(self, username, scope, local=None, remote=None, session_id=None, **argv):
        """
        ... autofunction::: open_session
            Sets up a user session for a previously successful authenticated user.
            The session should later be terminated with a call to close_session.
            :param username: username
            :type username: string
            :param scope: a scope name
            :type scope: string
            :param local: optional local IP address
            :type local: string
            :param remote: optional remote IP address
            :type remote: string
            :param session_id: optional session id (default = username)
            :type session_id: string
        """
        if not session_id:
            session_id = username
        sessions = self._get_scope_sessions(scope)
        session = { 'username': username,
                    'since': int(time.time()),
                    'local': local or "",
                    'remote': remote or "" }
        session.update(argv)
        sessions[session_id] = session
        return { 'open_session' : True }

    def close_session(self, username, scope, session_id=None, **argv):
        """
        ... autofunction::: close_session
            This function is used to indicate that an authenticated session has ended.
            The session should have been created with a call to open_session.
            :param username: username
            :type username: string
            :param scope: a scope name
            :type scope: string
            :param session_id: optional session id (default = username)
            :type session_id: string
        """
        if not session_id:
            session_id = username
        sessions = self._get_scope_sessions(scope)
        try:
            del sessions[session_id]
            return { 'close_session' : True }
        except:
            return { 'close_session' : False }

    def list_open_sessions(self, username=None, scope=None, **argv):
        """
        ... autofunction::: list_open_sessions
            List the open sessions.
            :param username: an optional username
            :type username: string
            :param scope: an optional scope scope name
            :type scope: string
        """
        result = {}
        if not scope:
            for scope in self.eal.get_scope_names():
                sessions = dict(self._get_scope_sessions(scope, use_list_open_session=True))
                # Filter by username
                if username:
                    sessions = dict([(k,v) for k,v in sessions.iteritems() if v.get('username') == username])
                # Filter by additional args
                for arg_k, arg_v in argv.iteritems():
                    sessions = dict([(k,v) for k,v in sessions.iteritems() if v.get(arg_k) == arg_v])
                result[scope] = sessions
            return result
        else:
            sessions = dict(self._get_scope_sessions(scope, use_list_open_session=True))
            # Filter by username
            if username:
                sessions = dict([(k,v) for k,v in sessions.iteritems() if v.get('username') == username])
            # Filter by additional args
            for arg_k, arg_v in argv.iteritems():
                sessions = dict([(k,v) for k,v in sessions.iteritems() if v.get(arg_k) == arg_v])
            return { scope: sessions }

    def _get_scope_sessions(self, scope, use_list_open_session=False):
        if use_list_open_session:
            # Try calling the list_open_session function of the given scope
            # (this function return additional information about the connection)
            try:
                fn = self.eal.get_scope_module(scope).list_open_sessions
                try:
                    return fn()
                except Exception, ex:
                    logger.error(str(ex), exc_info=True)
            except:
                pass
        s = self.scopes_sessions.get(scope, None)
        if s is not None:
            return s
        try:
            self._lock.acquire()
            # Try again inside the lock
            s = self.scopes_sessions.get(scope, None)
            if s is not None:
                return s
            # Check if the scope exists
            if scope not in self.eal.get_scope_names():
                raise AuthException("Scope not found")
            # Create the instance
            s = PersistentDict(SESSION_PREFIX + scope, format=FORMAT_PICKLE) # use pickle instead of YAML
            self.scopes_sessions[scope] = s
            return s
        finally:
            self._lock.release()

