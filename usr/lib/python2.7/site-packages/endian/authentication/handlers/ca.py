#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-11-17"

import os
import threading
import subprocess
from datetime import datetime
from endian.core import logger
from endian.core.pdict import PersistentDict
from endian.validators.boolean import to_bool
from endian.emi.acl import AuthException

__all__ = [
    'HANDLER_CLASS',
    'OPENSSL_CONFIG',
    'CA_ROOT_DIR',
    'CA_CACONFIG_PATH',
    'CA_CACERTS_DIR',
    'CA_PRIVATE_DIR',
    'CA_CERTS_DIR',
    'CA_CERTS_STATUS',
    'CA_CRLS_DIR',
    'CA_INDEX',
    'CA_SERIAL',
    'CA_CA',
    'CA_CERT',
    'CA_KEY',
    'CA_CRL',
    'CERT_TYPE_OPTIONS',
    'DEFAULT_CERT_DAYS',
    'CERT_STATUS_VALID',
    'CERT_STATUS_REVOKED',
    'CERT_STATUS_INVALID',
    'CERT_STATUS_EXPIRED',
    'CAConfigItem',
    'EndianCertificateAuthority',
    'DEFAULT_DIGEST',
    'CERT_DIGEST_OPTIONS'
]

# OpenSSL command name
OPENSSL_BIN = "openssl"

HANDLER_CLASS = 'EndianCertificateAuthority'
OPENSSL_CONFIG = "/etc/ssl/endian-vpn.conf"

CA_ROOT_DIR = "/var/efw/vpn/ca/"

CA_CACONFIG_PATH = os.path.join(CA_ROOT_DIR, "caconfig")
CA_CACERTS_DIR = os.path.join(CA_ROOT_DIR, "cacerts")
CA_PRIVATE_DIR = os.path.join(CA_ROOT_DIR, "private")
CA_CERTS_DIR = os.path.join(CA_ROOT_DIR, "certs")
CA_CERTS_STATUS = os.path.join(CA_ROOT_DIR, "certs.status")
CA_CRLS_DIR = os.path.join(CA_ROOT_DIR, "crls")
CA_INDEX = os.path.join(CA_CERTS_DIR, "index.txt")
CA_SERIAL = os.path.join(CA_CERTS_DIR, "serial")
CA_CA = "ca"
CA_CERT = os.path.join(CA_CACERTS_DIR, "cacert.pem")
CA_KEY = os.path.join(CA_PRIVATE_DIR, "cakey.pem")
CA_CRL = os.path.join(CA_ROOT_DIR, "crl.pem")

CERT_STATUS_VALID = "valid"
CERT_STATUS_REVOKED = "revoked"
CERT_STATUS_INVALID = "invalid"
CERT_STATUS_EXPIRED = "expired"

# Don't change the order!
CERT_TYPE_OPTIONS = ['client', 'server', 'email', 'objsign', 'reserved', 'sslCA', 'emailCA', 'objCA']

DEFAULT_CERT_DAYS = 3652 # 10 years  # 99999

CERT_DIGEST_OPTIONS = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512']
DEFAULT_DIGEST = 'sha256'

RFC2253_ESCAPE = ' "+,;<>\\/' # See RFC2253

certs_status = PersistentDict(CA_CERTS_STATUS)

class CAConfigItem(object):
    def __init__(self, i=0, name='', subject=''):
        self._meta = ['i', 'name', 'subject']
        self.i = i
        self.name = name
        self.subject = subject

class EndianCertificateAuthority(object):

    ACTIONS = ['create_certificate',
               'create_certificate_authority',
               'revoke_certificate',
               'verify_certificate',
               'sign_certificate_request',
               'create_hash_symlink',
               'create_ca_hash_symlink',
               'create_crl_hash_symlink',
               'generate_crl',
               'update_index',
               'recreate_hash_symlinks',
              ]

    def __init__(self, eal):
        self._lock = threading.Lock()
        self.eal = eal

    def create_certificate(self, cert_name, cert_email="", cert_ou="", cert_organization="",
                           cert_city="", cert_state="", cert_country="", cert_subjectaltname="",
                           cert_password="", cert_days="", cert_filename="", cert_type="",
                           cert_comment="", cert_start_date="", cert_digest=DEFAULT_DIGEST, **argv):
        """
            Create a new certificate

            :param cert_name: CN = CommonName
            :type cert_name: string
            :param cert_email: Email address
            :type cert_ou: string
            :param cert_organization: OU = Organization Unit typically certificate type
            :type cert_organization: string
            :param cert_city: L = Locality; generally - city
            :type cert_city: string
            :param cert_state: ST = state or province
            :type cert_state: string
            :param cert_country: C = ISO3166 two character country code
            :type cert_country: string
            :param cert_subjectaltname:
            :type cert_subjectaltname: string
            :param cert_password: certificate password
            :type cert_password: string
            :param cert_days: default certificate validity in days
            :type cert_days: string or int
            :param cert_filename: certificate file name (equals to cert_name if empty)
            :type cert_filename: string
            :param cert_type: optional certificate type (check CERT_TYPE_OPTIONS for valid options)
            :type cert_type: string
            :param cert_comment: optional comment
            :type cert_comment: string
            :param cert_start_date: optional certificate validity notBefore
            :type cert_start_date: string in YYMMDDHHMMSSZ format
            :param cert_digest: digest algorithm
            :type cert_digest: string
        """
        if not os.path.exists(CA_CERT):
            raise AuthException("Create the CA before generating the certificate")
        if not cert_filename or cert_filename == "None":
            cert_filename = generate_filename(cert_name)
        if cert_type and cert_type not in CERT_TYPE_OPTIONS:
            raise AuthException("Invalid certificate type '%s' " % cert_type)
        if not cert_digest:
            cert_digest = DEFAULT_DIGEST
        if cert_digest not in CERT_DIGEST_OPTIONS:
            raise AuthException("Invalid certificate digest '%s' " % cert_digest)

        subject = self._prepare_subject(cert_name, cert_email, cert_ou, cert_organization,
                           cert_city, cert_state, cert_country, cert_subjectaltname)

        key_filename = os.path.join(CA_CERTS_DIR, cert_filename + "key.pem")
        req_filename = os.path.join(CA_CERTS_DIR, cert_filename + "req.csr")

        # Create the certificate request
        logger.info("Creating a certificate for %s" % cert_name)

        p = subprocess.Popen([OPENSSL_BIN, "req",
                                 "-config", OPENSSL_CONFIG,
                                 "-new", "-nodes", "-batch",
                                 "-newkey", "rsa:1024",
                                 "-%s" % cert_digest,
                                 "-keyout", key_filename,
                                 "-out", req_filename,
                                 "-subj", subject],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        output = p.communicate()[0]
        exit_code = p.returncode

        if exit_code != 0:
            for f in [key_filename, req_filename]:
                try:
                    os.unlink(f)
                except:
                    pass
            raise AuthException("Error creating the certificate: %s" % output)

        # Sign the certificate request
        return self.sign_certificate_request(cert_name=cert_name,
                              cert_subjectaltname=cert_subjectaltname,
                              cert_password=cert_password,
                              cert_days=cert_days,
                              cert_filename=cert_filename,
                              cert_type=cert_type,
                              cert_comment=cert_comment,
                              cert_start_date=cert_start_date,
                              cert_digest=cert_digest,
                              **argv)

    @classmethod
    def _escape(cls, value):
        # Escape a value according to RFC2253
        return ''.join([c in RFC2253_ESCAPE and '\\' + c or c for c in (value or '')])

    @classmethod
    def _prepare_subject(cls, cert_name, cert_email="", cert_ou="", cert_organization="",
                           cert_city="", cert_state="", cert_country="", cert_subjectaltname="",
                           **argv):
        # Various interpretations of the RDN fields exist the
        # following are presented as generally accepted values
        subject = ""
        if cert_country: # ISO3166 two character country code
            subject += "/C=" + cls._escape(cert_country)
        if cert_state: # ST = state or province
            subject += "/ST=" + cls._escape(cert_state)
        if cert_city: # L = Locality; generally - city
            subject += "/L=" + cls._escape(cert_city)
        if cert_organization: # O = Organization - Company Name
            subject += "/O=" + cls._escape(cert_organization)
        if cert_ou: # OU = Organization Unit typically certificate type
            subject += "/OU=" + cls._escape(cert_ou)
        # CN = CommonName/emailAddress=email
        subject += "/CN=" + cls._escape(cert_name)
        if cert_email:
            subject += "/emailAddress=" + cls._escape(cert_email)
        return subject

    def sign_certificate_request(self, cert_name, cert_subjectaltname="", cert_password="", cert_days="",
                         cert_filename="", cert_type="", cert_comment="", cert_start_date="",
                         revoke_old_certificate=False, cert_digest=DEFAULT_DIGEST, **argv):
        """
            Sign a certificate request

            :param cert_name: CN = CommonName
            :type cert_name: string
            :param cert_subjectaltname:
            :type cert_subjectaltname: string
            :param cert_password: certificate password
            :type cert_password: string
            :param cert_days: default certificate validity in days
            :type cert_days: string or int
            :param cert_type: optional certificate type (check CERT_TYPE_OPTIONS for valid options)
            :type cert_type: string
            :param cert_comment: optional comment
            :type cert_comment: string
            :param cert_start_date: optional certificate validity notBefore
            :type cert_start_date: string in YYMMDDHHMMSSZ format
            :param revoke_old_certificate: revoke the old certificate if exist
            :type revoke_old_certificate: boolean
            :param cert_digest: digest algorithm
            :type cert_digest: string
        """
        from OpenSSL import rand
        if not os.path.exists(CA_CERT):
            raise AuthException("Create the CA before generating the certificate")
        if not cert_filename or cert_filename == "None":
            cert_filename = generate_filename(cert_name)
        if not cert_days or cert_days == "None":
            cert_days = DEFAULT_CERT_DAYS
        if cert_type and cert_type not in CERT_TYPE_OPTIONS:
            raise AuthException("Invalid certificate type '%s' " % cert_type)
        if not cert_start_date:
            cert_start_date = datetime.utcnow().strftime("%y%m%d%H%M%SZ")
        if not cert_digest:
            cert_digest = DEFAULT_DIGEST
        if cert_digest not in CERT_DIGEST_OPTIONS:
            raise AuthException("Invalid certificate digest '%s' " % cert_digest)

        # Sign the certificate request
        logger.info("Signing the cert %s" % cert_name)
        if not cert_days:
            cert_days = DEFAULT_CERT_DAYS

        # Check if a certificate with the same name already exist
        cert_filename = cert_filename.replace('/', '_') # clean the filename
        if os.path.exists(os.path.join(CA_CERTS_DIR, cert_filename + "cert.pem")):
            # The certificate exists. Check if it is revoked.
            status = self.verify_certificate(cert_name)
            if not status['revoked']:
                revoke_old_certificate = to_bool(revoke_old_certificate)
                if not revoke_old_certificate:
                    raise AuthException("A certificate with the same name already exists.")
                self.revoke_certificate(cert_name)

        # No easy way for specifying the contain of subjectAltName without writing a config file..
        from tempfile import NamedTemporaryFile
        f = NamedTemporaryFile()
        if cert_subjectaltname:
            f.write('subjectAltName=%s\n' % cert_subjectaltname)
        f.write('basicConstraints=CA:FALSE\n')
        if cert_comment:
            f.write('nsComment="%s"\n' % cert_comment.replace('"', '\\"'))
        else:
            f.write('nsComment="Authentication Layer Generated Certificate"\n')
        f.write('subjectKeyIdentifier=hash\n')
        f.write('authorityKeyIdentifier=keyid,issuer:always\n')
        if cert_type:
            f.write('nsCertType=%s\n' % cert_type)
            if cert_type == 'server':
                # Required by Windows 7 client for IPsec server certificate
                f.write('extendedKeyUsage=serverAuth\n')

        f.flush()

        key_filename = os.path.join(CA_CERTS_DIR, cert_filename + "key.pem")
        req_filename = os.path.join(CA_CERTS_DIR, cert_filename + "req.csr")
        p12_filename = os.path.join(CA_CERTS_DIR, cert_filename + ".p12")
        out_filename = os.path.join(CA_CERTS_DIR, cert_filename + "cert.pem")

        try:
            self._lock.acquire()

            # Generate the certificate serial (128 bit positive number)
            n = [ord(x) for x in rand.bytes(16)]
            if n[0] > 127:
                n[0] = n[0] % 128
            serial = "%s\n" % "".join(["%02X" % x for x in n])
            try:
                sf = file(CA_SERIAL, 'w+')
                sf.write(serial)
            finally:
                sf.close()

            p = subprocess.Popen([OPENSSL_BIN, "ca",
                                 "-config", OPENSSL_CONFIG,
                                 "-days", str(cert_days),
                                 "-batch", "-notext",
                                 "-md", cert_digest,
                                 "-in", req_filename,
                                 "-out", out_filename,
                                 "-extfile", f.name,
                                 "-startdate", cert_start_date],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
            output = p.communicate()[0]
            exit_code = p.returncode
        finally:
            self._lock.release()
        f.close() # close and delete the tmp file

        if exit_code != 0:
            for f in [key_filename, req_filename, out_filename]:
                try:
                    os.unlink(f)
                except:
                    pass
            raise AuthException("Error signing the certificate: %s" % output)

        # Delete the certificate request
        try:
            os.unlink(req_filename)
        except:
            pass

        # Mark the certificate as valid
        certs_status[cert_filename] = CERT_STATUS_VALID

        # Create the hash symlink
        self._create_hash_symlink(out_filename, "x509")

        # If the private key does not exist,
        # exit without packaging the p12
        if not os.path.exists(key_filename):
            return { 'cert_filename': out_filename }

        # Create the pkcs12 file
        logger.info("Packing a pkcs12 file..");

        p = subprocess.Popen([OPENSSL_BIN, "pkcs12",
                                     "-export",
                                     "-inkey", key_filename,
                                     "-in", out_filename,
                                     "-name", cert_name,
                                     "-passout", "pass:%s" % cert_password,
                                     "-certfile", CA_CERT,
                                     "-out", p12_filename],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)

        output = p.communicate()[0]
        exit_code = p.returncode
        if exit_code != 0:
            return { 'cert_filename': out_filename }
        else:
            return { 'p12_filename': p12_filename,  'cert_filename': out_filename }

    def create_certificate_authority(self, cert_name, cert_email="", cert_ou="", cert_organization="",
                           cert_city="", cert_state="", cert_country="", cert_subjectaltname="",
                           cert_days="", cert_filename="", cert_digest="", **argv):
        """
            Create a new certificate

            :param cert_name: CN = CommonName
            :type cert_name: string
            :param cert_email: Email address
            :type cert_ou: string
            :param cert_organization: OU = Organization Unit typically certificate type
            :type cert_organization: string
            :param cert_city: L = Locality; generally - city
            :type cert_city: string
            :param cert_state: ST = state or province
            :type cert_state: string
            :param cert_country: C = ISO3166 two character country code
            :type cert_country: string
            :param cert_subjectaltname:
            :type cert_subjectaltname: string
            :param cert_days: default certificate validity in days
            :type cert_days: string or int
            :param cert_filename: certificate file name (equals to cert_name if empty)
            :type cert_filename: string
            :param cert_digest: digest algorithm
            :type cert_digest: string
        """
        if not cert_filename or cert_filename == "None":
            cert_filename = cert_name
        if not cert_days or cert_days == "None":
            cert_days = DEFAULT_CERT_DAYS
        if not cert_digest:
            cert_digest = DEFAULT_DIGEST
        if cert_digest not in CERT_DIGEST_OPTIONS:
            raise AuthException("Invalid certificate digest '%s' " % cert_digest)

        subject = self._prepare_subject(cert_name, cert_email, cert_ou, cert_organization,
                           cert_city, cert_state, cert_country, cert_subjectaltname)

        key_filename = os.path.join(CA_PRIVATE_DIR, cert_filename + "key.pem")
        out_filename = os.path.join(CA_CACERTS_DIR, cert_filename + "cert.pem")

        # Create the ca certificate
        logger.info("Creating certificate authority %s" % cert_name)

        p = subprocess.Popen([OPENSSL_BIN, "req",
                                 "-config", OPENSSL_CONFIG,
                                 "-x509", "-nodes", "-batch",
                                 "-newkey", "rsa:2048",
                                 "-%s" % cert_digest,
                                 "-days", str(cert_days),
                                 "-keyout", key_filename,
                                 "-out", out_filename,
                                 "-subj", subject],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        output = p.communicate()[0]
        exit_code = p.returncode

        if exit_code != 0:
            for f in [key_filename, out_filename]:
                try:
                    os.unlink(f)
                except:
                    pass
            raise AuthException("Error creating certificate authority: %s" % output)

        # Truncate the index file
        open(CA_INDEX,'w+').close()

        # Reset ca serial numbers
        f = file(CA_SERIAL, 'w+')
        f.write("01\n")
        f.close()

        # Create the hash symlink
        self._create_hash_symlink(out_filename, "x509")

        # Generate the CRL file
        self.generate_crl()

        return { 'key_filename': key_filename, 'cert_filename': out_filename }

    def generate_crl(self):
        """
            Generate/regenerate the CRL file
        """
        if not os.path.exists(CA_CERT):
            raise AuthException("Create the CA before generating the CRL file")

        # Generate the CRL file
        crl_filename = os.path.join(CA_CRL)
        try:
            self._lock.acquire()
            p = subprocess.Popen([OPENSSL_BIN, "ca",
                                 "-config", OPENSSL_CONFIG,
                                 "-gencrl", "-batch",
                                 "-md", DEFAULT_DIGEST,
                                 "-out", crl_filename],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
            output = p.communicate()[0]
            exit_code = p.returncode
        finally:
            self._lock.release()
        if exit_code != 0:
            logger.error(output)

        # Create the symlink to the CRL file
        self._create_hash_symlink(crl_filename, "crl")

        # Create the symlink in the CRLs directory
        try:
            os.symlink(crl_filename, os.path.join(CA_CRLS_DIR, "%s.crl" % CA_CA))
        except:
            pass

        return { 'crl_filename': crl_filename }

    def revoke_certificate(self, cert_name, **argv):
        """
            Revoke and delete a certificate
            (the certificates issued by other CAs are only deleted, not revoked)

            :param cert_name: Certificate name
            :type cert_name: string
        """
        logger.info("Revoking the cert %s" % cert_name)

        cert_filename = generate_filename(cert_name)
        out_filename = os.path.join(CA_CERTS_DIR, cert_filename + "cert.pem")
        key_filename = os.path.join(CA_CERTS_DIR, cert_filename + "key.pem")
        p12_filename = os.path.join(CA_CERTS_DIR, cert_filename + ".p12")

        if self._check_certificate_ca(cert_name, CA_CA)['valid']:
            try:
                self._lock.acquire()
                p = subprocess.Popen([OPENSSL_BIN, "ca",
                                 "-config", OPENSSL_CONFIG,
                                 "-batch",
                                 "-revoke", out_filename],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
                output = p.communicate()[0]
                exit_code = p.returncode
                action = "revoke"
            finally:
                self._lock.release()
        else:
            # Not valid certificates cannot be revoked
            action = "delete"
            exit_code = 0

        # Delete the certificate files
        if action == "revoke":
            files = [key_filename, p12_filename]
        else:
            files = [out_filename, key_filename, p12_filename]
        for f in files:
            try:
                os.unlink(f)
            except:
                pass

        if action == "revoke":
            # Regenerate the CRL file
            self.generate_crl()
            # Mark the certificate as revoked
            certs_status[cert_filename] = CERT_STATUS_REVOKED
        else:
            # Delete the certificate status
            try:
                del certs_status[cert_filename]
            except:
                pass

        # Delete the broken symlinks
        self._delete_broken_symlinks()

        if exit_code != 0:
            logger.error(output)
            raise AuthException(output)

        return { 'cert_filename': out_filename, 'action': action }

    def _check_certificate_ca(self, cert_name, ca_name):
        """
            Verify is a certificate was issued by a given CA

            :param cert_name: Certificate name
            :type cert_name: string
            :param ca_name: CA name
            :type ca_name: string
        """
        cert_filename = os.path.join(CA_CERTS_DIR, cert_name + "cert.pem")
        ca_filename = os.path.join(CA_CACERTS_DIR, ca_name + "cert.pem")
        p = subprocess.Popen([OPENSSL_BIN, "verify",
                              "-CAfile", ca_filename,
                              cert_filename],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        output = p.communicate()[0].strip()
        valid = output.endswith("OK")

        return { 'output': output, 'valid': valid  }

    def verify_certificate(self, cert_name, **argv):
        """
            Verify a certificate

            :param cert_name: Certificate name
            :type cert_name: string
        """
        cert_filename = generate_filename(cert_name)
        out_filename = os.path.join(CA_CERTS_DIR, cert_filename + "cert.pem")
        p = subprocess.Popen([OPENSSL_BIN, "verify",
                              "-crl_check",
                              "-CApath", CA_CERTS_DIR,
                              out_filename],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
        output = p.communicate()[0].strip()

        if 'unable to get certificate CRL' in output:
            # CRL not found, repeat without checking the CRL
            p = subprocess.Popen([OPENSSL_BIN, "verify",
                                "-CApath", CA_CERTS_DIR,
                                out_filename],
                                stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)
            output = p.communicate()[0].strip()
        elif 'lookup:' in output:
            output = output.split('lookup:')[1]

        valid = output.endswith("OK")
        revoked = not valid and "certificate revoked" in output
        expired = not valid and "certificate has expired" in output

        return { 'output': output, 'valid': valid , 'revoked': revoked, 'expired': expired }

    def create_hash_symlink(self, cert_name,  **argv):
        """
            Create the certificate hash symlink used by openssl

            :param cert_name: Certificate name
            :type cert_name: string
        """
        cert_filename = generate_filename(cert_name)
        out_filename = os.path.join(CA_CERTS_DIR, cert_filename + "cert.pem")
        cert_hash_filename, output = self._create_hash_symlink(out_filename, "x509")
        return { 'cert_hash_filename': cert_hash_filename, 'output': output }

    def create_ca_hash_symlink(self, cert_name,  **argv):
        """
            Create the CA certificate hash symlink used by openssl

            :param cert_name: CA Certificate name
            :type cert_name: string
        """
        cert_filename = generate_filename(cert_name)
        out_filename = os.path.join(CA_CACERTS_DIR, cert_filename + "cert.pem")
        cert_hash_filename, output = self._create_hash_symlink(out_filename, "x509")
        return { 'cert_hash_filename': cert_hash_filename, 'output': output }

    def create_crl_hash_symlink(self, crl_name,  **argv):
        """
            Create the CRL hash symlink used by openssl

            :param cert_name: CRL name
            :type cert_name: string
        """
        crl_filename = os.path.join(CA_CRLS_DIR, crl_name + ".crl")
        crl_hash_filename, output = self._create_hash_symlink(crl_filename, "crl")
        return { 'crl_hash_filename': crl_hash_filename, 'output': output }

    def _create_hash_symlink(self, filename, filetype="x509", remove_old_symlinks=True, delete_broken_symlinks=True):
        """
            Create a symlink used by openssl for a certificat/CA certificate/CRL

            :param filename: full path of the file to be symlinked
            :type filename: string
            :param filetype: x509 or crl
            :type filetype: string
            :param remove_old_symlinks: if true, remove the old symlinks to the file
            :param remove_old_symlinks: boolean
        """

        # Delete the broken symlinks
        if delete_broken_symlinks:
            self._delete_broken_symlinks()

        # Remote old symlinks to the file
        if remove_old_symlinks:
            for name in os.listdir(CA_CERTS_DIR):
                link = os.path.join(CA_CERTS_DIR, name)
                if link != filename and os.path.islink(link) and os.path.realpath(link) == filename:
                    try:
                        os.unlink(link)
                    except:
                        pass

        # Get the file hash
        p = subprocess.Popen([OPENSSL_BIN, filetype,
                              "-hash",
                              "-noout",
                              "-in",
                              filename],
                              stdout=subprocess.PIPE,
                              stderr=subprocess.STDOUT)
        cert_hash = p.communicate()[0].strip()
        exit_code = p.returncode
        if exit_code != 0 and filetype == "x509": # "openssl crl -hash .." exits with exit code 1 instead of 0 :-(
            return "", cert_hash

        # Find a name for the symlink
        prefix = filetype == "crl" and "r" or ""
        i = 0
        while os.path.lexists(os.path.join(CA_CERTS_DIR, "%s.%s%s" % (cert_hash, prefix, i))): # lexist returns True for broken symbolic links
            i = i + 1
        cert_hash_filename = os.path.join(CA_CERTS_DIR, "%s.%s%s" % (cert_hash, prefix, i))

        # Create the symlink
        os.symlink(filename, cert_hash_filename)
        return cert_hash_filename, cert_hash

    def update_index(self):
        """
            Checks index.txt for expired certificates and mark them
        """
        if not os.path.exists(CA_CERT):
            raise AuthException("Create the CA before updating index file")
        try:
            self._lock.acquire()
            p = subprocess.Popen([OPENSSL_BIN, "ca",
                                 "-config", OPENSSL_CONFIG,
                                 "-updatedb",
                                 "-verbose"],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
            output = p.communicate()[0]
        finally:
            self._lock.release()
        # TODO: Check new expired certificates
        pass

        # Update the status
        for name in os.listdir(CA_CERTS_DIR):
            if name.endswith("cert.pem"):
                name = name[:-8]
                if name not in certs_status:
                    status = self.verify_certificate(name)
                    if status.get('valid'):
                        certs_status[name] = CERT_STATUS_VALID
                    elif status.get('revoked'):
                        certs_status[name] = CERT_STATUS_REVOKED
                    elif status.get('expired'):
                        certs_status[name] = CERT_STATUS_EXPIRED
                    else:
                        certs_status[name] = CERT_STATUS_INVALID

        return {"info": output}

    def _delete_broken_symlinks(self):
        """
            Delete the broken symlinks
        """
        for name in os.listdir(CA_CERTS_DIR):
            link = os.path.join(CA_CERTS_DIR, name)
            if os.path.islink(link) and not os.path.exists(os.readlink(link)):
                try:
                    os.unlink(link)
                except:
                    pass

    def recreate_hash_symlinks(self, **argv):
        """
           Recreate all the CAs, certificates, and CRLs hash symlinks
        """
        # Delete all the symlinks
        for name in os.listdir(CA_CERTS_DIR):
            link = os.path.join(CA_CERTS_DIR, name)
            if os.path.islink(link):
                try:
                    os.unlink(link)
                except:
                    pass
        # Create the CA certificates symlinks
        for name in os.listdir(CA_CACERTS_DIR):
            name = os.path.join(CA_CACERTS_DIR, name)
            if name.endswith(".pem"):
                self._create_hash_symlink(name, "x509", remove_old_symlinks=False, delete_broken_symlinks=False)
        # Create the certificates symlinks
        for name in os.listdir(CA_CERTS_DIR):
            name = os.path.join(CA_CERTS_DIR, name)
            if name.endswith("cert.pem"):
                self._create_hash_symlink(name, "x509", remove_old_symlinks=False, delete_broken_symlinks=False)
        # Create the CRLs symlinks
        for name in os.listdir(CA_CRLS_DIR):
            name = os.path.join(CA_CRLS_DIR, name)
            if name.endswith(".crl"):
                self._create_hash_symlink(name, "crl", remove_old_symlinks=False, delete_broken_symlinks=False)
        return {"info": "Symlinks created"}

def generate_filename(cert_name):
    """
        Generate the file name starting from the certificate common name
        (basically change *.example.com into _.example.com, and replace / with _)
    """
    if not cert_name:
        return cert_name
    cert_name = cert_name.replace('/', '_')
    if cert_name.startswith('*.'):
        cert_name = '_.' + cert_name[2:]
    return cert_name

