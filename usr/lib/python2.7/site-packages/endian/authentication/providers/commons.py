#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from endian.core.i18n import _
from endian.core import logger
from endian.core.sha512crypt import sha512crypt
from endian.emi.storage.yamlstorage import YamlStorage
from endian.emi.acl import AuthException, UserNotFoundError, AuthNotImplemented

__all__ = [
    'PROVIDER_OPTIONS',
    'GroupNotFoundError',
    'GroupNotEnableddError',
    'AuthProvider',
    'AuthNotImplemented'
]

PROVIDER_OPTIONS = [
    'can_authenticate',
    'can_get_user',
    'can_list_users',
    'can_update_user',
    'can_create_user',
    'can_delete_user',
    'can_sync_users',
    'can_get_group',
    'can_list_groups',
    'can_update_group',
    'can_create_group',
    'can_delete_group',
    'can_sync_groups'
]

# Keys that are never supposed to be merged (only include keys
# starting with vpn_ or l2tp_).
NEVER_MERGE_KEYS = {
    'vpn_domain': None,
    'vpn_custom_dns': None,
    'l2tp_ipsec_tunnel': None
}

def merge_values(key, user_val, group_val):
    """Merge a key value for a user and its group(s)."""
    if key in NEVER_MERGE_KEYS and user_val:
        return user_val
    if not group_val:
        return user_val
    value = user_val
    if isinstance(group_val, bool):
        return user_val or group_val
    elif isinstance(group_val, (list, tuple)):
        user_val = user_val or []
        return user_val + [x for x in group_val if x not in user_val]
    return value

class GroupNotFoundError(AuthException):
    def __init__(self, message=_("Group not found")):
        AuthException.__init__(self, message)

class GroupNotEnableddError(AuthException):
    def __init__(self, message=_("Group not enabled")):
        AuthException.__init__(self, message)

class AuthProvider(object):
    id = None
    name = None
    can_authenticate = False
    can_get_user = False
    can_list_users = False
    can_update_user = False
    can_create_user = False
    can_delete_user = False
    can_sync_users = False
    can_get_group = False
    can_list_groups = False
    can_update_group = False
    can_create_group = False
    can_delete_group = False
    can_sync_groups = False
    enabled_for_vpn = False

    def __init__(self, **argv):
        self.provider_name = argv.get('name')

    def authenticate(self, username, password, scope, password_already_verified=False, **argv):
        """
            Overwrite this function to authenticate a user. E.g. raise UserNotFoundError, InvalidPasswordError or
            UserNotEnableddError exceptions if authentication fails.

            :param username: name of the user
            :type username: str
            :param password: password of the user
            :type password: str
            :param scope: name of the scope which is used for authentication
            :type scope: str
            :param password_already_verified: do we need to verify the password again
            :type password_already_verified: bool
            :rtype: dict
        """
        raise AuthNotImplemented()

    def get_user(self, username, scope, retrieve_attributes="*", **argv):
        """
            Overwrite this function to get info of a user by name and scope.

            :param username: name of the user
            :type username: str
            :param scope: name of the scope to search within
            :type scope: str
            :param retrieve_attributes: return this attributes in the dict
            :type retrieve_attributes: string or list of strings
            :rtype: dict
        """
        raise AuthNotImplemented()

    def list_users(self, scope, retrieve_attributes=["name"], **argv):
        """
            Overwrite this function to return infos about all users of this provider.

            :param username: name of the user
            :type username: str
            :param scope: name of the scope to search within
            :type scope: str
            :param retrieve_attributes: return this attributes in the dict
            :type retrieve_attributes: string or list of strings
            :rtype: list of dicts
        """
        raise AuthNotImplemented()

    def create_user(self, username, scope, password=None, args=None):
        """
            Overwrite this function to create a new user.

            :param username: name of the user
            :type username: str
            :param scope: name of the scope
            :type scope: str
            :param password: password of the user
            :type password: str
            :rtype: dict
        """
        raise AuthNotImplemented()

    def delete_user(self, username, scope):
        """
            Overwrite this function to delete an existing user.

            :param username: name of the user
            :type username: str
            :param scope: name of the scope
            :type scope: str
            :rtype: dict
        """
        raise AuthNotImplemented()

    def update_user(self, username, scope, new_values):
        """
            Overwrite this function to update values of an existing user.

            :param username: name of the user
            :type username: str
            :param scope: name of the scope
            :type scope: str
            :param new_values: update this values
            :type new_values: dict
            :rtype: dict
        """
        raise AuthNotImplemented()

    def sync_users(self, scope):
        """
            Sync users from remote source e.g. LDAP
            Overwrite this function to sync users from a remote source.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
        """
        raise AuthNotImplemented()

    def get_group(self, groupname, scope, retrieve_attributes="*", **argv):
        """
            Overwrite this function to get info of a group by name and scope.

            :param groupname: name of the group
            :type groupname: str
            :param scope: name of the scope to search within
            :type scope: str
            :param retrieve_attributes: return this attributes in the dict
            :type retrieve_attributes: string or list of strings
            :rtype: dict
        """
        raise AuthNotImplemented()

    def list_groups(self, scope, retrieve_attributes=["name"], **argv):
        """
            Overwrite this function to return infos about all groups of this provider by scope.

            :param groupname: name of the group
            :type groupname: str
            :param scope: group of the scope to search within
            :type scope: str
            :param retrieve_attributes: return this attributes in the dict
            :type retrieve_attributes: string or list of strings
            :rtype: list of dicts
        """
        raise AuthNotImplemented()

    def create_group(self, groupname, scope, args=None):
        """
            Overwrite this function to create a new group.

            :param groupname: name of the group
            :type groupname: str
            :param scope: name of the scope
            :type scope: str
            :rtype: dict
        """
        raise AuthNotImplemented()

    def delete_group(self, groupname, scope):
        """
            Overwrite this function to delete an existing group.

            :param groupname: name of the group
            :type groupname: str
            :param scope: name of the scope
            :type scope: str
            :rtype: dict
        """
        raise AuthNotImplemented()

    def update_group(self, groupname, scope, new_values):
        """
            Overwrite this function to update values of an existing group.

            :param groupname: name of the group
            :type groupname: str
            :param scope: name of the scope
            :type scope: str
            :param new_values: update this values
            :type new_values: dict
            :rtype: dict
        """
        raise AuthNotImplemented()

    def sync_groups(self, scope):
        """
            Sync groups from remote source e.g. LDAP

            Overwrite this function to sync groups from a remote source.
            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
        """
        raise AuthNotImplemented()

    def _prepare_result(self, user, retrieve_attributes="*"):
        """
            Strips not needed value from the user dictionary.

            :param user: user info in a dict
            :type user: dict
            :param retrieve_attributes: return this attributes in the dict
            :type retrieve_attributes: string or list of strings
            :rtype: dict
        """
        if not retrieve_attributes or retrieve_attributes == "*":
            retrieve_attributes = user.keys()
            if 'name' not in retrieve_attributes:
                retrieve_attributes.append('name')
            if 'enabled' not in retrieve_attributes:
                retrieve_attributes.append('enabled')
        if 'password' in retrieve_attributes:
            retrieve_attributes.remove('password')
        result = {}
        for key in retrieve_attributes:
            result[key] = user.get(key, None)
        return result

    def _filter_match(self, result, **argv):
        """
            Matches the argv key, value pairs with the key, value pairs of a dict.

            :param result: dictionary with values which will be matched with argv values
            :type result: dict
            :rtype: bool
        """
        for k, v in argv.iteritems():
            if result.get(k) != v:
                return False
        return True

    def _filter_results(self, results, **argv):
        """
            Removes items from a list if they do not match.

            :param result: list of dictionary with values to filter
            :type result: list of dicts
            :rtype: list
        """
        if not argv:
            return results
        else:
            return [x for x in results if self._filter_match(x, **argv)]

class StorageAuthProvider(AuthProvider):

    user_storage = None
    group_storage = None
    conf = {}
    provider_groups = None
    provider_groupnames = None

    def __init__(self, **argv):
        """
        Init the user and group storages and read the selected user groups if a filter
        is set on the provider.
        """
        super(StorageAuthProvider, self).__init__( **argv)
        self.user_storage = YamlStorage(namespace="access.user", indexes=['name'])
        self.group_storage = YamlStorage(namespace="access.usergroup", indexes=['name'])
        self.conf = dict(
            local_user_groups=argv.get('local_user_groups', ''),
            local_select_groups=argv.get('local_select_groups', '')
        )
        # provider group names with prefix. needed to check if a group is in user_memberof
        self.provider_groups = set(self.conf.get('%s_user_groups' % self.id) or [])
        # provider group names without prefix. needed to fetch a group by name
        self.provider_groupnames = set([self._remove_name_prefix(g) for g in self.provider_groups])

    def _remove_name_prefix(self, string):
        """
        Remove prefixes from user or group names, so the name can be used to search
        e.g. by group name.
        Prefixes are used to filter users and groups by type. e.g. usergroup, ...
        """
        string = string.split(":")
        if len(string) == 1:
            return string[0]
        return ":".join(string[1:])

    def _filter_by_groups(self, users):
        """
        If this provider is configured to use one or more user groups,
        filter the list of users.
        """
        if not isinstance(users, (list, tuple)):
            users = [users]
        if not self.conf.get('local_select_groups', False):
            return users
        filtered_users = []
        for user in users:
            found = False
            for groupname in self.provider_groups:
                if groupname in [self._remove_name_prefix(x) for x
                                in (user.get("user_memberof") or [])]:
                    found = True
                    break
            if found:
                filtered_users.append(user)
        return filtered_users

    def _filter_results(self, results, **argv):
        """
        Apply default and group filters.
        """
        results = super(StorageAuthProvider, self)._filter_results(results, **argv)
        if not results:
            return results
        return self._filter_by_groups(results)

    def _filter_group_results(self, results, **argv):
        """
        If this provider is configured to use one or more user groups,
        filter the list of groups.
        """
        if not self.conf.get('local_select_groups', False):
            return results
        filtered_results = []
        for result in results:
            if result.get("name", "") in self.provider_groupnames:
                filtered_results.append(result)
        return filtered_results

    def _merge_user_options(self, user):
        """
        Return a dictionary with values for this user merged with values from its group(s).
        1. read service options of the user
            a. custom service options set -> go to 6.
            b. no custom service options set -> go to 2.
        2. read groups of the user
        3. read service options of groups
            a. no service options available for groups -> go to 4.
            b. user is part of one group -> go to 6.
            c. user is part of multiple groups -> go to 5.
        4. read service options from service configuration -> go to 6.
        5. merge service options of groups -> go to 6.
        6. use parsed service options
        """
        vpn_override = user.get('vpn_override_options', False)
        l2tp_override = user.get('l2tp_override_options', False)
        if vpn_override and l2tp_override:
            return user
        groups = user.get('user_memberof') or []
        for groupname in groups:
            groupname = self._remove_name_prefix(groupname)
            group = self.fetch_group(groupname)
            vpn_override = group.get('vpn_override_options', False)
            l2tp_override = group.get('l2tp_override_options', False)
            if not (vpn_override or l2tp_override):
                continue
            for key, value in group.iteritems():
                if key.startswith('vpn_'):
                    if not vpn_override:
                        continue
                    user[key] = merge_values(key, user.get(key), value)
                elif key.startswith('l2tp_'):
                    if not l2tp_override:
                        continue
                    user[key] = merge_values(key, user.get(key), value)
        return user

    def fetch_users(self, username=None, check_acl=False, merge_user_options=True, **argv):
        """
        Fetch all users or a user by name (username) and filter the list.
        """
        args = argv.copy()
        if username:
            args['name'] = username
        args['check_acl'] = check_acl
        query_result = self._filter_results(self.user_storage.select(**args), **argv) or []
        if not merge_user_options:
            return query_result
        else:
            # make sure the OpenVPN an L2TP options are merged
            return [self._merge_user_options(x) for x in query_result]

    def fetch_user(self, username=None, check_acl=False, merge_user_options=True, **argv):
        """
        Return a user by name.
        """
        query_result = self.fetch_users(username=username, check_acl=check_acl, merge_user_options=merge_user_options, **argv)
        return query_result and query_result[0] or None

    def create_user(self, username, scope, password=None, args={}):
        """
        Create a user in the storage, if not already existent.
        """
        provider_name = args.get('provider_name')
        if provider_name:
            user = self.fetch_user(username, check_acl=False, merge_user_options=False, provider_name=provider_name)
        else:
            user = self.fetch_user(username, check_acl=False, merge_user_options=False)

        if user is not None:
            raise AuthException("User '%s' already exist" % username)

        user = {}
        if args is not None:
            user.update(args)
        user.update({
            'name': username,
            'enabled': True
        })
        password_type = args.get('password_type', None)
        if password_type == 'no-password':
            user.update({
                'password': '',
                'password_type': 'no-password',
            })
        else:
            user.update({
                'password': sha512crypt(password),
                'password_type': 'sha512crypt',
            })
        self.user_storage.store(user, check_acl=False)
        self.sync_user(username)
        return user

    def delete_user(self, username, scope):
        """
        Delete a user from the storage.
        """
        user = self.fetch_user(username, check_acl=False, merge_user_options=False)
        if not user:
            logger.info("Cannot delete not existing user '%'" % username)
            raise UserNotFoundError()
        else:
            self.user_storage.delete(user['ID'], check_acl=False)
            self.sync_user(username)
        return user

    def update_user(self, username, scope, new_values):
        """
        Update user values (e.g. password) in the storage.
        """
        user = self.fetch_user(username, check_acl=False, merge_user_options=False)
        if not user:
            raise UserNotFoundError()

        # Update the values
        for attribute, value in new_values.iteritems():
            if not attribute:
                raise AuthException("Attribute '' not found")
            if attribute.upper() == 'ID':
                raise AuthException("Cannot set the id")
            # Encrypt the password (it it is not encrypted
            if attribute == 'password':
                if 'password_type' not in new_values or \
                        new_values.get('password_type') == 'plain' or \
                        new_values.get('password_type') == None:
                    user['password'] = sha512crypt(value)
                    user['password_type'] = 'sha512crypt'
                elif new_values.get('password_type') == 'no-password':
                    user['password'] = ''
                    user['password_type'] = 'no-password'
                else:
                    user['password'] = value
                    user['password_type'] = new_values['password_type']
            if attribute == 'password_type':
                pass
            user[attribute] = value

        self.user_storage.store(user, check_acl=False)
        self.sync_user(username)
        return user

    def sync_user(self, username):
        """
        Sync user user_memberof with the group users list.
        """
        pass

    def fetch_groups(self, groupname=None, check_acl=False, **argv):
        """
        Fetch all group or a group by name (username) and filter the list.
        """
        args = argv.copy()
        if groupname:
            args['name'] = groupname
        args['check_acl'] = check_acl
        return self._filter_group_results(self.group_storage.select(**args), **argv) or []

    def fetch_group(self, groupname=None, check_acl=False, **argv):
        """
        Return a group by name.
        """
        query_result = self.fetch_groups(groupname=groupname, check_acl=check_acl, **argv)
        return query_result and query_result[0] or None

    def create_group(self, groupname, scope, args={}):
        """
        Create a group in the storage, if not already existent.
        """
        provider_name = args.get('provider_name')
        if provider_name:
            group = self.fetch_group(groupname, check_acl=False, provider_name=provider_name)
        else:
            group = self.fetch_group(groupname, check_acl=False)

        if group is not None:
            raise AuthException("Group '%s' already exist" % groupname)

        group = {}
        if args is not None:
            group.update(args)
        group.update({
            'name': groupname,
            'enabled': True
        })
        self.group_storage.store(group, check_acl=False)
        self.sync_group(groupname)
        return group

    def delete_group(self, groupname, scope):
        """
        Delete a group from the storage.
        """
        group = self.fetch_group(groupname, check_acl=False)
        if not group:
            logger.info("Cannot delete not existing group '%'" % groupname)
            raise GroupNotFoundError()
        else:
            self.group_storage.delete(group['ID'], check_acl=False)
        return group

    def update_group(self, groupname, scope, new_values):
        """
        Update group values in the storage.
        """
        group = self.fetch_group(groupname, check_acl=False)
        if not group:
            raise GroupNotFoundError()

        # Update the values
        for attribute, value in new_values.iteritems():
            if not attribute:
                raise AuthException("Attribute '' not found")
            if attribute.upper() == 'ID':
                raise AuthException("Cannot set the id")
            group[attribute] = value

        self.group_storage.store(group, check_acl=False)
        return group

    def sync_group(self, groupname):
        """
        Sync group users with the users user_memberof list.
        """
        pass

