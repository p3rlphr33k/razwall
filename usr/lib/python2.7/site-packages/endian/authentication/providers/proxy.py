#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

from endian.core.i18n import _
from endian.emi.acl import AuthException
from endian.authentication.providers.commons import AuthProvider

__all__ = ['ProxyAuthProvider']

PROXY_AUTH_SEQUENCE = [
    "proxy_before_get_user",
    "proxy_get_user",
    "proxy_after_get_user",
    "proxy_check_local_password",
    "proxy_after_check_local_password",
    "proxy_check_remote_password",
    "proxy_after_check_remote_password",
]

class AttrDict(dict):

    def __init__(self, *args, **kwargs):
        super(AttrDict, self).__init__(*args, **kwargs)
        self.__dict__ = self

class ProxyAuthProvider(AuthProvider):

    id = "proxy"
    name = _("Split Data (User Information & Password)")
    can_authenticate = True
    can_get_user = True
    can_list_users = True
    enabled_for_vpn = True

    def __init__(self, eal, **argv):
        AuthProvider.__init__(self, **argv)
        self.eal = eal
        self._proxy_password_provider = argv.get('proxy_password_provider', '')
        self._proxy_user_provider = argv.get('proxy_user_provider', '')

    @property
    def proxy_password_provider(self):
        proxy_password_provider = self.eal.get_provider(self._proxy_password_provider)
        if proxy_password_provider == None:
            raise AuthException("Password provider %s not found" % self._proxy_password_provider)
        return proxy_password_provider

    @property
    def proxy_user_provider(self):
        proxy_user_provider = self.eal.get_provider(self._proxy_user_provider)
        if proxy_user_provider == None:
            raise AuthException("User provider %s not found" % self._proxy_user_provider)
        return proxy_user_provider

    def authenticate(self, username, password, scope, password_already_verified=False, called=None, **argv):
        if not called:
            called = set()
        elif self in called:
            raise AuthException("Recursive provider are not allowed")
        called.add(self)
        # Prepare the arguments
        auth_args = AttrDict({
            'username': username,
            'password': password,
            'scope': scope,
            'password_already_verified': password_already_verified,
            'called': called,
            'argv': argv,
            'user': None,
        })
        # Execute the steps
        for step in PROXY_AUTH_SEQUENCE:
            fn = getattr(self, step)
            fn(auth_args)
        return auth_args.user

    def get_user(self, username, scope, retrieve_attributes="*", **argv):
        return self.proxy_user_provider.get_user(username, scope, retrieve_attributes=retrieve_attributes, **argv)

    def list_users(self, scope, retrieve_attributes=["name"], **argv):
        return self.proxy_user_provider.list_users(scope, retrieve_attributes=retrieve_attributes, **argv)

    def proxy_before_get_user(self, auth_args):
        pass

    def proxy_get_user(self, auth_args):
        # Get user info
        auth_args.user = self.proxy_user_provider.authenticate(auth_args.username, auth_args.password, auth_args.scope, password_already_verified=True, called=auth_args.called, **auth_args.argv)
        if auth_args.user is not None and not auth_args.user.get('use_external_password_provider'):
            auth_args.user = self.proxy_user_provider.authenticate(auth_args.username, auth_args.password, auth_args.scope, password_already_verified=False, called=auth_args.called, **auth_args.argv)
            auth_args.password_already_verified = True

    def proxy_after_get_user(self, auth_args):
        pass

    def proxy_check_local_password(self, auth_args):
        pass

    def proxy_after_check_local_password(self, auth_args):
        pass

    def proxy_check_remote_password(self, auth_args):
        # Check the password
        if not auth_args.password_already_verified:
            self.proxy_password_provider.authenticate(auth_args.username, auth_args.password, auth_args.scope, called=auth_args.called, **auth_args.argv)

    def proxy_after_check_remote_password(self, auth_args):
        pass

