#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-10-21"

import sys
reload(sys)
sys.setdefaultencoding("utf-8")
import signal
import BaseHTTPServer
import simplejson
try:
    from urlparse import parse_qs
except ImportError:
    from cgi import parse_qs
from endian.data import DataSource
from endian.emi.acl import AuthException
from endian.core.daemon import Daemon, registerSignalHandler
from endian.core.procutils import set_process_name
from endian.core.logger import debug, info, warn, error
from endian.authentication.eal import EndianAuthenticationLayer
from endian.authentication.auth_client import DEFALT_SERVER_PORT

__all__ = ['main',
           'EalDaemon',
           'EalHandler']

HOST_NAME = 'localhost'
PORT_NUMBER = DEFALT_SERVER_PORT

class EalHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    def _to_json(self, d):
        try:
            return simplejson.dumps(d)
        except Exception, e:
            warn('exception caught parsing %s: %s', str(d), e)
        nd = {}
        for key, value in d.iteritems():
            try:
                simplejson.dumps({key: value})
                nd[key] = value
            except Exception, e:
                warn('excluded key: %s, value: %s', str(key), str(value))
                continue
        return simplejson.dumps(nd)

    def do_GET(self):
        """
        ... autofunction::: do_GET
            Respond to a GET request.
        """
        path = self.path
        if '?' in path:
            path, query = path.split('?', 1)
        else:
            path, query = path, ''

        # Convert path into action name
        action = path[1:]
        if action.endswith('/'):
            action = action[:-1]

        if action not in self.server.eal.ACTIONS:
            self.send_error(code=404, message="Not found")
            return

        # Parse the parameters
        raw_query_dict = parse_qs(query, keep_blank_values=1)
        parameters = {}
        for key, value in raw_query_dict.items():
            if key != 'self' and key != 'caller_id': # The caller_id parameter is ignored and displayed only in the log
                if len(value) <= 1:
                    parameters[key] = value[0]
                else:
                    parameters[key] = value

        # Get the action handler
        handler = self._resolv_handler(action)

        # Exec the action
        try:
            if handler == self.index:
                result = handler(**parameters)
                self.send_response(200)
                self.send_header("Content-type", "text/html")
            else:
                result = handler(**parameters)
                result = self._to_json(result)
                self.send_response(200)
                self.send_header("Content-type", "application/json")
            self.end_headers()
            if self.command != 'HEAD':
                self.wfile.write(result)
        except TypeError, ex:
            # Format the error for the missing arguments
            # e.g. "list_open_sessions() takes exactly 2 arguments (1 given)"
            message = hasattr(ex, 'message') and ex.message or str(ex)
            if message.startswith("%s()" % handler.__name__):
                import inspect
                inspect.getargspec(handler)[0]
                args = [x for x in inspect.getargspec(handler)[0] if x != 'self']
                message = "%s requires the following arguments: %s" % (
                                handler.__name__,
                                ",".join(args))
                self.send_error(code=500, message=message)
            else:
                error(str(ex), exc_info=True)
                self.send_error(code=500, ex=ex)
        except Exception, ex:
            if not isinstance(ex, AuthException):
                error(str(ex), exc_info=True)
            self.send_error(code=500, ex=ex)

    def index(self):
        """
        ... autofunction::: index
            Index page, return the list of the available actions
        """
        result = ["<!DOCTYPE html>\n" \
                  "<html xmlns=\"http://www.w3.org/1999/xhtml\">\n" \
                  "<head>\n" \
                  "<meta charset=\"utf-8\" />\n" \
                  "<title>EAL Available Commands</title>\n" \
                  "</head>\n" \
                  "<body>\n" \
                  "<table>" ]

        for action in sorted(self.server.eal.ACTIONS):
            if action:
                result.append("<tr><td><a href=\"%s\">%s</a></td><td><pre>%s</pre></td></tr>" % (
                                    action, action, self._resolv_handler(action).__doc__))

        result.append("</table>\n" \
                      "</body>\n" \
                      "</html>")
        return '\n'.join(result)
        #return dict([(x, self._resolv_handler(x).__doc__) for x in self.server.eal.ACTIONS if x])


    def send_error(self, code=500, message=None, ex=None):
        """
        ... autofunction::: send_error
            Send an error reply as json
        """
        self.send_response(code, message)
        self.send_header("Content-type", "application/json")
        self.send_header('Connection', 'close')
        self.end_headers()
        if self.command != 'HEAD' and code >= 200 and code not in (204, 304):
            content = {'code': code, 'message': message }
            if ex != None:
                content['exception'] = ex.__class__.__name__
                if message == None:
                    content['message'] = str(ex)
            self.wfile.write(simplejson.dumps(content))

    def log_request(self, code="-", size=None):
        debug('"%s" %s', self.requestline, str(code))

    def send_response(self, code, message=None):
        """
        ... autofunction::: send_response
            Send the response header and log the response code.
        """
        self.log_request(code)
        if message is None:
            if code in self.responses:
                message = self.responses[code][0]
            else:
                message = ''
        self.wfile.write("%s %d %s\r\n" % (self.protocol_version, code, message))

    def log_message(self, format, *args):
        info(format % args)

    def log_error(self, format, *args):
        error(format % args)

    def _resolv_handler(self, action):
        tmp = self.server.eal
        for action in action.split('/'):
            tmp = getattr(tmp, action, self.index)
        return tmp

class EalHTTPServer(BaseHTTPServer.HTTPServer):

    def __init__(self, server_address, RequestHandlerClass):
        BaseHTTPServer.HTTPServer.__init__(self, server_address, RequestHandlerClass)
        self.eal = EndianAuthenticationLayer()
        settings = DataSource().auth.settings
        if settings.get('CERTIFICATE_HASH_FUNCTION') != 'new':
            try:
                self.eal.ca.recreate_hash_symlinks()
            except Exception, ex:
                error(ex, exc_info=True)
            settings['CERTIFICATE_HASH_FUNCTION'] = 'new'
            settings.write()


class EalDaemon(Daemon):

    def __init__(self, name):
        set_process_name(name)
        Daemon.__init__(self, name=name)
        registerSignalHandler(signal.SIGTERM, self.shutdown)

    def do(self):
        info("Endian Authentication Layer startup")
        self.keep_running = True
        try:
            try:
                httpd = EalHTTPServer((HOST_NAME, PORT_NUMBER), EalHandler)
                try:
                    while self.keep_running:
                        httpd.handle_request()
                except KeyboardInterrupt:
                    pass
            except Exception, ex:
                error(ex, exc_info=True)
                raise ex
        finally:
            httpd.server_close()
            info("Endian Authentication Layer shutdown")

    def shutdown(self, *args, **kwds):
        self.keep_running = False

def main():
    a = EalDaemon("authentication")
    a.getOptionParserGroup()
    a.run()

if __name__ == '__main__':
    main()
