#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-10-21"

from endian.core.logger import create_logger
from endian.emi.storage.yamlstorage import YamlStorage
from endian.emi.acl import AuthException, UserNotFoundError, NotAuthorizedError, AuthNotImplemented
from endian.authentication.scopes import get_scopes_modules
from endian.authentication.providers.commons import PROVIDER_OPTIONS, GroupNotFoundError
from endian.authentication.handlers import get_handlers
from endian.authentication.utils import cache

__all__ = ['EndianAuthenticationLayer']

logger = create_logger(name="authentication")

class EndianAuthenticationLayer(object):

    ACTIONS = [
           '', # index
           'authenticate',
           'get_user',
           'list_users',
           'create_user',
           'delete_user',
           'update_user_value',
           'sync_users',
           'get_group',
           'list_groups',
           'create_group',
           'delete_group',
           'update_group_value',
           'sync_groups',
           'get_scope_names',
           'get_scope_title',
           'get_scopes',
           'get_providers',
           'get_provider_types',
           'get_provider_type',
           'reload_scopes_and_providers']

    # Authentication

    def authenticate(self, username, password, scope, cache_timeout=None, **argv):
        """
            Try to Authenticate an user, identified by an username,
            password and (optional) additional arguments on a scope.
            Raise 'AuthException' if the user authentication failed.
            Return a dictionary of user attributes in case of success.

            :param username: username
            :type username: string
            :param password: password
            :type password: string
            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :param cache_timeout: if great then 0, store the authentication result for 'cache_timeout' seconds. This value will be reused for future authentications
            :type cache_timeout: int (seconds)
            :type scope: string
        """
        try:
            cache_timeout = int(cache_timeout)
        except:
            cache_timeout = None
        # Get the providers
        last_exception = None
        providers = self.get_providers_by_scope(scope, default=None)
        if providers == None:
            logger.info("AUTH_STATUS(FAILED) SCOPE(%s) USER(%s) REASON(not found)" % (scope, username))
            raise AuthException("Invalid authentication scope (not found)")
        if not providers:
            logger.info("AUTH_STATUS(FAILED) SCOPE(%s) USER(%s) REASON(no provider found)" % (scope, username))
            raise AuthException("Invalid authentication scope (no provider found)")
        # Authenticate
        for provider in providers:
            try:
                # Check the cache
                result = cache.get(username, password, provider)
                if result is not None:
                    logger.info("AUTH_STATUS(ACCEPTED-CACHED) SCOPE(%s) USER(%s) PROVIDER(%s)" % (scope, username, provider.provider_name))
                    return result
                result = provider.authenticate(username, password, scope, **argv)
                # Store the result in the cache
                if cache_timeout is not None:
                    cache.set(username, password, provider, result, cache_timeout)
                logger.info("AUTH_STATUS(ACCEPTED) SCOPE(%s) USER(%s) PROVIDER(%s)" % (scope, username, provider.provider_name))
                return result
            except UserNotFoundError, ex:
                pass
            except AuthException, ex:
                last_exception = ex
        if not last_exception:
            last_exception = UserNotFoundError()
        logger.info("AUTH_STATUS(FAILED) SCOPE(%s) USER(%s) REASON(%s)" % (scope, username, str(last_exception)))
        raise last_exception

    # Account Management
    @classmethod
    def _convert_value_type(cls, value):
        if not isinstance(value, basestring):
            return value
        if value == "None" or value == "null":
            return None
        if value == "True" or value == "true":
            return True
        if value == "False" or value == "false":
            return False
        if '.' in value:
            try:
                return float(value)
            except:
                pass
        else:
            try:
                return int(value)
            except:
                pass
        return value

    ## User Management
    def get_user(self, username, scope, retrieve_attributes="*", **argv):
        """
            Get an user, identified by an username and a scope.
            Raise 'UserNotFoundError' if the user does not exist.
            Return a dictionary of user attributes in case of success.

            :param username: username
            :type username: string
            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
        """
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]
        providers = self.get_providers_by_scope(scope, default=None)
        if not providers:
            raise UserNotFoundError()
        retrieve_attributes_added = isinstance(retrieve_attributes, list) and 'disabled_scopes' not in retrieve_attributes
        if retrieve_attributes_added and not scope.startswith("provider:"):
            retrieve_attributes.append('disabled_scopes')
        for provider in providers:
            try:
                if not provider.can_get_user:
                    raise AuthNotImplemented("Provider does not support reading a user")
                result = provider.get_user(username, scope, retrieve_attributes, **argv)
                if not scope.startswith("provider:") and scope in (result.get("disabled_scopes") or []):
                    raise NotAuthorizedError("Scope disabled for this user")
                if retrieve_attributes_added and 'disabled_scopes' in result:
                    del result['disabled_scopes']
                return result
            except UserNotFoundError:
                pass
        raise UserNotFoundError()

    def list_users(self, scope, retrieve_attributes=["name"], **argv):
        """
            Get the list of all the users of a scope.
            For each user, is extracted a subset of the attributes,
            specified by the retrieve_attributes parameter
            This method depends on the ability of the providers to
            retrieve the user list
            (not all the kinds of providers are able to do this).
            The additional arguments are used to filter the users list.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
            :param retrieve_attributes: list of user attributes to be returned
            :type retrieve_attributes: list of string
            :return: a list of users with the selected attributes
            :rtype: list of dict
        """
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]

        argv = dict([(k, self._convert_value_type(v)) for k, v in argv.iteritems()])
        providers = self.get_providers_by_scope(scope, default=[])
        retrieve_attributes_added = isinstance(retrieve_attributes, list) and 'disabled_scopes' not in retrieve_attributes
        if retrieve_attributes_added and not scope.startswith("provider:"):
            retrieve_attributes.append('disabled_scopes')
        result = []
        if providers:
            for provider in providers:
                try:
                    if not provider.can_list_users:
                        raise AuthNotImplemented("Provider does not support listing users")
                    users = provider.list_users(scope, retrieve_attributes=retrieve_attributes, **argv)
                    if not scope.startswith("provider:"):
                        f_users = []
                        for user in users:
                            if scope not in (user.get("disabled_scopes") or []):
                                if retrieve_attributes_added and 'disabled_scopes' in user:
                                    del user['disabled_scopes']
                                f_users.append(user)
                        users = f_users
                    result.extend(users)
                except AuthException:
                    pass
        return result

    def update_user_value(self, username, scope, attribute, value):
        """
            Update an user attribute

            :param username: username
            :type username: string
            :param scope: scope
            :type scope: string
            :param attribute: the attribute to be updated
            :type attribute: string
            :param value: the attribute value
            :type value: value
            :return: Return a dictionary of user attributes in case of success.
            :rtype: dict
        """
        new_values = { attribute: self._convert_value_type(value) }
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_update_user:
                    raise AuthNotImplemented("Provider does not support updating user values")
                return provider.update_user(username, scope, new_values)
            except AuthNotImplemented:
                pass
            except UserNotFoundError:
                pass
        raise AuthException("Not updated")

    def create_user(self, username, scope, password=None):
        """
            Create a new user
            Raise 'AuthException' if it is impossibile to create the user.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
            :param username: username
            :type username: string
            :param password: password
            :type password: string
        """
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_create_user:
                    raise AuthNotImplemented("Provider does not support creating users")
                return provider.create_user(username, scope, password=password)
            except AuthNotImplemented:
                pass
            except UserNotFoundError:
                pass
        raise AuthException("Not created")

    def delete_user(self, username, scope):
        """
            Delete an user
            Raise 'AuthException' if it is impossibile to delete the user.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
            :param username: username
            :type username: string
        """
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_delete_user:
                    raise AuthNotImplemented("Provider does not support deleting users")
                return provider.delete_user(username, scope)
            except AuthNotImplemented:
                pass
            except UserNotFoundError:
                pass
        raise AuthException("Not deleted")

    def sync_users(self, scope):
        """
            Sync users from remote source e.g. LDAP
            Raise 'AuthException' if it is impossibile to sync the users.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
        """
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_sync_users:
                    raise AuthNotImplemented("Provider does not support syncing users")
                return provider.sync_users(scope)
            except AuthNotImplemented:
                pass
        raise AuthException("Not synced")

    ## Group Management
    def get_group(self, groupname, scope, retrieve_attributes="*", **argv):
        """
            Get a group, identified by a groupname and a scope.
            Raise 'GroupNotFoundError' if the group does not exist.
            Return a dictionary of group attributes in case of success.

            :param groupname: username
            :type groupname: string
            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
        """
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]
        providers = self.get_providers_by_scope(scope, default=None)
        if not providers:
            raise GroupNotFoundError()
        for provider in providers:
            try:
                if not provider.can_get_group:
                    raise AuthNotImplemented("Provider does not support reading a group")
                result = provider.get_group(groupname, scope, retrieve_attributes, **argv)
                return result
            except GroupNotFoundError:
                pass
        raise GroupNotFoundError()

    def list_groups(self, scope, retrieve_attributes=["name"], **argv):
        """
            Get the list of all the groups of a scope.
            For each group, is extracted a subset of the attributes,
            specified by the retrieve_attributes parameter
            This method depends on the ability of the providers to
            retrieve the group list
            (not all the kinds of providers are able to do this).
            The additional arguments are used to filter the groups list.

            :param scope: a scope group or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
            :param retrieve_attributes: list of group attributes to be returned
            :type retrieve_attributes: list of string
            :return: a list of groups with the selected attributes
            :rtype: list of dict
        """
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]

        argv = dict([(k, self._convert_value_type(v)) for k, v in argv.iteritems()])
        providers = self.get_providers_by_scope(scope, default=[])
        result = []
        if providers:
            for provider in providers:
                try:
                    if not provider.can_list_groups:
                        raise AuthNotImplemented("Provider does not support listing groups")
                    groups = provider.list_groups(scope, retrieve_attributes=retrieve_attributes, **argv)
                    if not scope.startswith("provider:"):
                        f_groups = []
                        for group in groups:
                            f_groups.append(group)
                        groups = f_groups
                    result.extend(groups)
                except AuthException:
                    pass
        return result

    def update_group_value(self, groupname, scope, attribute, value):
        """
            Update an group attribute

            :param groupname: groupname
            :type groupname: string
            :param scope: scope
            :type scope: string
            :param attribute: the attribute to be updated
            :type attribute: string
            :param value: the attribute value
            :type value: value
            :return: Return a dictionary of group attributes in case of success.
            :rtype: dict
        """
        new_values = { attribute: self._convert_value_type(value) }
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_update_group:
                    raise AuthNotImplemented("Provider does not support updating group values")
                return provider.update_group(groupname, scope, new_values)
            except AuthNotImplemented:
                pass
            except GroupNotFoundError:
                pass
        raise AuthException("Not updated")

    def create_group(self, groupname, scope):
        """
            Create a new group
            Raise 'AuthException' if it is impossibile to create the group.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
            :param username: groupname
            :type username: string
        """
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_create_group:
                    raise AuthNotImplemented("Provider does not support creating groups")
                return provider.create_group(groupname, scope)
            except AuthNotImplemented:
                pass
            except GroupNotFoundError:
                pass
        raise AuthException("Not created")

    def delete_group(self, groupname, scope):
        """
            Delete an group
            Raise 'AuthException' if it is impossibile to delete the group.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
            :param username: groupname
            :type username: string
        """
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_delete_group:
                    raise AuthNotImplemented("Provider does not support deleting groups")
                return provider.delete_grooup(groupname, scope)
            except AuthNotImplemented:
                pass
            except GroupNotFoundError:
                pass
        raise AuthException("Not deleted")

    def sync_groups(self, scope):
        """
            Sync groups from remote source e.g. LDAP
            Raise 'AuthException' if it is impossibile to sync the groups.

            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
        """
        providers = self.get_providers_by_scope(scope, default=[])
        for provider in providers:
            try:
                if not provider.can_sync_groups:
                    raise AuthNotImplemented("Provider does not support syncing groups")
                return provider.sync_groups(scope)
            except AuthNotImplemented:
                pass
        raise AuthException("Not synced")

    # Authentication Layer Configuration
    # Scope and providers

    def get_scope_names(self):
        """
            Return the list of all the defined authentication scopes
        """
        return self.scope_names.keys()

    def get_scope_title(self, name):
        """
            Return the name of a scope by name
        """
        try:
            return self.scope_names[name]["title"] or name
        except KeyError:
            return name

    def get_scope_module(self, name):
        """
            Return the scope module by name
        """
        try:
            return self.scope_names[name]["module"]
        except KeyError:
            return name

    def get_scopes(self):
        """
            Return the authentication scopes list
        """
        return self.scope_storage.select(check_acl=False)

    def register_scope_name(self, id, title=None, default_providers=None, module=None):
        """ Register a scope and create the default scope configuration and providers if missing """
        logger.debug("Register scope name %s" % id)
        if not title:
            title = id
        self.scope_names[id] = {
            'ID': id,
            'title': title,
            'default_providers': default_providers or [],
            'module': module,
        }
        # Create default scopes an providers if missing
        result = self.scope_storage.select(name=id, check_acl=False)
        scope = result and result[0] or None
        if scope == None:
            logger.info("Creating scope '%s'" % id)
            self.scope_storage.store({'name': id,
                'providers': default_providers or []})
            # Create the providers for the scope
            for provider in default_providers or []:
                result = self.provider_storage.select(name=provider, check_acl=False)
                result = result and result[0] or None
                if result == None and \
                        provider in self.provider_types:
                    logger.info("Creating provider '%s'" % provider)
                    self.provider_storage.store({'name': provider,
                        'provider_type': provider,
                        'enabled': True})

    def get_default_providers(self, id):
        try:
            return self.scope_names[id]['default_providers']
        except:
            return []

    def get_provider_types(self):
        """
            Return the list of all the providers types
        """
        return dict([(key, dict([(k,v) for k,v in value.iteritems() if k != 'provider_class'])) \
                      for key, value in self.provider_types.iteritems() if value is not None])

    def get_provider_type(self, id):
        """
            Return the a providers type based on the id
        """
        return dict([(k,v) for k,v in self.provider_types.get(id).iteritems() if k != 'provider_class'])

    def get_providers(self):
        """
            Return the authentication providers list
        """
        result = []
        for provider in self.provider_storage.select():
            provider = provider.copy()
            try:
                provider_type = self.provider_types[provider['provider_type']]
                for k in PROVIDER_OPTIONS:
                    provider[k] = provider_type[k]
            except:
                pass
            result.append(provider)
        return result

    def register_provider_type(self, provider_class):
        """
            Register a new type of provider (e.g. file, local db, radius)
        """
        provider = {
            'ID': provider_class.id,
            'name': provider_class.name,
            'provider_class': provider_class
        }
        for provider_option in PROVIDER_OPTIONS:
            provider[provider_option] = getattr(provider_class, provider_option)

        self.provider_types[provider_class.id] = provider

    def get_provider(self, name):
        """
            Return a provider by its name
        """
        return self.providers.get(name, None)

    def get_providers_by_scope(self, scope, default=[]):
        """
            Return a list of providers for a scope
            :param scope: a scope name or a string starting with the prefix 'provider:'
                          followed by the name of a provider
            :type scope: string
        """
        if scope and scope.startswith("provider:"):
            provider = self.get_provider(scope[9:])
            return provider and [provider] or default
        else:
            return self.scopes.get(scope, default)

    def get_provider_class(self, id):
        try:
            return self.provider_types[id]['provider_class']
        except:
            return None

    def load_providers(self):
        providers = {}
        for provider_config in self.provider_storage.select(check_acl=False):
            try:
                name = "missing name"
                name = provider_config['name']
                if provider_config['enabled']:
                    provider_type = provider_config['provider_type']
                    auth_provider_class = self.get_provider_class(provider_type)
                    if auth_provider_class == None:
                        raise Exception("Invalid provider type '%s' for provider '%s'" % (provider_type, name))
                    # Create an AuthProvider instance, passing the config options as constructor arguments
                    args = dict(provider_config)
                    args['eal'] = self
                    auth_provider = auth_provider_class(**args)
                    providers[name] = auth_provider
            except Exception, ex:
                logger.warn("Error initializing provider '%s': %s" % (name, str(ex)))
        self.providers = providers

    def reload_scopes_and_providers(self):
        """
            Reload the scopes and providers configuration
        """
        self._reload_scopes_and_providers()
        return { 'scopes': self.get_scopes(),
                 'providers': self.get_providers(),
                 'scope_names': self.get_scope_names(),
                 'provider_types': self.get_provider_types() }

    def _reload_scopes_and_providers(self):
        self.load_providers()
        scopes = {}
        # Load the scopes
        for scope in self.scope_storage.select(check_acl=False):
            scope_name = scope['name']
            scope_providers = []
            for provider_name in scope['providers']:
                provider = self.get_provider(provider_name)
                if not provider:
                    logger.warn("Missing provider '%s' for scope '%s'" % (provider_name, scope_name))
                else:
                    scope_providers.append(provider)
            scopes[scope_name] = scope_providers
        self.scopes = scopes

    def register_sub_handler(self, name, hander_class):
        logger.debug("Register command handler %s" % name)
        setattr(self, name, hander_class(self))
        for action in getattr(hander_class, "ACTIONS"):
            self.ACTIONS.append("%s/%s" % (name, action))

    def __init__(self):
        self.providers = {} # auth provider instances
        self.scopes = {} # map scope -> providers
        # Provider types:
        # Key = provider id (e.g. 'file')
        # Value = a dict with the following kets: 'ID', 'name', 'provider_class'
        self.provider_types = {}
        # Key = scope id (e.g. 'openvpn')
        # Value = a dict with the following kets: 'ID', 'default_providers'
        self.scope_names = {}

        self.provider_storage = YamlStorage(namespace="access.provider")
        self.scope_storage = YamlStorage(namespace="access.scope")

        # Register and load the provider types
        from endian.authentication.providers import get_providers_classes
        for provider_class in get_providers_classes():
            self.register_provider_type(provider_class)

        # Register the scopes (and create the default configuration/providers if missing)
        for scope_name, scope_module in get_scopes_modules().iteritems():
            self.register_scope_name(scope_module.name,
                title=getattr(scope_module, 'title'),
                default_providers=scope_module.default_providers,
                module=scope_module)

        # Load scopes and providers
        self._reload_scopes_and_providers()

        # Register the additional command handlers
        for name, handler_class in get_handlers().iteritems():
            self.register_sub_handler(name, handler_class)

