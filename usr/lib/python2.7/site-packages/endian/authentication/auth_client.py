#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-10-21"

# Client-side authentication api

# KEEP THIS FILE SMALLEST AS POSSIBILE
# DON'T IMPORT ANYTHING IF IT IS NOT STRICTLY INDISPENDABLE !!!
import sys
import urllib
import simplejson

__all__ = ['authenticate',
           'get_user',
           'list_users',
           'create_user',
           'delete_user',
           'update_user_value',
           'sync_users',
           'get_group',
           'list_groups',
           'create_group',
           'delete_group',
           'update_group_value',
           'sync_groups',
           'auth_client_cmd',
           'get_scopes',
           'get_scope_names',
           'get_scope_title',
           'get_providers',
           'get_provider_types',
           'get_provider_type',
           'reload_scopes_and_providers',
           'create_certificate',
           'create_certificate_authority',
           'revoke_certificate',
           'verify_certificate',
           'sign_certificate_request',
           'create_hash_symlink',
           'create_ca_hash_symlink',
           'open_session',
           'close_session',
           'list_open_sessions',
           'create_crl_hash_symlink',
           'generate_crl',
           'update_index',
           'recreate_hash_symlinks',
           'ClientAuthException']

DEFAULT_SERVER_HOST = "localhost"
DEFALT_SERVER_PORT = 3132
DEFAULT_METHOD = "GET"

class ClientAuthException(Exception):
    pass

def auth_client_cmd(cmd, args={}, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT):
    """
        Send a generic cmd to the authentication layer.
        Raise 'ClientAuthException' if case of error.
        :return: Return the result of the command execution.
        :rtype: a dict or a list
    """
    args_list = []
    for k, v in args.iteritems():
        if isinstance(v, list):
            if not v: # empty list
                args_list.append((k, ""))
            else:
                args_list.extend([(k, x or "") for x in v])
        else:
            args_list.append((k, v or ""))

    query = urllib.urlencode(args_list)
    try:
        if method == "GET": # use GET
            url = "http://%s:%s/%s/?%s" % (host, port, cmd, query)
            response = urllib.urlopen(url)
        elif method == "POST": # use POST
            url = "http://%s:%s/%s/" % (host, port, cmd)
            response = urllib.urlopen(url, query)
        else:
            raise ClientAuthException("ValueError: Invalid method (valid methods are GET and POST)")
        data = response.read()
        response.close()
    except IOError, ex:
        raise ClientAuthException("IOError: Error in communication with authentication server")
    if data.startswith('ERROR:'):
        raise ClientAuthException(data[6:].rstrip())
    try:
        data = simplejson.loads(data)
    except ValueError, ex:
        raise ClientAuthException("ValueError: %s" % str(ex))
    if 'code' in data and 'message' in data:
        exception = data.get('exception','Error')
        message = data.get('message','');
        raise ClientAuthException("%s: %s" % (exception, message))
    return data

def authenticate(username, password, scope, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, cache_timeout=None, **argv):
    """
        Try to Authenticate an user, identified by an username,
        password and a scope.
        Raise 'ClientAuthException' if the user authentication failed.

        :param username: username
        :type username: string
        :param password: password
        :type password: string
        :param scope: a scope name or a string starting with the prefix 'provider:'
                      followed by the name of a provider
        :type scope: string
        :param cache_timeout: if great then 0, store the authentication result for 'cache_timeout' seconds. This value will be reused for future authentications
        :type cache_timeout: int (seconds)
        :return: Return a dictionary of user attributes in case of success.
        :rtype: dict
    """
    args = {}
    args.update(argv)
    args['username'] = username
    args['password'] = password
    args['scope'] = scope
    if caller_id:
        args['caller_id'] = caller_id
    if cache_timeout is not None:
        args['cache_timeout'] = cache_timeout
    return auth_client_cmd("authenticate", args, method=method, host=host, port=port)

def get_user(username, scope, retrieve_attributes="*", method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, **argv):
    """
        Get an user, identified by an username and a scope.
        Raise 'ClientAuthException' if the user authentication failed.

        :param scope: scope
        :type scope: string
        :param retrieve_attributes: list of user attributes to be returned
        :type retrieve_attributes: list of strings
        :return: Return a dictionary of user attributes in case of success.
        :rtype: dict
    """
    args = {}
    args.update(argv)
    args['username'] = username
    args['scope'] = scope
    if caller_id:
        args['caller_id'] = caller_id
    if retrieve_attributes:
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]
        args['retrieve_attributes'] = retrieve_attributes
    return auth_client_cmd("get_user", args, method=method, host=host, port=port)

def list_users(scope, retrieve_attributes=['name'], method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, **argv):
    """
        Get the list of all the users of a scope.
        For each user, is extracted a subset of the attributes,
        specified by the retrieve_attributes parameter
        This method depends on the ability of the providers to
        retrieve the user list
        (not all the kinds of providers are able to do this).
        The additional arguments (argv) are used to filter the users list.

        :param scope: scope
        :type scope: string
        :param retrieve_attributes: list of user attributes to be returned
        :type retrieve_attributes: list of strings
        :return: a list of users with the selected attributes
        :rtype: list of dict
    """
    args = {}
    args.update(argv)
    args['scope'] = scope
    if caller_id:
        args['caller_id'] = caller_id
    if retrieve_attributes:
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]
        args['retrieve_attributes'] = retrieve_attributes
    return auth_client_cmd("list_users", args, method=method, host=host, port=port)

def update_user_value(username, scope, attribute, value, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Update an user attribute

        :param username: username
        :type username: string
        :param scope: scope
        :type scope: string
        :param attribute: the attribute to be updated
        :type attribute: string
        :param value: the attribute value
        :type value: value
        :return: Return a dictionary of user attributes in case of success.
        :rtype: dict
    """
    args = {'username' : username,
            'scope' :    scope,
            'attribute': attribute,
            'value' :    value}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("update_user_value", args, method=method, host=host, port=port)

def create_user(username, scope, password=None, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Update an user attribute

        :param username: username
        :type username: string
        :param scope: scope
        :type scope: string
        :param password: username
        :type password: string
        :return: Return a dictionary of user attributes in case of success.
        :rtype: dict
    """
    args = {'username' : username,
            'password' : password,
            'scope' :    scope}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("create_user", args, method=method, host=host, port=port)

def delete_user(username, scope, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Update an user attribute

        :param username: username
        :type username: string
        :param scope: scope
        :type scope: string
        :return: Return a dictionary of user attributes in case of success.
        :rtype: dict
    """
    args = {'username' : username,
            'scope' : scope}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("delete_user", args, method=method, host=host, port=port)

def sync_users(scope, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        sync users from remote source to make service options overwriteable

        :param scope: scope
        :type scope: string
        :return: Return a dict containing a list of available users, removed users and created users
        :rtype: dict
    """
    args = {'scope' : scope}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("sync_users", args, method=method, host=host, port=port)

def get_group(groupname, scope, retrieve_attributes="*", method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, **argv):
    """
        Get an group, identified by an groupname and a scope.
        Raise 'ClientAuthException' if the user authentication failed.

        :param scope: scope
        :type scope: string
        :param retrieve_attributes: list of user attributes to be returned
        :type retrieve_attributes: list of strings
        :return: Return a dictionary of user attributes in case of success.
        :rtype: dict
    """
    args = {}
    args.update(argv)
    args['groupname'] = groupname
    args['scope'] = scope
    if caller_id:
        args['caller_id'] = caller_id
    if retrieve_attributes:
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]
        args['retrieve_attributes'] = retrieve_attributes
    return auth_client_cmd("get_group", args, method=method, host=host, port=port)

def list_groups(scope, retrieve_attributes=['name'], method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, **argv):
    """
        Get the list of all the groups of a scope.
        For each group, is extracted a subset of the attributes,
        specified by the retrieve_attributes parameter
        This method depends on the ability of the providers to
        retrieve the group list
        (not all the kinds of providers are able to do this).
        The additional arguments (argv) are used to filter the groups list.

        :param scope: scope
        :type scope: string
        :param retrieve_attributes: list of group attributes to be returned
        :type retrieve_attributes: list of strings
        :return: a list of groups with the selected attributes
        :rtype: list of dict
    """
    args = {}
    args.update(argv)
    args['scope'] = scope
    if caller_id:
        args['caller_id'] = caller_id
    if retrieve_attributes:
        if isinstance(retrieve_attributes, basestring) and retrieve_attributes != "*":
            retrieve_attributes = [retrieve_attributes]
        args['retrieve_attributes'] = retrieve_attributes
    return auth_client_cmd("list_groups", args, method=method, host=host, port=port)

def update_group_value(groupname, scope, attribute, value, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Update an group attribute

        :param groupname: username
        :type groupname: string
        :param scope: scope
        :type scope: string
        :param attribute: the attribute to be updated
        :type attribute: string
        :param value: the attribute value
        :type value: value
        :return: Return a dictionary of group attributes in case of success.
        :rtype: dict
    """
    args = {'groupname' : groupname,
            'scope' :    scope,
            'attribute': attribute,
            'value' :    value}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("update_group_value", args, method=method, host=host, port=port)

def create_group(groupname, scope, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Update an user attribute

        :param username: groupname
        :type username: string
        :param scope: scope
        :type scope: string
        :return: Return a dictionary of group attributes in case of success.
        :rtype: dict
    """
    args = {'groupname' : groupname,
            'scope' :    scope}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("create_group", args, method=method, host=host, port=port)

def delete_group(groupname, scope, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Deleta a group by name

        :param groupname: groupname
        :type groupname: string
        :param scope: scope
        :type scope: string
        :return: Return a dictionary of group attributes in case of success.
        :rtype: dict
    """
    args = {'groupname' : groupname,
            'scope' : scope}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("delete_user", args, method=method, host=host, port=port)

def sync_groups(scope, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        sync groups from remote source to make service options overwriteable

        :param scope: scope
        :type scope: string
        :return: Return a dict containing a list of available groups, invalidated groups and created users
        :rtype: dict
    """
    args = {'scope' : scope}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("sync_groups", args, method=method, host=host, port=port)

def get_scope_names(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Return the list of all the defined authentication scopes
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("get_scope_names", args, method=method, host=host, port=port)

def get_scope_title(name, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Return the list of all the defined authentication scopes

        :param name: scope title by name, fallback to name if not present
        :type name: string
        :rtype: string
    """
    args = {
        "name": name
    }
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("get_scope_title", args, method=method, host=host, port=port)

def get_scopes(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Return the authentication scopes list
        :return: Return a list of scopes.
        :rtype: list of dict
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("get_scopes", args, method=method, host=host, port=port)

def get_providers(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Return the authentication providers list
        :return: Return a list of providers.
        :rtype: list of dict
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("get_providers", args, method=method, host=host, port=port)

def get_provider_types(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Return the list of all the providers types
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("get_provider_types", args, method=method, host=host, port=port)

def get_provider_type(id, method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Return the provider type by id

        :param id: provider id
        :type id: string
        :rtype: dict
    """
    args = {
        'id': id
    }
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("get_provider_type", args, method=method, host=host, port=port)

def reload_scopes_and_providers(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Reload the scopes and providers configuration
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("reload_scopes_and_providers", args, method=method, host=host, port=port)

def create_certificate(cert_name, cert_email="", cert_ou="", cert_organization="",
                       cert_city="", cert_state="", cert_country="", cert_subjectaltname="",
                       cert_password="", cert_days="", cert_filename="", cert_type="", cert_comment="",
                       cert_start_date="", cert_digest="",
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Create a new certificate

        :param cert_name: CN = CommonName
        :type cert_name: string
        :param cert_email: Email address
        :type cert_ou: string
        :param cert_organization: OU = Organization Unit typically certificate type
        :type cert_organization: string
        :param cert_city: L = Locality; generally - city
        :type cert_city: string
        :param cert_state: ST = state or province
        :type cert_state: string
        :param cert_country: C = ISO3166 two character country code
        :type cert_country: string
        :param cert_subjectaltname:
        :type cert_subjectaltname: string
        :param cert_password: certificate password
        :type cert_password: string
        :param cert_days: default certificate validity in days
        :type cert_days: string or int
        :param cert_filename: certificate file name (equals to cert_name if empty)
        :type cert_filename: string
        :param cert_type: optional certificate type (check CERT_TYPE_OPTIONS for valid options)
        :type cert_type: string
        :param cert_comment: optional comment
        :type cert_comment: string
        :param cert_start_date: optional certificate validity notBefore
        :type cert_start_date: string in YYMMDDHHMMSSZ format
        :param cert_digest: digest algorithm
        :type cert_digest: string
    """
    args = {'cert_name' :           cert_name,
            'cert_email' :          cert_email,
            'cert_ou':              cert_ou,
            'cert_organization':    cert_organization,
            'cert_city':            cert_city,
            'cert_state':           cert_state,
            'cert_country':         cert_country,
            'cert_subjectaltname':  cert_subjectaltname,
            'cert_password':        cert_password,
            'cert_days':            cert_days,
            'cert_filename':        cert_filename,
            'cert_type':            cert_type,
            'cert_comment':         cert_comment,
            'cert_start_date':      cert_start_date,
            'cert_digest':          cert_digest}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/create_certificate", args, method=method, host=host, port=port)

def sign_certificate_request(cert_name, cert_subjectaltname="", cert_password="", cert_days="",
                     cert_filename="", cert_type="", cert_start_date="",
                     revoke_old_certificate=False, cert_digest="",
                     method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Sign a certificate request

        :param cert_name: CN = CommonName
        :type cert_name: string
        :param cert_subjectaltname:
        :type cert_subjectaltname: string
        :param cert_password: certificate password
        :type cert_password: string
        :param cert_days: default certificate validity in days
        :type cert_days: string or int
        :param cert_filename: certificate file name (equals to cert_name if empty)
        :type cert_filename: string
        :param cert_type: optional certificate type (check CERT_TYPE_OPTIONS for valid options)
        :type cert_type: string
        :param cert_start_date: optional certificate validity notBefore
        :type cert_start_date: string in YYMMDDHHMMSSZ format
        :param revoke_old_certificate: revoke the old certificate if exist
        :type revoke_old_certificate: boolean
        :param cert_digest: digest algorithm
        :type cert_digest: string
    """
    args = {'cert_name' :           cert_name,
            'cert_subjectaltname':  cert_subjectaltname,
            'cert_password':        cert_password,
            'cert_days':            cert_days,
            'cert_filename':        cert_filename,
            'cert_type':            cert_type,
            'cert_start_date':      cert_start_date,
            'revoke_old_certificate': revoke_old_certificate,
            'cert_digest':          cert_digest}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/sign_certificate_request", args, method=method, host=host, port=port)

def create_certificate_authority(cert_name, cert_email="", cert_ou="", cert_organization="",
                       cert_city="", cert_state="", cert_country="", cert_subjectaltname="",
                       cert_days="", cert_filename="", cert_digest="",
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Create a new certificate

        :param cert_name: CN = CommonName
        :type cert_name: string
        :param cert_email: Email address
        :type cert_ou: string
        :param cert_organization: OU = Organization Unit typically certificate type
        :type cert_organization: string
        :param cert_city: L = Locality; generally - city
        :type cert_city: string
        :param cert_state: ST = state or province
        :type cert_state: string
        :param cert_country: C = ISO3166 two character country code
        :type cert_country: string
        :param cert_subjectaltname:
        :type cert_subjectaltname: string
        :param cert_days: default certificate validity in days
        :type cert_days: string or int
        :param cert_filename: certificate file name (equals to cert_name if empty)
        :type cert_filename: string
        :param cert_digest: digest algorithm
        :type cert_digest: string
    """
    args = {'cert_name' :           cert_name,
            'cert_email' :          cert_email,
            'cert_ou':              cert_ou,
            'cert_organization':    cert_organization,
            'cert_city':            cert_city,
            'cert_state':           cert_state,
            'cert_country':         cert_country,
            'cert_subjectaltname':  cert_subjectaltname,
            'cert_days':            cert_days,
            'cert_filename':        cert_filename,
            'cert_digest':          cert_digest}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/create_certificate_authority", args, method=method, host=host, port=port)

def revoke_certificate(cert_name,
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Revoke a certificate

        :param cert_name: Certificate name
        :type cert_name: string
    """
    args = {'cert_name' :           cert_name,}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/revoke_certificate", args, method=method, host=host, port=port)

def verify_certificate(cert_name,
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
        Verify a certificate

        :param cert_name: Certificate name
        :type cert_name: string
    """
    args = {'cert_name' :           cert_name,}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/verify_certificate", args, method=method, host=host, port=port)

def create_hash_symlink(cert_name,
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
            Create the certificate hash symlink used by openssl

            :param cert_name: Certificate name
            :type cert_name: string
    """
    args = {'cert_name' :           cert_name,}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/create_hash_symlink", args, method=method, host=host, port=port)

def create_ca_hash_symlink(cert_name,
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
            Create the CA certificate hash symlink used by openssl

            :param cert_name: CA Certificate name
            :type cert_name: string
    """
    args = {'cert_name' :           cert_name,}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/create_ca_hash_symlink", args, method=method, host=host, port=port)

def create_crl_hash_symlink(crl_name,
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
            Create the CRL hash symlink used by openssl

            :param crl_name: CA Certificate name
            :type crl_name: string
    """
    args = {'crl_name' :            crl_name,}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/create_crl_hash_symlink", args, method=method, host=host, port=port)

def generate_crl(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
            Generate/regenerate the CRL file
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/generate_crl", args, method=method, host=host, port=port)

def update_index(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
            Checks index.txt for expired certificates and mark them
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/update_index", args, method=method, host=host, port=port)

def recreate_hash_symlinks(method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None):
    """
           Recreate all the CAs, certificates, and CRLs hash symlinks
    """
    args = {}
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("ca/recreate_hash_symlinks", args, method=method, host=host, port=port)

def open_session(username, scope, local=None, remote=None, session_id=None,
                 method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, **argv):
    """
        Sets up a user session for a previously successful authenticated user.
        The session should later be terminated with a call to close_session.

        :param username: username
        :type username: string
        :param scope: a scope name
        :type scope: string
        :param local: optional local IP address
        :type local: string
        :param remote: optional remote IP addryess
        :type remote: string
        :param session_id: optional session id (default = username)
        :type session_id: string
    """
    args = {'scope' :               scope,
            'username':             username,
            'local':                local,
            'remote':               remote,
            'session_id':           session_id}
    args.update(argv)
    if caller_id:
        args['caller_id'] = caller_id
    args.update(argv)
    return auth_client_cmd("acct/open_session", args, method=method, host=host, port=port)

def close_session(username, scope, session_id=None,
                  method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, **argv):
    """
        This function is used to indicate that an authenticated session has ended.
        The session should have been created with a call to open_session.

        :param username: username
        :type username: string
        :param scope: a scope name
        :type scope: string
        :param session_id: optional session id (default = username)
        :type session_id: string
    """
    args = {'scope' :               scope,
            'username':             username,
            'session_id':           session_id}
    args.update(argv)
    if caller_id:
        args['caller_id'] = caller_id
    args.update(argv)
    return auth_client_cmd("acct/close_session", args, method=method, host=host, port=port)

def list_open_sessions(username="", scope="",
                       method=DEFAULT_METHOD, host=DEFAULT_SERVER_HOST, port=DEFALT_SERVER_PORT, caller_id=None, **argv):
    """
        List the open sessions.

        :param username: an optional username
        :type username: string
        :param scope: an optional scope scope name
        :type scope: string
    """
    args = {}
    args.update(argv)
    if username:
        args['username'] = username
    if scope:
        args['scope'] = scope
    if caller_id:
        args['caller_id'] = caller_id
    return auth_client_cmd("acct/list_open_sessions", args, method=method, host=host, port=port)

def main(argv=None):
    if argv is None:
        argv = sys.argv
    if len(argv) < 3:
        print 'usage: auth_client <SCOPE> <USERNAME> <PASSWORD> [SERVER PORT]'
        return 2
    try:
        print authenticate(scope=argv[1], username=argv[2], password=argv[3], port=len(argv) > 4 and argv[4] or DEFALT_SERVER_PORT)
        return 0
    except Exception, ex:
        print 'ERROR: %s' % str(ex)
        return 1

if __name__ == "__main__":
    sys.exit(main())
