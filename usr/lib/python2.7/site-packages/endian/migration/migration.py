#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2009-10-22"

"""
Migration Framework - Modular framework for doing
changes in filesystem or configuration when a
package has been upgraded from version A to 
version B.


"""

import endian.core.logger
import os
import stat
import endian.core.cache
import endian.data
from endian.core.treefilter import takeCached
import endian.core.modules
from glob import glob
from operator import itemgetter
import sys
try:
    import rpm
except ImportError:
    rpm = None

__all__ = ['migrate', 
           'variableRegistry', 
           'registerVariable',
           'mainHandler',
           'update'
           ]

MIGRATIONROOT = "migration"
DEFAULT_LOGGER = endian.core.logger.logger

epochExceptions = [
    'efw-smtpscan'
    ]

inexistent = {
    'version': '0',
    'release': '0',
    'epoch': '0',
    }

variableRegistry = {}
def registerVariable(k,v):
    variableRegistry[k] = v

def getCurrentRPMPackages(logger=DEFAULT_LOGGER):
    if rpm == None:
        logger.error("rpm module not found")
        return {}
        
    logger.debug("Load current packages from RPM database")
    pkg = {}
    ts = rpm.TransactionSet()
    mi = ts.dbMatch()
    for hdr in mi:
        epoch = hdr['epoch']
        if epoch is not None:
            epoch = str(epoch)
        pkg[hdr['name']] = {
            'version': str(hdr['version']),
            'release': str(hdr['release']),
            'epoch': epoch
            }
    ts.closeDB()
    return pkg

def rpmCmp((e1, v1, r1), (e2, v2, r2)):
    if 'ignore' in [e1, e2]:
        return rpm.labelCompare((None, v1, r1), (None, v2, r2))
    else:
        return rpm.labelCompare((e1, v1, r1), (e2, v2, r2))


class RPMPackageList(object):
    def __init__(self):
        self.data = {}
        self.timestamp = -1
        self.dscache = endian.core.cache.Cache()
        self.ds = endian.data.DataSource()
    def parse(self, logger=DEFAULT_LOGGER):
        i = 0
        if self.data == {}:
            logger.debug("Load backup.rpms list")
        else:
            logger.error("Refresh backup.rpms list, because it has expired")
        for line in self.ds.backup.rpms:
            token = line.split()
            l = len(token)
            if l <= 1:
                continue
            name = token[0]
            epoch = 'ignore'
            if name in epochExceptions:
                epoch = '0'
            if l > 3:
                epoch = token[3]
            if epoch in ['(none)', 'None']:
                epoch = None
            item = {
                'version': token[1],
                'release': token[2],
                'epoch': epoch,
                'line': i
                }
            self.data[name] = item
            i += 1

    def load(self, logger=DEFAULT_LOGGER):
        takeCached(self.ds, 'backup.rpms', self.dscache, None, lambda : self.parse(logger))

    def diff(self, to):
        self.load()
        ret = {}
        for (k,v) in to.iteritems():
            if k not in self.data:
                ret[k] = {
                    'new': to[k],
                    'old': inexistent,
                    }
                continue
            rpm = self.data[k]
            if (v['version'] == rpm['version'] and
                v['release'] == rpm['release'] and
                (v['epoch'] == None or
                 v['epoch'] != None and v['epoch'] == rpm['epoch'])):
                continue
            ret[k] = {'new': v, 
                      'old': rpm}
        return ret

    def set(self, package, epoch, version, release, logger=DEFAULT_LOGGER):
        self.load()
        container = takeCached(self.ds, 'backup.rpms', self.dscache)
        linedata = None
        if epoch != None:
            linedata = "%s %s %s %s" % (
                package, version, release, epoch)
        else:
            linedata = "%s %s %s" % (
                package, version, release)
        if package not in self.data:
            logger.debug("Append new package '%s' to rpms list", package)
            container.append(linedata)
        else:
            line = self.data[package]['line']
            container[line] = linedata
        container.write()
        logger.debug("Store package '%s' in rpms list with new version '%s'." % (
                package, getVersionString((epoch, version, release))))
        self.dscache.setDirty('backup.rpms')

    def update(self, data, logger=DEFAULT_LOGGER):
        self.load()
        container = takeCached(self.ds, 'backup.rpms', self.dscache)
        if container == None:
            raise Exception("No current packages list in '/var/efw/backup/rpms'."
                            " Create it before updating")
        container.data = []

        pkgs = data.keys()
        pkgs.sort()

        for p in pkgs:
            item = data[p]
            item['name'] = p
            line = ''
            if item['epoch'] != None:
                line = "%(name)s %(version)s %(release)s %(epoch)s" % item
            else:
                line = "%(name)s %(version)s %(release)s" % item

            container.append(line)
        container.write()
        logger.debug("Store updated packages list")


# defines static list of rpm's hold in last backup
# is cached and will automatically be updated when necessary
_backuplist = RPMPackageList()

def getModuleName(path):
    root = endian.core.modules.MODULES_ROOT.replace('.', '/')
    (module, ext) = os.path.splitext(path)
    ix = module.find("/%s/" % root)
    ix += 1
    module = module[ix:]
    module = module.replace('/', '.')
    return module

def getVersionData(item):
    return (item['epoch'], 
            item['version'], 
            item['release'])

def getVersionString(ver):
    if ver[0] == None:
        return "%s-%s" % (ver[1], ver[2])
    else:
        return "%s:%s-%s" % (ver[0], ver[1], ver[2])

def searchModules(s, logger=DEFAULT_LOGGER):
    modules = []
    root = endian.core.modules.module_registry.get_modules_path()
    search = "%s/*/%s/%s.py*" % (root, MIGRATIONROOT, s)
    logger.debug("Search for pending migration modules in %s" % search)
    for i in glob(search):
        mod = getModuleName(i)
        # modules may be exist multiple times:
        # as .py, pyc, pyo. process only once.
        if mod in modules:
            continue
        modules.append(mod)
        if os.path.basename(i).startswith('__'):
            continue
        yield (i, mod)

def pendingScripts(search, old=None, new=None, anyscripts=True, logger=DEFAULT_LOGGER):
    ret = []

    for (script, mod) in searchModules(search):
        tok = mod.split('__')
        tok = map(lambda x: x.replace('_', '.'), tok)

        # remove path and package name
        tok.pop(0)
        tok.pop(0)

        release = None
        version = None
        epoch = None

        # if those are not present, version is None and the script is never
        # running
        try:
            release = tok.pop()
            version = tok.pop()
        except IndexError:
            pass

        # epoch is optional, that's why we need to handle it separately
        try:
            epoch = tok.pop()
        except IndexError:
            pass

        verData = (epoch, version, release)
        if release == 'any':
            if not anyscripts:
                continue
            logger.debug("Found an *any* module (%s), to be applied always." % mod)
            ret.append((mod, old))
            continue

        # we need to call the script only if it is
        # between the old and new version
        if old and rpmCmp(verData, old) <= 0:
            logger.debug("Migration module %s older or equal than old status. Skipping." % mod)
            continue
        if new and rpmCmp(verData, new) > 0:
            logger.debug("Migration module %s newer than current status. Skipping." % mod)
            continue

        # needs migration
        ret.append((mod, verData))
    return ret


def iterateScripts(pkg=None, rpms=None, anyscripts=True, logger=DEFAULT_LOGGER):
    if rpms == None:
        rpms = getCurrentRPMPackages(logger=logger)
    diff = _backuplist.diff(rpms)

    logger.debug("%s packages upgraded." % len(diff))

    if pkg != None:
        # iterate only over one package
        if pkg not in diff:
            logger.debug("No pending migration modules for package '%s'." %pkg)
            return
        diff = {pkg: diff[pkg]}

    for (k,v) in diff.iteritems():
        logger.debug("Check for pending migration modules for package '%s'." %k)
        pypkg = k.replace('-', '_')
        scripts = pendingScripts("step__%s__*" % pypkg,
                                 getVersionData(v['old']), 
                                 getVersionData(v['new']),
                                 anyscripts)
        scripts.sort(cmp=rpmCmp, key=itemgetter(1))

        if not scripts:
            continue

        pre = pendingScripts("pre__%s*" % pypkg,
                             anyscripts=anyscripts)
        if len(pre) > 0:
            logger.debug("Found pre hook for package '%s'" % k)
            for i in pre:
                yield('pre', k, i)

        for sc in scripts:
            logger.debug("Found pending migration module '%s'" % sc[0])
            yield ('step', k, sc)

        post = pendingScripts("post__%s*" % pypkg,
                              anyscripts=anyscripts)
        if len(post) > 0:
            logger.debug("Found post hook for package '%s'" % k)
            for i in post:
                yield('post', k, i)

def migrate(pkg=None, epoch=None, version=None, release=None, logger=DEFAULT_LOGGER):
    """
    Searches all migration modules for package '''pkg''', and
    to the versioning supplied, if supplied, or all packages,
    if '''pkg''' is omitted.

    If a versioning is supplied at least '''version''' must be
    provided.

    Calls all migration modules of those versions between that 
    one of the last backup, (stored in /var/efw/backup/rpms) and
    the current status within the rpm db. 

    Migration modules are searched within  endian.*.migration.
    They need to be named as follows:

    <package-name>[__<epoch>]__<version>__<release>

    Any '.' and '-' need to be replaced with a '_'.

    Example:
    endian.qos.migration.efw_qos__1__1_0_0__0_endian0
    endian.qos.migration.efw_qos__2_2_10__0_endian0

    The modules will be called in the correct order of precedence
    according their version coded within the module name.

    If a module has errors, all following modules of the same
    package will be skipped.
    
    """

    skipPackage = ''
    callCount = 0
    moduleCount = 0
    ret = []
    rpms = None
    if pkg != None and version != None:
        epoch = str(epoch)
        if epoch == '%epoch' or epoch == '%{epoch}':
            epoch = '(none)'
        rpms = {
            pkg: {
                'epoch': epoch,
                'version' : str(version),
                'release' : str(release)
                }
            }
        logger.info("Migrate package '%s' to version '%s'" % (pkg, rpms[pkg]))

    for (flavour, package, (mod, ver)) in iterateScripts(pkg, rpms=rpms, logger=logger):
        moduleCount += 1
        if skipPackage == package:
            logger.warn("Skip pending migration module '%s' due to error "
                 "of a previous migration of the same package." % mod)
            ret.append("%s: SKIP" %mod)
            continue
        cb = None
        try:
            logger.info("Call pending migration module '%s'." % mod)
            if mod in sys.modules:
                del sys.modules[mod]
            basemod = mod.split(".")[0]
            obj = __import__(mod, globals(), locals(), [basemod])
            cb = getattr(obj, "main")
        except Exception, e:
            if isinstance(e, AttributeError):
                logger.error("Could not load pending migration module '%s' "
                      "because main() is not implemented. "
                      "Skip the following of this package." % mod)
            else:
                logger.error("Could not load pending migration module '%s'. "
                      "Skip the following of this package." % mod)
            logger.debug("Traceback: ", exc_info=True)
            skipPackage = package
            ret.append("%s: FAILED LOADING" %mod)
            continue

        # actually call the migration routine
        try:
            cb()
        except Exception, e:
            skipPackage = package
            logger.error("Error in migration module '%s'. Skip migration "
                  "for package '%s'" % (mod, package), exc_info=True)
            ret.append("%s: FAILED (%s)" % (mod, e))
            continue

        callCount += 1
        ret.append("%s: OK" %mod)
        if flavour == 'step':
            logger.info("Set current configuration version of '%s' to '%s'" % (
                    package, getVersionString(ver)))
            _backuplist.set(package, logger=logger, *ver)

    if moduleCount > 0:
        if callCount != moduleCount:
            logger.warn("%s migration modules of %s processed successfully." %(
                    callCount, moduleCount))
        else:
            logger.info("All %s migration modules processed successfully." % callCount)

    ret.append("---")
    ret.append("Found: %s" % moduleCount)
    ret.append("OK: %s" % callCount)

    logger.debug("Update rpm list")
    update(logger)

    return "\n".join(ret)


def update(logger=DEFAULT_LOGGER):
    """
    Updates list of the version of current configuration files

    The list of teh version of current configuration files is
    basically a list of rpm package names with their version, 
    release and epoch. In order to allow to understand which
    configuration file must be migrated this list should reflect
    always the versions the corresponding settings files have at
    the moment.

    This function should be called before upgrades, in order to
    understand which packages need migration during upgrade process.

    """
    needmigration = []
    rpms = getCurrentRPMPackages(logger=logger)
    for (flavour, package, (mod, ver)) in iterateScripts(rpms=rpms, anyscripts=False, logger=logger):
        if flavour != 'step':
            continue
        if package in needmigration:
            continue
        needmigration.append(package)

    logger.debug("Packages '%s' still need migration. Don't update their "
          "versions in packages list." % needmigration)

    count = 0
    newdata = {}
    for (k,v) in rpms.iteritems():
        if k in needmigration:
            newdata[k] = _backuplist.data[k]
        else:
            newdata[k] = {
                'version': v['version'],
                'release': v['release'],
                'epoch': v.get('epoch', '(none)')
            }
            count += 1

    _backuplist.update(newdata, logger=logger)
    logger.info("Packages list updated")

    ret = {
        'updatedCount': count,
        'needmigrationCount': len(needmigration),
        'needmigration': needmigration,
        }
    return ret

def opthandler(cb):
    from optparse import OptionParser
    usage = "usage: %prog <options>"
    parser = OptionParser(usage)

    parser.add_option("-d", "--debug", dest="debug", action="store_true",
                      help="Increase debug level", default=False)

    # Add the following options only for main
    if cb == main:
        parser.add_option("--pkg", dest="pkg",
                      help="Call all migration modules of that pakage", metavar="PKG")
        parser.add_option("--epoch", dest="epoch",
                      help="Migrate to provided epoch", metavar="EPOCH")
        parser.add_option("--version", dest="version",
                      help="Migrate to provided version", metavar="VERSION")
        parser.add_option("--release", dest="release",
                      help="Migrate to provided release", metavar="RELEASE")

    (options, args) = parser.parse_args()

    return (options, args)

def mainHandler(cb):
    (o, a) = opthandler(cb)
    if o.debug:
        endian.core.logger.logger.setLevel(endian.core.logger.logging.DEBUG)
    if cb == main:
        cb(pkg=o.pkg, epoch=o.epoch, version=o.version, release=o.release)
    else:
        cb()

def main(pkg=None, epoch=None, version=None, release=None):
    print migrate(pkg, epoch, version, release)

if __name__ == '__main__':
    mainHandler(main)
