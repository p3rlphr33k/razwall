#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2012 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import sys
from formencode.api import _
from formencode.validators import (Bool, ConfirmType, Constant,
           DateConverter, DateValidator, DictConverter, Email,
           Empty, FancyValidator, FieldStorageUploadConverter,
           FieldsMatch, FileUploadKeeper, FormValidator,
           IndexListConverter, Int,
           MaxLength,
           MinLength, NotEmpty,
           Number, OneOf, OpenId, PlainText, RangeValidator,
           Regex, RequireIfMissing, RequireIfPresent, Set,
           SignedString, String, StringBool, StringBoolean, StripField,
           TimeConverter, URL, UnicodeString, Validator, Wrapper,
           XRI, CIDR, IPAddress)
from formencode.foreach import ForEach
from formencode.api import Invalid, NoDefault
from formencode.schema import Schema

__all__ = ['Bool', 'ConfirmType', 'Constant',
           'DateConverter', 'DateValidator', 'DictConverter', 'Email',
           'Empty', 'FancyValidator', 'FieldStorageUploadConverter',
           'FieldsMatch', 'FileUploadKeeper', 'ForEach', 'FormValidator',
           'IndexListConverter', 'Int', 'Invalid',
           'MaxLength', 'Multiline', 'Multichoice',
           'MinLength', 'NoDefault', 'NotEmpty',
           'Number', 'OneOf', 'OpenId', 'Percentage', 'PlainText', 'RangeValidator',
           'Relation', 'Regex', 'RequireIfMissing', 'RequireIfPresent', 'Schema', 'Set',
           'SignedString', 'String', 'StringBool', 'StringBoolean', 'StripField',
           'TimeConverter', 'URL', 'UnicodeString', 'Validator', 'Wrapper',
           'XRI', 'ObjectId', 'CIDR', 'IPAddress']

def empty_value(self, value):
    # fancy validator now return empty string when no value given
    # before None was written into datasource
    return ""

FancyValidator.empty_value = empty_value

class UnicodeString(UnicodeString):
    """
       The FormEncode UnicodeString validator encodes strings as utf-8
       for display. However, this is not desired behaviour in tw.forms,
       as Genshi will fail when it receives such strings.
       Instead, this validator renders Python unicode objects where
       possible, strings otherwise.
    """
    def _from_python(self, value, state):
        if isinstance(value, basestring):
            return value
        elif hasattr(value, '__unicode__'):
            return unicode(value)
        else:
            return str(value)

class Multiline(ForEach):
    required = False

    def _to_python(self, value, state=None):
        if type(value) != list:
            value = value.replace("\r\n", "\n")
            value = value.strip().split("\n")
        value = ForEach._to_python(self, value, state)
        if self.required and (not value or not value[0]):
            raise Invalid(_("Please enter a value"), value, state)
        return value

    def empty_value(self, value):
        if self.required:
            try:
                caller = sys._getframe(1).f_code.co_name
                if caller != "to_python":
                    return
            except:
                pass
            raise Invalid(_("Please enter a value"), value, None)
        return ForEach.empty_value(self, value)

class Multichoice(ForEach):
    pass

class Percentage(FancyValidator):
    messages = {
        'invalid' : _("Invalid percentage value")
    }

    def _to_python(self, value, state):
        value = str(value)
        if not value.endswith("%"):
            raise Invalid(self.message('invalid', state), value, state)
        try:
            int(value[:-1])
        except:
            raise Invalid(self.message('invalid', state), value, state)
        return value

class Relation(OneOf):
    """
    Checks if the item is inside a list of values and if "values" is callable
    it does a lazy call to lookup the values.
    """

    lookup = None
    # if the list of items is a list of dicts use this key to extract the values
    key = None

    def validate_python(self, value, state):
        if hasattr(self.list, "loadAll"):
            self.lookup = self.list.loadAll
        if hasattr(self.list, "load"):
            self.lookup = self.list.load
        if callable(self.list) and not self.lookup:
            self.lookup = self.list
        if self.lookup:
            self.list = self.lookup()
        if type(self.list) != list:
            raise Invalid("Invalid Reference list:" % self.list)
        if self.key:
            self.list = map(lambda i: i.get(self.key), self.list)
        return OneOf.validate_python(self, value, state)

class ObjectId(FancyValidator):
    """
    Converts a string to a MongoDB ObjectId
    """

    def _to_python(self, value, state):
        from bson.objectid import ObjectId
        return ObjectId(value)

    def _from_python(self, value, state):
        return str(value)

