#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import socket
import re
from formencode.validators import MACAddress, Int, FancyValidator, Invalid, URL
from formencode.api import _
from endian.datatypes import network

__all__ = ['MACAddress',
           'Port',
           'PortRange',
           'MultiPortRange',
           'CIDR',
           'IPAddress',
           'NetworkAddress',
           'NetworkIPS',
           'NetworkMultiIPS',
           'Hostname',
           'HostnameOrIPAddress',
           'HostnameRegex',
           'DomainNameRegex',
           'SubdomainNameRegex',
           'URLDomainOrIP',
           'URLDomainOrHostnameOrIP',
           'URLPath',
           'URLAbsolutePath',
           'HostPort',
           'BindableIPAddress',
          ]

# Always add colons to MACAddress field
MACAddress.add_colons = True

class Port(Int):
    messages = {
        'integer': _("Invalid port number"),
        'tooLow': _("Port number must be bigger than 0"),
        'tooHigh': _("Port number must be smaller than 65536"),
    }

    min = 0
    max = 65536

class PortRange(Port):
    """
        Validator to check a port range, e.g. 80:85

        Options:
        * not_empty: If true, then if an empty value is given raise an error.
        * separator: Separator character, default ':'
        * accept_single_port: If true, then accept both port range or single port
    """
    messages = {
        'range': _("Invalid port range"),
        'invalid': _("Start port must be smaller then end port"),
    }
    not_empty = False
    separator = ':'
    accept_single_port = False

    def validate_python(self, value, state):
        super(PortRange, self).validate_python(self.start, state)
        super(PortRange, self).validate_python(self.end, state)
        if self.accept_single_port:
            if self.start > self.end:
                raise Invalid(self.message('invalid', state), value, state)
        else:
            if self.start >= self.end:
                raise Invalid(self.message('invalid', state), value, state)

    def _to_python(self, value, state=None):
        if value:
            value = value.strip()
        values = value.split(self.separator)
        if len(values) == 1 and self.accept_single_port:
            self.start = super(PortRange, self)._to_python(values[0], state)
            self.end = self.start
            return str(self.start)
        if len(values) != 2:
            raise Invalid(self.message('range', state), value, state)
        self.start = super(PortRange, self)._to_python(values[0], state)
        self.end = super(PortRange, self)._to_python(values[1], state)
        value = "%s%s%s" % (self.start, self.separator, self.end)
        return value


class MultiPortRange(FancyValidator):
    """
        Validator to check multiple ports/port ranges, e.g. 80:85, 90, 91

        Options:
        * not_empty: If true, then if an empty value is given raise an error.
        * range_separator: Range separator character, default ':'
        * separator: Separator character, default ','
    """
    range_separator = ':'
    separator = ','

    def _to_python(self, value, state):
        if value:
            result = []
            port_validator = Port()
            port_range_validator = PortRange(separator=self.range_separator)
            for item in value.strip().split(self.separator):
                item = item.strip()
                if self.range_separator in item:
                    item = port_range_validator.to_python(item)
                else:
                    item = str(port_validator.to_python(item))
                result.append(item)
            value = self.separator.join(result)
        return value


class IPAddress(FancyValidator):
    """
        Validator to check whether a string is a correct IP address
    """

    use_datatype = False

    messages = {
        'bad_format': _('Please enter a valid IP address (a.b.c.d)')
    }

    def _to_python(self, value, state):
        try:
            value = network.IPAddress(value)
        except:
            raise Invalid(self.message("bad_format", state), value, state)
        if self.use_datatype:
            return value
        else:
            return str(value).split("/")[0]

    def _from_python(self, value, state):
        return str(value).split("/")[0]


class CIDR(FancyValidator):
    """
        Validator to check whether a string is in correct CIDR
        notation  (IP address, or IP address plus /mask)
    """

    use_datatype = False

    messages = {
        'bad_format': _('Please enter a valid IP address (a.b.c.d) or IP network (a.b.c.d/e)'),
    }

    def _to_python(self, value, state):
        try:
            if '/' in value:
                value = network.CIDR(value)
            else:
                value = network.IPAddress(value)
        except:
            raise Invalid(self.message("bad_format", state), value, state)
        if self.use_datatype:
            return value
        else:
            return str(value)

    def _from_python(self, value, state):
        return str(value)


class NetworkAddress(FancyValidator):
    """
        Validator to check whether a string is in correct CIDR
        notation IP address/mask
        Netmask is mandatory - i.e. IP address without netmask is not valid
    """

    use_datatype = False

    messages = {
        'bad_format': _('Please enter a valid IP network (a.b.c.d/e)'),
    }

    def _to_python(self, value, state):
        try:
            value = network.CIDR(value)
        except:
            raise Invalid(self.message("bad_format", state), value, state)
        if self.use_datatype:
            return value
        else:
            return str(value)

    def _from_python(self, value, state):
        return str(value)


class NetworkIPS(FancyValidator):
    """
    Controlls:
    * if the ip is the same as the network address.
    * if the ip is the same as the network broadcast address.
    * if the network contains just one ip.
    If so shows an error.
    """

    use_datatype = False

    messages = {
        'bad_format': _('Please enter a valid IP address (a.b.c.d) or IP network (a.b.c.d/e)'),
        'ip_same_as_network': _("The address is the same as its network address, which is not allowed!"),
        'ip_same_as_broadcast': _("The address is the same as its broadcast address, which is not allowed!"),
        'only_one_ip': _("The network mask addresses less than 4 IP address, which will lock you out if applied. Choose another one!"),
    }

    def _to_python(self, value, state):
        try:
            if '/' in value:
                value = network.CIDR(value)
            else:
                value = network.IPAddress(value)
        except:
            raise Invalid(self.message("bad_format", state), value, state)
        # Bits (netmask) correct?
        bits = int(value.bits)
        if int(bits) > 30:
            raise Invalid(self.message('only_one_ip', state), value, state)
        if value.address == value.netaddress:
            raise Invalid(self.message('ip_same_as_network', state), value, state)
        if value.address == value.broadcast:
            raise Invalid(self.message('ip_same_as_broadcast', state), value, state)
        if self.use_datatype:
            return value
        else:
            return str(value)

    def _from_python(self, value, state):
        return str(value)


class NetworkMultiIPS(FancyValidator):
    """
    Controlls for comma seperated ips:
    * if the ip is the same as the network address.
    * if the ip is the same as the network broadcast address.
    * if the network contains just one ip.
    If so shows an error.
    """

    use_datatype = False

    messages = {
        'ip_same_as_network': _("One address is the same as its network address, which is not allowed!"),
        'ip_same_as_broadcast': _("One address is the same as its broadcast address, which is not allowed!"),
        'only_one_ip': _("One network mask addresses less than 4 IP address, which will lock you out if applied. Choose another one!"),
        'intersect': _("The networks do intersect, which is not allowed!"),
    }

    def _to_python(self, value, state):
        if not value:
            return value

        values = [x.strip() for x in value.split(",")]
        cidrs = []
        for _value in values:
            try:
                cidrs.append(network.CIDR(_value))
            except (ValueError, AttributeError):
                raise Invalid(self.message("bad_format", state), _value, state)

        for cidr in cidrs:
            if int(cidr.bits) > 30:
                raise Invalid(self.message('only_one_ip', state), _value, state)
            if cidr.address == cidr.netaddress:
                raise Invalid(self.message('ip_same_as_network', state), _value, state)
            if cidr.address == cidr.broadcast:
                raise Invalid(self.message('ip_same_as_broadcast', state), _value, state)

        error = False
        for i, cidri in enumerate(cidrs):
            for j, cidrj in enumerate(cidrs):
                if i == j:
                    continue
                if cidri in cidrj:
                    error = True
                break
            break

        if error:
            raise Invalid(self.message('intersect', state), _value, state)
        if self.use_datatype:
            return cidrs
        else:
            return ",".join([str(x) for x in cidrs])

    def _from_python(self, value, state):
        if (isinstance(value, list)):
            return ",".join([str(x) for x in value])
        else:
            return str(value)


class Hostname(FancyValidator):
    """
        Validator to check whether a string is a resolvable domain name
    """

    messages = {
        'bad_format': _('Please enter a valid domain name')
    }

    def _to_python(self, value, state):
        try:
            value = value.strip()
            try:
                network.IPAddress(value)
                is_ip_address = True
            except:
                is_ip_address = False
            if is_ip_address:
                raise Exception()
            socket.gethostbyname(value)
            return value
        except:
            raise Invalid(self.message("bad_format", state), value, state)


class HostnameOrIPAddress(FancyValidator):
    """
        Validator to check whether a string is a correct IP address or a resolvable domain name
    """

    messages = {
        'bad_format': _('Please enter a valid IP address (a.b.c.d) or domain name')
    }

    def _to_python(self, value, state):
        try:
            value = value.strip()
            socket.gethostbyname(value)
            return value
        except:
            raise Invalid(self.message("bad_format", state), value, state)

allowed = re.compile("(?!-)[A-Z\d-]{1,63}(?<!-)$", re.IGNORECASE)

class HostnameRegex(FancyValidator):
    """
        Validator to check whether a string is a valid hostname
    """

    messages = {
        'bad_format': _('Please enter a valid hostname')
    }

    def _to_python(self, value, state):
        if allowed.match(value):
            return value
        raise Invalid(self.message("bad_format", state), value, state)


class DomainNameRegex(FancyValidator):
    """
        Validator to check whether a string is a valid domain name
    """

    require_fqdn = True

    messages = {
        'bad_format': _('Please enter a valid domain name')
    }

    def _to_python(self, value, state):

        if value[-1] == ".":
            value = value[:-1] # strip exactly one dot from the right, if present

        if self.require_fqdn:
            min_domains = 2
        else:
            min_domains = 1
        if len(value.split(".")) >= min_domains:
            for x in value.split("."):
                if not allowed.match(x):
                    raise Invalid(self.message("bad_format", state), value, state)
        else:
            raise Invalid(self.message("bad_format", state), value, state)
        return value

class SubdomainNameRegex(FancyValidator):
    """
        Validator to check whether a string is a valid domain name that allows subdomains
    """

    messages = {
        'bad_format': _('Please enter a valid domain name')
    }

    def _to_python(self, value, state):

        if value[-1] == '.':
            value = value[:-1]

        copy = value

        if len(copy.split(".")) > 1:
            if copy.split(".")[0] == '':
                copy = copy[1:]
            for x in copy.split("."):
                if not allowed.match(x):
                    raise Invalid(self.message("bad_format", state), value, state)
        else:
            raise Invalid(self.message("bad_format", state), value, state)

        return value

class URLDomainOrIP(URL):
    """
        Validator to check whether a string is a valid URL based on domains or IP address.
    """
    require_tld = False

    url_re = re.compile(r'''
        ^(http|https)://
        (?:[%:\w]*@)?                              # authenticator
        (?:(?P<domain>[a-z0-9][a-z0-9\-]{1,62}\.)*   # (sub)domain - alpha followed by 62max chars (63 total)
        (?P<tld>[a-z]{2,})|[0-9]+(?:\.[0-9]+){3})  # TLD
        (?::[0-9]+)?                               # port

        # files/delims/etc
        (?P<path>/[a-z0-9\-\._~:/\?#\[\]@!%\$&\'\(\)\*\+,;=]*)?
        $
    ''', re.I | re.VERBOSE)


class URLDomainOrHostnameOrIP(URL):
    """
        Validator to check whether a string is a valid URL based on domains, hostname or IP address.
    """
    require_tld = False

    url_re = re.compile(r'''
        ^(http|https)://
        (?:[%:\w]*@)?                              # authenticator
        (?:(?P<domain>[a-z0-9][a-z0-9\-]{1,62}\.)*   # (sub)domain - alpha followed by 62max chars (63 total)
        (?P<tld>(?!-)[a-z\d-]{1,63}(?<!-)|[a-z]{2,})|[0-9]+(?:\.[0-9]+){3})  # TLD or hostname
        (?::[0-9]+)?                               # port

        # files/delims/etc
        (?P<path>/[a-z0-9\-\._~:/\?#\[\]@!%\$&\'\(\)\*\+,;=]*)?
        $
    ''', re.I | re.VERBOSE)


class URLPath(FancyValidator):
    """
        Validator to check whether a string is a valid path for an URL
    """

    messages = {
        'bad_format': _('Please enter a valid path')
    }

    re_path = re.compile(r"^[a-z0-9\-\._~:/\?#\[\]@!%\$&\'\(\)\*\+,;=]*$",
            re.I | re.VERBOSE)

    def _to_python(self, value, state):

        if not self.re_path.match(value):
            raise Invalid(self.message("bad_format", state), value, state)
        return value


class URLAbsolutePath(URLPath):
    """
        Validator to check whether a string is a valid absolute path for an URL
    """

    messages = {
        'bad_format': _('Please enter a valid absolute path')
    }

    re_path = re.compile(r"^/[a-z0-9\-\._~:/\?#\[\]@!%\$&\'\(\)\*\+,;=]*$",
            re.I | re.VERBOSE)


class HostPort(FancyValidator):
    """
        Validator to check whether a string is a valid hostname/ip[:port]

        Options:
        * not_empty: If true, then if an empty value is given raise an error.
        * require_port: If true, then if port is missing raise an error.
    """

    require_port = False

    messages = {
        'bad_format': _('Please enter a valid hostname/IP address and port number'),
        'require_port': _('Missing port number')
    }

    re_host_port =re.compile(r'''^
            (([a-z0-9][a-z0-9\-]{1,62}\.)*   # (sub)domain - alpha followed by 62max chars (63 total)
            ([a-z]{2,})|[0-9]+(?:\.[0-9]+){3})  # TLD
            (:\b([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])\b)? # port
            $''', re.I | re.VERBOSE)

    def _to_python(self, value, state):
        match = self.re_host_port.match(value)
        if not match:
            raise Invalid(self.message("bad_format", state), value, state)
        if self.require_port and match.group(4) == None:
            raise Invalid(self.message("require_port", state), value, state)
        return value

class HostPortProtocol(HostPort):
    """
        Validator to check whether a string is a valid hostname/ip[:port[:protocol]]

        Options:
        * not_empty: If true, then if an empty value is given raise an error.
        * require_port: If true, then if port is missing raise an error.
        * require_protocol: If true, then if port or protocol are missing raise an error.
        * valid_protocols: List of valid protocols
    """

    require_protocol = False
    valid_protocols = ['tcp', 'udp']

    messages = {
        'bad_format': _('Please enter a valid hostname/IP address, port number and protocol'),
        'require_port': _('Missing port number'),
        'invalid_protocol': _('Invalid protocol'),
        'require_protocol': _('Missing protocol')
    }

    def __init__(self, *args, **kwargs):
        super(HostPortProtocol, self).__init__(*args, **kwargs)
        if self.require_protocol:
            self.require_port = True

    def _to_python(self, value, state):
        if value and value.count(":") == 2:
            host_port, protocol = value.rsplit(":", 1)
            if protocol:
                protocol = protocol.strip()
            if self.require_protocol and not protocol:
                raise Invalid(self.message("require_protocol", state), value, state)
            if protocol not in self.valid_protocols:
                raise Invalid(self.message("invalid_protocol", state), value, state)
        elif self.require_protocol:
            raise Invalid(self.message("require_protocol", state), value, state)
        else:
            host_port = value
        super(HostPortProtocol, self)._to_python(host_port, state)
        return value

class BindableIPAddress(FancyValidator):
    """
        Validator to check whether a string is a bindable (local) IP address
    """

    use_datatype = False

    messages = {
        'bad_format': _('Please enter a valid IP address (a.b.c.d)'),
        'cannot_bind': _('Cannot bind to the given IP address')
    }

    def _to_python(self, value, state):
        try:
            value = network.IPAddress(value)
        except:
            raise Invalid(self.message("bad_format", state), value, state)
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind((str(value).split("/")[0], 0))
        except:
            raise Invalid(self.message("cannot_bind", state), value, state)
        if self.use_datatype:
            return value
        else:
            return str(value).split("/")[0]

    def _from_python(self, value, state):
        return str(value).split("/")[0]
