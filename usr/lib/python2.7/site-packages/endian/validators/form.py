#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2012 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from formencode.validators import FormValidator, Invalid
from formencode.api import _
from endian import datatypes

__all__ = ['NetworkSelectorContains',
           'NetworkIntersection',
           'IpRange',
           'FieldValueCount',
           'Require',
           'RequireIfPresentSelected',
           'Unique',
           'ConditionalValidator',
          ]

class NetworkSelectorContains(FormValidator):
    """
    Controlls if the required interface types occure(as sum) at least
    count times.
    """
    # NetworkSelector field
    selector = None
    # A interface type (or list of types) which should be present
    interface = None
    # The count of appearences of the type(types)
    count = 1

    messages = {
        'missing_interface_selection': _("Not all needed interfaces selected."),
    }

    def __init__(self, *args, **kws):
        super(NetworkSelectorContains, self).__init__(*args, **kws)
        if not isinstance(self.interface, list):
            self.interface = [self.interface]

    def _to_python(self, value_dict, state):
        if self.selector is not None and self.interface is not None:
            values = [x.split(":")[1] for x in value_dict.get(self.selector).split(",")]
            value_count = 0
            for key in self.interface:
                value_count += values.count(key)

            if value_count < self.count:
                error_dict = {
                    self.selector: Invalid(self.message('missing_interface_selection',
                                                        state),
                                           value_dict,
                                           state)
                    }
                raise Invalid(_("Not all needed interfaces selected."),
                              value_dict, state,
                              error_dict=error_dict)
        return value_dict


class NetworkIntersection(FormValidator):
    """
    Controlls if the CIDR values intersect.
    """

    # The id
    networks = []

    __unpackargs__ = ('networks',)

    messages = {
        'bad_format': _("The network string is formated bad!"),
        'intersect': _("The different networks do intersect!")
    }

    def __init__(self, *args, **kws):
        super(NetworkIntersection, self).__init__(*args, **kws)

    def _to_python(self, value_dict, state):
        cidrs = []
        for network in self.networks:
            try:
                values = value_dict[network]
                if not isinstance(values, list):
                    if "," in values:
                        values = values.split(",")
                    else:
                        values = [values]

                for value in values:
                    cidrs.append(datatypes.CIDR(value))
            except (ValueError, AttributeError):
                error_dict = {
                    network: Invalid(self.message("bad_format", state), value, state)
                    }
                raise Invalid(_('The networks have bad formats: %s' % (" ,".join(self.networks))),
                              value_dict,
                              state,
                              error_dict=error_dict)

        error = False
        for i, cidri in enumerate(cidrs):
            for j, cidrj in enumerate(cidrs):
                if i == j:
                    continue
                if cidri in cidrj:
                    error = True
                    break
            break

        if error:
            error_dict = {}
            for network in self.networks:
                error_dict[network] = Invalid(self.message('intersect', state),
                                              value_dict,
                                              state)
            raise Invalid(_('The networks intersect: %s' % (" ,".join(self.networks))),
                          value_dict,
                          state,
                          error_dict=error_dict)
        return value_dict

class IpRange(FormValidator):
    """
    Controlls if the first ip greater than the second.
    Optional: controlls if both are in a certain network(may multiple with comma separated).
    """

    # first ip
    first_ip = None
    # second ip
    second_ip = None
    # network
    network = None

    __unpackargs__ = ('first_ip','second_ip')

    messages = {
        'bad_format': _("The ip string is formated bad!"),
        'first_greater': _("The first ip must be smaller than the second!"),
        'not_subnetwork': _("The ip is not in the network!")
    }

    def _to_python(self, value_dict, state):
        import iplib

        if self.first_ip and self.second_ip:
            try:
                start_ip = iplib.IPv4Address(value_dict[self.first_ip])
            except (ValueError, AttributeError):
                error_dict = {
                    self.first_ip: Invalid(self.message("bad_format", state),
                                           value_dict, state)
                    }
                raise Invalid(_('The ip has bad format: %s' % self.first_ip),
                              value_dict,
                              state,
                              error_dict=error_dict)
            try:
                end_ip = iplib.IPv4Address(value_dict[self.second_ip])
            except ValueError, AttributeError:
                error_dict = {
                    self.second_ip: Invalid(self.message("bad_format", state),
                                            value_dict, state)
                    }
                raise Invalid(_('The ip has bad format: %s' % self.second_ip),
                              value_dict,
                              state,
                              error_dict=error_dict)

            if start_ip >= end_ip:
                error_dict = {
                    self.first_ip: Invalid(self.message('first_greater', state),
                                           value_dict,
                                           state)
                    }
                raise Invalid(_('The first ip is greate: %s %s' % (self.first_ip, self.second_ip)),
                              value_dict,
                              state,
                              error_dict=error_dict)

            if self.network:
                cidrs = []
                try:
                    values = value_dict[self.network]
                    if not isinstance(values, list):
                        if "," in values:
                            values = values.split(",")
                        else:
                            values = [values]

                    for value in values:
                        cidrs.append(datatypes.CIDR(value))
                except (ValueError, AttributeError):
                    error_dict = {
                        self.network: Invalid(self.message("bad_format", state),
                                         value_dict, state)
                        }
                    raise Invalid(_('The network has bad format: %s' % self.network),
                                  value_dict,
                                  state,
                                  error_dict=error_dict)

                first_in = False
                second_in = False
                for cidr in cidrs:
                    if value_dict[self.first_ip] in cidr:
                        first_in = True
                    if value_dict[self.second_ip] in cidr:
                        second_in = True

                if not first_in:
                    error_dict = {
                        self.first_ip: Invalid(self.message('not_subnetwork', state),
                                               value_dict,
                                               state)
                        }
                    raise Invalid(_('The first ip is not in the network: %s' % self.first_ip),
                                  value_dict,
                                  state,
                                  error_dict=error_dict)

                if not second_in:
                    error_dict = {
                        self.second_ip: Invalid(self.message('not_subnetwork', state),
                                                value_dict,
                                                state)
                        }
                    raise Invalid(_('The first ip is not in the network: %s' % self.second_ip),
                                  value_dict,
                                  state,
                                  error_dict=error_dict)


        return value_dict


class FieldValueCount(FormValidator):
    """
    Validator for checking if more then a defined count of items with a
    fieldvalue already exist.
    """

    field = "enabled"
    value = True
    count = 4
    entity = None
    storage = None

    messages = {
        'to_many': _("Too many items with same value"),
        'to_many_long': _('To many items with same value for %(field)s')
    }

    def _to_python(self, value_dict, state):
        if self.entity:
            self.storage = self.entity.storage()
        value = value_dict.get(self.field, "")
        # item is not effected
        if value != self.value:
            return value_dict
        try:
            id = int(value_dict.get("ID"))
        except:
            id = ""
        count = 0
        for item in self.storage.load():
            # do not include the item himself, because it could have had the same value before editing
            if int(item.get("ID")) == id:
                continue
            # do not increase count if the item does not have the value
            if item.get(self.field) != self.value:
                continue
            count += 1
            if count == self.count:
                error_dict = {
                    self.name: Invalid(self.message('to_many', state),
                                       value_dict, state)
                }
                raise Invalid(self.message('to_many_long', state, field=self.field),
                              value_dict, state,
                              error_dict=error_dict)
        return value_dict


class Require(FormValidator):
    """
    Require for the id(or list of id) an input value.
    """

    # The id
    require = []

    __unpackargs__ = ('require',)

    def __init__(self, *args, **kws):
        super(Require, self).__init__(*args, **kws)
        if not isinstance(self.require, list):
            self.require = [self.require]

    def _to_python(self, value_dict, state):

        missing = []

        for _require in self.require:
            if not value_dict.get(_require, False):
                missing.append(_require)

        if missing:
            error_dict = {}
            for _missing in missing:
                error_dict[_missing] = Invalid(self.message('empty', state),
                                               value_dict,
                                               state)

            raise Invalid(_('You must give a value for %s' % (" ,".join(missing))),
                          value_dict,
                          state,
                          error_dict=error_dict)

        return value_dict


class Unique(FormValidator):
    # Field that needs to be unique
    unique = None
    # entity in which to check
    entity = None
    # storage in which to check
    storage = None

    messages = {
        'unique': _("Must be unique"),
    }

    def _int_if_possible(self, v):
        try:
            return int(v)
        except:
            return v

    def _to_python(self, value_dict, state):
        if self.entity:
            self.storage = self.entity.storage()
        if self.unique and self.storage:
            id_ = self._int_if_possible(value_dict.get("ID"))
            value = value_dict.get(self.unique)
            for item in self.storage.load():
                if item.get(self.unique).lower() == value.lower() and self._int_if_possible(item.get("ID")) != id_:
                    error_dict = {
                        self.unique: Invalid(self.message('unique', state),
                                               value_dict,
                                               state)
                    }
                    raise Invalid(_('You must give a unique value for %s' % self.unique),
                                  value_dict, state,
                                  error_dict=error_dict)
        return value_dict


class RequireIfPresentSelected(FormValidator):

    """
    This requires one field based on another field being present or
    missing.  This is applied to a form, not an individual field
    (usually using a Schema's ``pre_validators`` or
    ``chained_validators``).

    If you provide a ``present`` value (another string key name) then
    if that field is present, the required field must also be present.

    If you provide a ``selected`` value (value of the present key) then
    if that value is selected, the required field must also be present.
    You may pass a list of acceptable values.

    ::

        >>> from formencode import validators
        >>> v = validators.RequireIfPresent('phone_type',
        ...                                 present='phone')
        >>> v.to_python({'phone_type':'', 'phone':'510 420  4577'})
        Traceback (most recent call last):
            ...
        Invalid: You must give a value for phone_type
        >>> v.to_python({'phone': ''})
        {'phone': ''}

    Note that if you have a validator on the optionally-required
    field, you should probably use ``if_missing=None``.  This way you
    won't get an error from the Schema about a missing value.  For example::

        class PhoneInput(Schema):
            phone = PhoneNumber()
            phone_type = String(if_missing=None)
            chained_validators = [RequireifPresent('phone_type', present='phone')]
    """

    # Field that potentially is required:
    required = None
    # If this field is present, then it is required:
    present = None
    # If this option of present is selected, then it is required:
    selected = None

    __unpackargs__ = ('required',)

    def __init__(self, *args, **kws):
        super(RequireIfPresentSelected, self).__init__(*args, **kws)
        if not isinstance(self.selected, list):
            self.selected = [self.selected]

    def _to_python(self, value_dict, state):
        is_required = False
        if self.present and self.selected:
            if value_dict.get(self.present) in self.selected:
                is_required = True
        elif self.present and value_dict.get(self.present):
            is_required = True
        if is_required and not value_dict.get(self.required):
            error_dict = {
                self.required: Invalid(self.message('empty', state),
                                       value_dict,
                                       state)
            }
            raise Invalid(_('You must give a value for %s' % self.required),
                          value_dict,
                          state,
                          error_dict=error_dict)
        return value_dict


class ConditionalValidator(FormValidator):
    """
    Does only apply the validator if the condition
    (a function which return True, if the validator should be applied, or
    a validator, which does not throw a exception) does not fail.

    Also a list of conditions or validators can be passed.
    """

    # The condition
    condition = []
    # the validator
    validator = []

    def __init__(self, *args, **kws):
        super(ConditionalValidator, self).__init__(*args, **kws)
        if not isinstance(self.condition, list):
            self.condition = [self.condition]
        if not isinstance(self.validator, list):
            self.validator = [self.validator]

    def _to_python(self, value_dict, state):

        if self.condition and self.validator:
            for _condition in self.condition:
                try:
                    if hasattr(_condition, "_to_python"):
                        if hasattr(_condition, '_to_python') and _condition._to_python is not None:
                            new_value_dict = _condition._to_python(value_dict, state)
                        else:
                            new_value_dict = _condition.validate_python(value_dict, state)
                        if new_value_dict is not None:
                            value_dict = new_value_dict
                    else:
                        if not _condition(value_dict, state):
                            return value_dict
                except Invalid:
                    return value_dict
            for _validator in self.validator:
                if hasattr(_validator, '_to_python') and _validator._to_python is not None:
                    new_value_dict = _validator._to_python(value_dict, state)
                else:
                    new_value_dict = _validator.validate_python(value_dict, state)
                if new_value_dict is not None:
                    value_dict = new_value_dict

        return value_dict
