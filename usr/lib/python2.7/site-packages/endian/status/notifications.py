#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2010-09-09"

"""
JSON notifications status interface
"""

from endian.core.logger import *
from endian.job.engine_control import send_cmd_to_engine, Fact
import time

__all__ = ['NotFoundError', 'getNotifications']

class NotFoundError(Exception):
    pass

def getNotifications(service, type, *argl, **args):
    """
    ... autofunction::: getNotifications

    Fetches notification data from notifications logger json file.
    The json file contains log messages posted with 'info()' or 'error()'.

    :param service: Specifies the service of which to fetch notifications
    :type service: string

    :param type: Accepts one of: 'status', 'history', 'error' in order to
    decide which json file to fetch. 'status' contains the current status,
    history contains all messages since start notified through the logger
    method 'info()' and 'error' contains the error messages posted with error().
    :service type: string
    """

    if type not in ['status', 'history', 'error']:
        raise KeyError("Type '%s' is not a valid notification type" % type)
    
    try:
        # Status
        query = "query service(name:%s)" % service
        result = send_cmd_to_engine(query)
        facts = [Fact(line[4:]) for line in result.split("\n") if line[3:4] == '-']
        if not facts:
            raise Exception("%s not found" % service)
        service_status = facts[0]
        schedule =  service_status.get_value('schedule')
        sub =  service_status.get_value('sub')
        status = service_status.get_value('status')
        t0 = service_status.get_value('t0', default=0, get_type=float)
        t1 = service_status.get_value('t1', default=0, get_type=float)
        modificationtime = max(t0, t1)
        if modificationtime == 0:
            modificationtime = time.time()
            
        if type == 'status' and schedule == "waiting":
            raise Exception("%s is not running" % service)
        elif type == 'error' and sub == "ok":
            raise Exception("No errors found for %s" % service)

        # Messages
        query = "messages raw %s" % min(t0, t1)
        result = send_cmd_to_engine(query)
        facts = [Fact(line[4:]) for line in result.split("\n") if line[3:4] == '-']
        data = []
        for fact in facts:
            if fact.get_value('job', default=None) == service:
                tmp = fact.get_value('msg').split('-', 2)
                msg_type = "info"
                msg_time = fact.get_value('timestamp')
                if len(tmp) == 3:
                    if tmp[1] == 'E':
                        msg_type = 'error'
                    msg = tmp[2]
                data.append({ 'msg': msg, 'type': msg_type, 'time': msg_time})
        return {
            'data': data,
            'schedule': schedule,
            'sub': sub,
            'status': status,
            'modificationtime': modificationtime,
        }
    except Exception, ex:
        return {
            "exception": str(ex),
            "error": str(ex)
        }            

if __name__ == '__main__':
    print getNotifications(
        service='squid',
        type='history'
        )

