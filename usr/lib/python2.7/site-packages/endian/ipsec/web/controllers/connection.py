#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2012-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | efw-ipsec is free software: you can redistribute it and/or modify it     |
# | under the terms of GNU General Public License (GPL) version 2.0          |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | efw-ipsec is distributed in the hope that it will be useful,             |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with efw-ipsec.     |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+

from endian.core import logger
from endian.data import DataSource
from endian.validators.boolean import to_bool
from endian.ca.schema import Certificate
from endian.ca.web.controllers.common import BaseCertificateGridController
from endian.ipsec.schema import IPsecConnection
from endian.ipsec.commands import ipsec_reload, reset_connection
from endian.ipsec.web.widgets.connection import ConnectionEditor, ConnectionGrid

__all__ = [
    "IPsecConnectionController"
]

class IPsecConnectionController(BaseCertificateGridController):
    title = _("Connections")

    editorWidget = ConnectionEditor
    gridWidget = ConnectionGrid

    cert_option_field = "auth_type"
    filename_field = "cert_filename"

    def onLoad(self, id, data):
        if data.get('auth_type') == 'cert' and data.get('common_name') == '%auth-dn':
            data['auth_type'] = "auth-dn"
            data['common_name'] = ""
        return data

    def onStore(self, id, data):
        auth_type = data.get(self.cert_option_field)
        if auth_type == 'psk' or auth_type == 'hybrid':
            # Password or XAuth hybrid
            data['cert_filename'] = ""
            data['common_name'] = ""
        elif auth_type == 'cert':
            # Use an existing certificate
            cert_filename = data["cert_filename"]
            try:
                if not cert_filename.endswith("cert.pem"):
                    raise Exception(_("Invalid certificate"))
                cert_name = cert_filename[:-8]
                common_name = Certificate.get_by_name(cert_name).common_name
                data['common_name'] = common_name
            except Exception, ex:
                logger.error(str(ex), exc_info=True)
                data['error'] = str(ex)
        elif auth_type == 'new_cert':
            # Create a new certificate
            data['auth_type'] = 'cert'
            data['common_name'] = data['new_cert_name']
        elif auth_type == 'upload_cert':
            # Upload certificate
            data['auth_type'] = 'cert'
        elif auth_type == 'upload_cert_req':
             # Upload certificate request
            data['auth_type'] = 'cert'
        elif auth_type == 'auth-dn':
            data['auth_type'] = 'cert'
            data['common_name'] = "%auth-dn"
        else:
            data = super(IPsecConnectionController, self).onStore(id, data)
        # Check the virtual IP pool
        DS = DataSource()
        if not DS.VPN.SETTINGS.VIRTUAL_IP_POOL and to_bool(data.get('vhost', None)):
            data["info"] = _("Warning: Set the Roadwarriors virtual IP pool in order to use the Virtual IPs")
        return data

    def onStoreSuccess(self, id, data):
        """
        Triggered after data has been written to storage
        """
        ipsec_reload()
        return data

    def onEnableSuccess(self, data):
        """
        Triggered after enable action was finished successfully
        """
        ipsec_reload()
        if data.get('enabled') == 'off':
            id = data.get('ID')
            if id is not None:
                connection = IPsecConnection.storage().load(id)
                if connection is not None:
                    reset_connection(connection.get('name'))
        return data

    def onDeleteSuccess(self, data):
        """
        Triggered after delete action was finished successfully
        """
        ipsec_reload()
        return data

