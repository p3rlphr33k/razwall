#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2012-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | efw-ipsec is free software: you can redistribute it and/or modify it     |
# | under the terms of GNU General Public License (GPL) version 2.0          |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | efw-ipsec is distributed in the hope that it will be useful,             |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with efw-ipsec.     |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+

import endian.core.i18n
from endian.core.logger import *
from endian.core.lazylist import LazyList, CachedList
from endian.data import DataSource
from endian.validators.core import Int, Multichoice, String, Multiline
from endian.validators.form import FormValidator
from endian.datatypes import network
from endian.validators.network import NetworkAddress, HostnameOrIPAddress
from endian.emi import entities
from endian.emi import widgets
from endian.job.engine_control import send_cmd_to_engine

__all__ = [
    "IPsecTypeOptions",
    "IPsecDeadPearActionOptions",
    "IPsecEncryption",
    "IPsecIKEIntegrity",
    "IPsecESPIntegrity",
    "IPsecGroupType",
    "IPsecAuthenticationOptions",
    "IPsecIKEVersionOptions",
    "IPsecInterfaceOptions",
    "IPsecConnection",
    "IPsecModeConfigOptions",
    "IPsecAutoOptions",
]

def get_local_subnet():
    try:
        DS = DataSource()
        net = network.CIDR(DS.ETHERNET.SETTINGS.GREEN_IPS)
        return "%s/%s" % (net.netaddress, net.bits)
    except:
        return ""

def get_certificate_filename():
    from endian.ca.commands import get_file_names
    return [{'ID': x, 'name': x} for x in get_file_names()]


class IPsecTypeOptions(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)
    label = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'host', 'name': _("Host-to-Net (roadwarrior)"), 'label': 'Host'},
        {'ID': 'net',  'name': _("Net-to-Net"), 'label': 'Net'},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None

# Optional types
try:
    import endian.l2tp
    IPsecTypeOptions.values.append(
        {'ID': 'l2tp', 'name': _("L2TP Host-to-Net (roadwarrior using L2TP)"), 'label': 'L2TP'},
    )
except:
    pass
try:
    import endian.xauth
    IPsecTypeOptions.values.append(
        {'ID': 'xauth', 'name': _("XAuth Host-to-Net (roadwarrior using XAuth)"), 'label': 'XAuth'},
    )
except:
    pass

class IPsecDeadPearActionOptions(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'restart', 'name': _("Restart")},
        {'ID': 'clear',   'name': _("Clear")},
        {'ID': 'hold',    'name': _("Hold")}
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None

class IPsecEncryption(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'aes256',        'name': _("AES (256 bit)")},
        {'ID': 'aes192',        'name': _("AES (192 bit)")},
        {'ID': 'aes128',        'name': _("AES (128 bit)")},
        {'ID': 'blowfish256',   'name': _("Blowfish (256 bit)")},
        {'ID': 'blowfish192',   'name': _("Blowfish (192 bit)")},
        {'ID': 'blowfish128',   'name': _("Blowfish (128 bit)")},
        {'ID': '3des',          'name': _("3DES")},
        {'ID': 'camellia128',   'name': _("Camellia (128 bit)")},
        {'ID': 'camellia192',   'name': _("Camellia (192 bit)")},
        {'ID': 'camellia256',   'name': _("Camellia (256 bit)")},
        {'ID': 'serpent128',    'name': _("Serpent (128 bit) - IKEv1 only")},
        {'ID': 'serpent192',    'name': _("Serpent (192 bit) - IKEv1 only")},
        {'ID': 'serpent256',    'name': _("Serpent (256 bit) - IKEv1 only")},
        {'ID': 'twofish128',    'name': _("Twofish (128 bit) - IKEv1 only")},
        {'ID': 'twofish192',    'name': _("Twofish (192 bit) - IKEv1 only")},
        {'ID': 'twofish256',    'name': _("Twofish (256 bit) - IKEv1 only")},
        {'ID': 'cast128',       'name': _("CAST - IKEv2 only")},
        {'ID': 'null',          'name': _("Null encryption")},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None

class IPsecIKEIntegrity(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'sha1',        'name': _("SHA1")},
        {'ID': 'md5',         'name': _("MD5")},
        {'ID': 'sha2_256',    'name': _("SHA2 256")}, # before version 2.6.33 the Linux kernel incorrectly used 96 bit truncation for SHA-256
        {'ID': 'sha2_384',    'name': _("SHA2 384")},
        {'ID': 'sha2_512',    'name': _("SHA2 512")},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None

class IPsecESPIntegrity(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'sha1',        'name': _("SHA1")},
        {'ID': 'md5',         'name': _("MD5")},
        {'ID': 'sha2_256',    'name': _("SHA2 256")}, # before version 2.6.33 the Linux kernel incorrectly used 96 bit truncation for SHA-256
        {'ID': 'sha2_384',    'name': _("SHA2 384")},
        {'ID': 'sha2_512',    'name': _("SHA2 512")},
        {'ID': 'aesxcbc',     'name': _("AES XCBC")},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None

class IPsecGroupType(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': '8192',      'name': _("DH group 18 (8192 bit)")},
        {'ID': '6144',      'name': _("DH group 17 (6144 bit)")},
        {'ID': '4096',      'name': _("DH group 16 (4096 bit)")},
        {'ID': '3072',      'name': _("DH group 15 (3072 bit)")},
        {'ID': '2048',      'name': _("DH group 14 (2048 bit)")},
        {'ID': '1536',      'name': _("DH group 5 (1536 bit)")},
        {'ID': '1024',      'name': _("DH group 2 (1024 bit)")},
        {'ID': '768',       'name': _("DH group 1 (768 bit)")},
        {'ID': '1024s160',  'name': _("DH group 22 (1024 bit, sub 160 bit)")},
        {'ID': '2048s224',  'name': _("DH group 23 (2048 bit, sub 224 bit)")},
        {'ID': '2048s256',  'name': _("DH group 24 (2048 bit, sub 256 bit)")},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None

class IPsecAuthenticationOptions(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)
    label = entities.Field(entities.Unicode, nullable=False)

    values = [
            {'ID': 'psk',  'name': _("Password (PSK)"), 'label': 'PSK' },
            {'ID': 'auth-dn', 'name': _("Peer is identified by either IPV4_ADDR, FQDN, USER_FQDN or DER_ASN1_DN string in remote ID field"), 'label': 'Auth-DN' },
            {'ID': 'cert', 'name': _("Use an existing certificate"), 'label': 'Certificate' },
            {'ID': 'new_cert', 'name': _("Generate a new certificate"), 'label': 'Certificate' }, # not stored, only for the gui
            {'ID': 'upload_cert', 'name': _("Upload a certificate"), 'label': 'Certificate' }, # not stored, only for the gui
            {'ID': 'upload_cert_req', 'name': _("Upload a certificate request"), 'label': 'Certificate' }, # not stored, only for the gui
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None

try:
    import endian.xauth
    IPsecAuthenticationOptions.values.insert(1,
        {'ID': 'hybrid', 'name': _("XAuth Hybrid"), 'label': 'Hybrid'},
    )
except:
    pass

class IPsecIKEVersionOptions(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': '',  'name': _("Both IKEv1 and IKEv2")},
        {'ID': '1', 'name': _("IKEv1")},
        {'ID': '2', 'name': _("IKEv2")},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None


class IPsecModeConfigOptions(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)
    label = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'pull', 'name': 'Pull', 'label': 'Pull'},
        {'ID': 'push', 'name': 'Push', 'label': 'Push'},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None


def get_connections():
    """
    ..autofunction::get_connections
      Return the list of the open connections
      Example:
      [{'status': 'ESTABLISHED', 'since': '4 minutes ago', 'name': 'mini30'}]
    """
    data = [x[4:].split(' ', 2) for x in send_cmd_to_engine("call ipsec.connections").split('\n') if x[0] == '2']
    return [dict(zip(['name','status','since'], x)) for x in data]


def get_ipsec_interfaces():
    from endian.core.niclist import getUplinks, getZoneDevices
    interfaces = []
    # Uplinks
    uplinks = getUplinks().values()
    uplinks.sort(cmp=lambda x,y: cmp(x.sortorder, y.sortorder))
    interfaces.extend(uplinks)
    # Zones
    zones = [v for k,v in getZoneDevices().items() if k.lower() not in ('red', 'purple')]
    zones.sort(cmp=lambda x,y: cmp(x.sortorder, y.sortorder))
    interfaces.extend(zones)
    return [{'ID': x.get("logical"), 'name': x.get("description", x.get("logical"))} for x in interfaces]


class IPsecInterfaceOptions(entities.Entity):
    entities.using_options(type='dynamic')

    ID = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)

    values = LazyList(get_ipsec_interfaces)

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        return cls.storage().load(id)


class IPsecAutoOptions(entities.Entity):
    entities.using_options(type='const')

    id = entities.Field(entities.Unicode, primary_key=True, nullable=False)
    name = entities.Field(entities.Unicode, nullable=False)
    label = entities.Field(entities.Unicode, nullable=False)

    values = [
        {'ID': 'start', 'name': _("Brings the connection up immediately"), 'label': 'Start'},
        {'ID': 'route', 'name': _("Starts the connection if traffic is detected"), 'label': 'Route'},
        {'ID': 'add', 'name': _("Loads the connection without starting it"), 'label': 'Add'},
    ]

    @classmethod
    def all(cls):
        return cls.storage().load()

    @classmethod
    def get_by_id(cls, id):
        for item in cls.all():
            if item['ID'] == id:
                return item
        return None


class IPsecConnection(entities.Entity):
    _connections = CachedList(get_connections, timeout=5)

    entities.using_options(namespace='vpn.config', type='csv', register_datasource=True)

    ID = entities.Field(entities.Integer,
        primary_key=True,
        autoincrement=True,
        hidden=True,
        expands=True)

    enabled = entities.Field(entities.Boolean,
        label_text=_("Enabled"),
        default=True)
    name = entities.Field(entities.String,
        label_text=_("Name"),
        required=True)
    common_name = entities.Field(entities.String,
        label_text=_("Common name"))
    connection_type = entities.ManyToOne(
        target="ipsec:IPsecTypeOptions",
        label_text=_("Connection type"),
        required=True)
    auth_type = entities.ManyToOne(
        target="ipsec:IPsecAuthenticationOptions",
        label_text=_("Authentication type"),
        required=True)
    
    secret = entities.Field(entities.String,
        label_text=_("Use a pre-shared key"),
        toggle_name="auth_type",
        toggle_option="psk")
    side = entities.Field(entities.String,
        label_text=_("TODO")) # left/right
    local_peerid = entities.Field(entities.String,
        label_text=_("Local ID"))
    local_subnet = entities.Field(entities.UnicodeText,
        label_text=_("Local subnets (only IKEv2 supports multiple subnets)"),
        validator=Multiline(NetworkAddress, required=True),
        default=get_local_subnet,
        required=True)
    remote_peerid = entities.Field(entities.String,
        label_text=_("Remote ID"))
    remote_address = entities.Field(entities.String,
        label_text=_("Remote host/IP"),
        validator=HostnameOrIPAddress)
    remote_subnet = entities.Field(entities.UnicodeText,
        label_text=_("Remote subnet (only IKEv2 supports multiple subnets)"),
        validator=Multiline(NetworkAddress),
        toggle_name="connection_type",
        toggle_option="net",
        expands=True)
    aggressive_mode = entities.Field(entities.Boolean,
        label_text=_("TODO"),
        default=False)
    compression = entities.Field(entities.Boolean,
        label_text=_("Negotiate payload compression"),
        default=False)
    vhost = entities.Field(entities.Boolean,
        label_text=_("Roadwarrior virtual IP (inner IP)"),
        default=False,
        toggle_name="connection_type",
        toggle_option=["host","xauth"])
    empty = entities.Field(entities.Boolean,
        label_text=_("TODO"),
        default=False)
    ike_lifetime = entities.Field(entities.Integer,
        label_text=_("IKE lifetime (hours)"),
        validator=Int,
        default=1)
    esp_keylife = entities.Field(entities.Integer,
        label_text=_("ESP lifetime (hours)"),
        validator=Int,
        default=8)

    ike_encryption = entities.ManyToMany(
        label_text=_("IKE encryption"),
        target="ipsec:IPsecEncryption", target_key="ID", target_label="name",
        multi_type="small",
        validator=Multichoice(String),
        default=['aes128','3des'])

    ike_integrity = entities.ManyToMany(
        label_text=_("IKE integrity"),
        target="ipsec:IPsecIKEIntegrity", target_key="ID", target_label="name",
        multi_type="small",
        validator=Multichoice(String),
        default=['md5','sha1'])

    ike_grouptype = entities.ManyToMany(
        label_text=_("IKE group type"),
        target="ipsec:IPsecGroupType", target_key="ID", target_label="name",
        multi_type="small",
        validator=Multichoice(String),
        default=['1024','1536'])

    esp_encryption = entities.ManyToMany(
        label_text=_("ESP encryption"),
        target="ipsec:IPsecEncryption", target_key="ID", target_label="name",
        multi_type="small",
        validator=Multichoice(String),
        default=['aes128','3des'])

    esp_integrity = entities.ManyToMany(
        label_text=_("ESP integrity"),
        target="ipsec:IPsecESPIntegrity", target_key="ID", target_label="name",
        multi_type="small",
        validator=Multichoice(String),
        default=['md5','sha1'])

    esp_grouptype = entities.ManyToMany(
        label_text=_("ESP group type"),
        target="ipsec:IPsecGroupType", target_key="ID", target_label="name",
        multi_type="small",
        validator=Multichoice(String),
        default=['1024','1536'])

    only_proposed = entities.Field(entities.Boolean,
        label_text=_("TODO"),
        default=False)

    remark = entities.Field(entities.String,
        label_text=_("Remark"))

    interface = entities.ManyToOne(
        target="ipsec:IPsecInterfaceOptions",
        label_text=_("Interface"),
        required=True)

    dpd_action = entities.ManyToOne(
        target="ipsec:IPsecDeadPearActionOptions",
        label_text=_("Dead peer detection action"),
        required=True)

    pfs = entities.Field(entities.Boolean, # Obsole in strongSwan >= 5.0.0
        label_text=_("Perfect Forward Secrecy (PFS)"),
        default=True)

    cert_filename = entities.ManyToOne(
        target="ca:Certificate",
        singleselect_type="chosen",
        label_text=_("Certificate"),
        toggle_name="auth_type",
        toggle_option="cert")

    ike_version = entities.ManyToOne(
        target="ipsec:IPsecIKEVersionOptions",
        label_text=_("IKE version"))
    
    modeconfig = entities.ManyToOne(
        target="ipsec:IPsecModeConfigOptions",
        label_text=_("Mode config (IKEv1 only)"))

    auto = entities.ManyToOne(
        target="ipsec:IPsecAutoOptions",
        label_text=_("Connection startup"),
        toggle_name="connection_type",
        toggle_option="net")

    @property
    def is_connected(self):
        for connection in self._connections:
            if connection.get('name') == self.name:
                return True
        return False

    @property
    def status(self):
        for connection in self._connections:
            if connection.get('name') == self.name:
                status = connection.get('status')
                if status == 'ESTABLISHED':
                    status = _("Connected")
                elif status == 'CONNECTING':
                    status = _("Connecting")
                return status
                # return "%s %s" % (status, connection.get('since', ''))
        return _("Closed")

    @property
    def type_label(self):
        try:
            label = IPsecTypeOptions.get_by_id(self.connection_type).label
        except:
            label = ""
        try:
            auth_type = self.auth_type
            if auth_type == 'cert' and self.common_name == '%auth-dn':
                auth_type = 'auth-dn'
            label += " (" + IPsecAuthenticationOptions.get_by_id(auth_type).label + ")"
        except:
            pass
        return label

    @property
    def common_name_type(self):
        if self.common_name != '%auth-dn':
            return self.common_name
        else:
            return ""

    @property
    def auth_dn(self):
        return self.common_name == '%auth-dn'

    @classmethod
    def invalidate_open_connections_cache(clazz):
        """
        ..autofunction:: invalidate_open_connections_cache
          Invalidate the cached open connections list (force reexecuting the function at the next access to the list)
        """
        clazz._connections.expiry = 0
