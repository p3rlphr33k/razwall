from endian.data.ds import DataSource
from uplinksdaemon.uplinks import UplinksPool
from endian.core.csvfile import CSVFile
from endian.core.logger import logger as def_logger
from endian.job.commons import is_ipaddress
import iplib

def get_source_ip(subnet):
    cidr = iplib.CIDR(subnet)
    ds = DataSource('ETHERNET')
    networks = []
    networks.extend(ds.settings.get('GREEN_IPS', '').split(','))
    networks.extend(ds.settings.get('ORANGE_IPS', '').split(','))
    networks.extend(ds.settings.get('BLUE_IPS', '').split(','))
    for net in networks:
        if net == "":
            continue
        source = iplib.CIDR(net).get_ip().get()
        if source in cidr:
            return source
    return ''


def get_uplink_data():
    ups = UplinksPool()
    uplinks = {}
    for uplink in ups.iterUplinks():
        settings = uplink.getSettings()
        if settings.get('RED_TYPE') == 'NONE':
            continue
        name = uplink.uplinkname
        data = uplink.getData()
        ip = data.get('ips', '')
        ips = ip.split(' ')
        ips = map(lambda x: x[:x.find('/')], ips)
        uplinks[name.lower()] = {
            'IPS': ips,
            'INTERFACE': data.get('interface'),
            'GATEWAY': data.get('gateway')
        }
    return uplinks

def get_connections(logger=def_logger):
    config = CSVFile('/var/efw/vpn/config', IPSEC(), tolerant=True).load()
    if not config:
        return []
    uplinks = get_uplink_data()
    for conn in config._data:
        # Set the default values
        if conn.esp_integrity == '':
            conn.esp_integrity = 'sha1|md5'
        if conn.esp_encryption == '':
            conn.esp_encryption = 'aes128|3des'
        if conn.ike_grouptype == '':
            conn.ike_grouptype = '1536|1024'
        if conn.ike_integrity == '':
            conn.ike_integrity = 'sha|md5'
        if conn.ike_encryption == '':
            conn.ike_encryption = 'aes128|3des'
        if conn.remote_address == '':
            conn.remote_address = '%any'

        conn.esp_grouptype_arr = conn.esp_grouptype and conn.esp_grouptype.split('|') or []
        conn.esp_integrity_arr = conn.esp_integrity.split('|')
        conn.esp_encryption_arr = conn.esp_encryption.split('|')
        conn.ike_grouptype_arr = conn.ike_grouptype.split('|')
        conn.ike_integrity_arr = conn.ike_integrity.split('|')
        conn.ike_encryption_arr = conn.ike_encryption.split('|')
        conn.local_subnet = conn.local_subnet.split('|')
        conn.remote_subnet = conn.remote_subnet.split('|')
        conn.local_sourceip = [get_source_ip(x) for x in conn.local_subnet if x]

        if conn.interface == 'RED':
            if uplinks.get('main'):
                conn.interface = 'UPLINK:main'
            else:
                if len(uplinks) == 0:
                    logger.error("Could not find a valid uplink. Are there only uplinks of type gateway?")
                    continue
                conn.interface = 'UPLINK:%s' % (uplinks.keys()[0])
        if conn.interface.startswith('UPLINK:'):
            tmp_uplink = conn.interface.split(':')
            up_name = tmp_uplink[1].lower()
            up = uplinks.get(up_name)
            if not up:
                logger.error("Could not find uplink '%s'. Has the uplink been removed or is it of type gateway perhaps?" % up_name)
                continue
            up_gw = up.get('GATEWAY')
            up_if = up.get('INTERFACE')
            if len(tmp_uplink) == 3:
                up_ip = tmp_uplink[2]
            else:
                try:
                    up_ip = up.get('IPS')[0]
                except:
                    logger.error("IP not found for uplink '%s'." % (up_name))
                    continue
            conn.uplink = {'IP': up_ip, 'INTERFACE': up_if, 'GATEWAY': up_gw}
        if (conn.local_peerid != ''
                and not conn.local_peerid.startswith('@')
                and not is_ipaddress(conn.local_peerid)
                and conn.local_peerid.find("=") < 0):
            conn.local_peerid = "@%s" % conn.local_peerid
        if (conn.remote_peerid != ''
                and not conn.remote_peerid.startswith('@')
                and not is_ipaddress(conn.remote_peerid)
                and conn.remote_peerid.find("=") < 0):
            conn.remote_peerid = "@%s" % conn.remote_peerid
    return config._data


class IPSEC(object):

    def __init__(self):
        self._meta = [
            'index', 'enabled', 'name', 'cert_name', 'connection_type', 'auth_type',
            'secret', 'side', 'local_peerid', 'local_subnet', 'remote_peerid', 'remote_address',
            'remote_subnet', 'aggressive_mode', 'compression', 'vhost', 'empty',
            'ike_lifetime', 'esp_keylife', 'ike_encryption', 'ike_integrity', 'ike_grouptype',
            'esp_encryption', 'esp_integrity', 'esp_grouptype', 'only_proposed', 'remark',
            'interface', 'dpd_action', 'pfs', 'cert_filename', 'ike_version', 'modeconfig', 'auto'
        ]

        self.aggressive_mode = 'off'  # AGGR_MODE
        self.auth_type = 'psk'  # psk/cert  (AUTH)
        self.cert_filename = ''
        self.cert_name = ''
        self.compression = 'on'
        self.connection_type = 'host'  # host/net  (TYPE)
        self.dpd_action = 'restart'  # clear/restart/hold
        self.empty = 'off'
        self.enabled = 'off'
        self.esp_encryption = ''
        self.esp_grouptype = ''
        self.esp_integrity = ''
        self.esp_keylife = ''
        self.ike_encryption = ''
        self.ike_grouptype = ''
        self.ike_integrity = ''
        self.ike_lifetime = ''
        self.ike_version = ''
        self.index = -1
        self.interface = 'RED'  # RED/ORANGE/BLUE
        self.local_peerid = ''
        self.local_sourceip = ''
        self.local_subnet = ''
        self.modeconfig = ''
        self.name = ''
        self.only_proposed = 'off'
        self.pfs = 'off'  # obsolete
        self.remark = ''
        self.remote_address = ''  # REMOTE
        self.remote_peerid = ''
        self.remote_subnet = ''
        self.secret = ''
        self.side = ''  # left/right
        self.vhost = 'off'

