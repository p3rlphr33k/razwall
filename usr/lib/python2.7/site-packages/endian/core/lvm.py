#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.core.logger import info 
from endian.core.i18n import _
import subprocess
import os 
import sys
import time
import string
import pexpect
import signal
from endian.core.daemon import daemonize
from copy import deepcopy

__VOLUME_GROUP = 'local'
__SNAPSHOT_SIZE = 2000
__USE_DD_TO_COPY = True
__DD_RESCUE_AVAILABLE = os.path.exists('/bin/dd_rescue')

LVM_ERROR_NO_SPACE = 101
LVM_ERROR_NO_GROUP = 102
LVM_ERROR_NO_VOLUME = 103
LVM_ERROR_NO_SUCCESS = 104
LVM_ERROR_VOLUME_USED = 105

__SIGNALS = [signal.SIGHUP,
             signal.SIGINT,
             signal.SIGQUIT,
             signal.SIGILL,
             signal.SIGTRAP,
             signal.SIGABRT,
             signal.SIGFPE,
             signal.SIGSEGV,
             signal.SIGPIPE,
             signal.SIGTERM,
             signal.SIGUSR1,
             signal.SIGUSR2] 

def isUsed():
    '''
    Check whether we are using LVM or not.
    '''
    p1 = subprocess.Popen(['/usr/sbin/lvscan'], 
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE)
    output = p1.communicate()[0].strip()
    if output == '':
        return False
    return True

def createVolume(volumename,size,volumegroup=__VOLUME_GROUP):
    p = subprocess.Popen(['/usr/sbin/lvcreate','-L',"%sM"%size,
                          '-n',volumename,volumegroup],
                         stderr=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    ret = p.wait()
    return ret == 0

def removeVolume(volumename,volumegroup=__VOLUME_GROUP):
    px = subprocess.Popen(['/usr/sbin/lvremove',
                           '-f',
                           "/dev/%s/%s" %(volumegroup,volumename)],
                          stderr=subprocess.PIPE,
                          stdout=subprocess.PIPE)
    ret = px.wait()
    return ret == 0

def createSnapshot(volumename,snapshotname,size=__SNAPSHOT_SIZE,volumegroup=__VOLUME_GROUP):
    p = subprocess.Popen(['/usr/sbin/lvcreate','-L','%sM' %size,'-s',
                          '-n',snapshotname,'/dev/%s/%s' %(volumegroup,volumename)],
                         stderr=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    ret = p.wait()
    return ret == 0

def __ddReadStatus(statusfile,opid,size,current,total):
    info(_('Waiting for information.'))

    def signalHandler(signum, frame):
        info(_("Caught signal %s - cleaning up before quitting.")%signum)
        try:
            try:
                os.kill(opid,signal.SIGTERM)
            except OSError:
                pass
            if os.path.exists(statusfile):
                os.unlink(statusfile)
        except Exception:
            sys.exit(1)

    # Intercept lots of signals
    for sig in __SIGNALS:
        signal.signal(sig,signalHandler)

    start = time.time()
    time.sleep(1)
    # convert since we are using megabytes everywhere else
    # while here bytes are required
    size = size * 1024 * 1024
    dir = '/proc/%s/fd'%opid
    infodir = '/proc/%s/fdinfo'%opid
    realfile = None
    for file in os.listdir(dir):
        fname = "%s/%s"%(dir,file)
        if os.path.realpath(fname) == os.path.realpath(statusfile):
            realfile = file
            break
    if not realfile:
        return
    realfile = "%s/%s" %(infodir,realfile)
    while True:
        try:
            f = open(realfile,'r')
            content = f.readlines()
            f.close()
            value = int(content[0].split(':')[1].strip())
            percentage = (value/float(size))*100
            now = int(time.time())
            diff = now - start
            remaining = 100 - percentage
            timeleft = int((diff*remaining)/percentage)
            minutes = timeleft / 60
            seconds = timeleft % 60
            info(_('Copying volume %d of %d: %2.1f%% done. %d:%02d minutes remaining.')%(current,
                                                                                         total,
                                                                                         percentage,
                                                                                         minutes,
                                                                                         seconds))
        except IndexError,e:
            pass
        except IOError,e:
            return 0
        except Exception, e:
            info('Something unexpected happened: %s.' %e)
            return -1
        time.sleep(5)
    return -1

def __ddWithStatus(volumes,pidname,callback=None,**callback_args):
    daemonize()
    remove_on_failure = []
    total = len(volumes)
    current = 1
    for volume in volumes:
        source = volume.get('source')
        destination = volume.get('destination')
        remove_source_on_failure = volume.get('remove_source_on_failure',True)
        remove_destination_on_failure = volume.get('remove_destination_on_failure',True)
        copy_from_snapshot = volume.get('copy_from_snapshot',False)
        create_destination = volume.get('create_destination',False)
        size = volume.get('size',0)

        lvmsource = __isLVMVolume(source)
        lvmdestination = __isLVMVolume(destination)

        compress = False
        uncompress = False

        if remove_source_on_failure:
            remove_on_failure.append(source)
        if remove_destination_on_failure:
            remove_on_failure.append(destination) 

        if not lvmsource and source.endswith('.gz'):
            uncompress = True

        if not lvmdestination:
            compress = True

        time_id = int(time.time())

        if lvmdestination:
            dst_group = string.split(destination,'/')[-2]
            dst_volume = string.split(destination,'/')[-1]

        if lvmsource:
            src_group = string.split(source,'/')[-2]
            src_volume = string.split(source,'/')[-1]

        if lvmsource and copy_from_snapshot:
            snapshotname = "%s.%s" %(src_volume,time_id)
            volumename = src_volume
            ret = createSnapshot(volumename,snapshotname, __SNAPSHOT_SIZE, src_group)
            if not ret:
                break
            remove_on_failure.append('/dev/%s/%s'%(src_group,snapshotname))

        if lvmdestination and create_destination:
            ret = createVolume(dst_volume, size, dst_group)
            if not ret:
                break

        if uncompress:
            info(_("Decompressing backup file %s.")%source)
            # Spawn with 5 hours timeout
            p = pexpect.spawn('/usr/local/bin/gunzip-progress -c %s'%source, timeout=60*60*5)
            source = source[:-3]
            while True:
                index = p.expect(['minutes','Done.','Failed.',pexpect.TIMEOUT,pexpect.EOF])
                if index == 0:
                    progress, eta = p.before.split(',')
                    progress = progress.split(' ')[-1]
                    eta = eta.strip().split(' ')[-1]
                    info(_("Decompressing backup %d of %d: %s done. %s minutes remaining.") %(current,total,progress,eta))
                elif index == 2 or index == 3:
                    if callback:
                        callback(False,**callback_args)
                    return False
                elif index == 4 or index == 1:
                    p.close()
                    ret = p.exitstatus
                    if ret == None:
                        ret = 0
                    if ret != 0:
                        if callback:
                            callback(False,**callback_args)
                        return False
                    break
    
            #convert size to megabytes
            size = int(os.path.getsize(source)) / (1024*1024)
        
        if lvmsource and copy_from_snapshot:
            dd_source = '/dev/%s/%s'%(src_group,snapshotname)
        else:
            dd_source = source
        p = subprocess.Popen(['/bin/dd','if=%s'%dd_source,'of=%s'%destination])
        pid = p.pid
    
    
        # Catch signals so files can be removed before exiting
        #
        # NOTE: killing the process while reverting a backup will leave the virtual
        #       machine in a non-working state
        def signalHandler(signum, frame):
            if signum != 0:
                info(_("Caught signal %s - preparing for clean exit.")%(signum))
            try:
                try:
                    os.kill(pid, signal.SIGKILL)
                # signalHandler may also be called after everything has been
                # completed successfully
                except:
                    pass
                # in case of cloning
                if lvmsource and lvmdestination:
                    if signum != 0:
                        removeVolume(dst_volume,dst_group)
                if lvmsource and copy_from_snapshot:
                    removeVolume(snapshotname,src_group)
                # if we were performing a revert
                elif not lvmsource and lvmdestination:
                    if uncompress and not source.endswith('.gz') and \
                       os.path.exists(source):
                        os.unlink(source)
                # performing a backup
                elif lvmsource and not lvmdestination:
                    if compress and signum != 0:
                        if os.path.exists("%s.gz" %destination):
                            os.unlink("%s.gz" %destination)
                    if os.path.exists(destination):
                        os.unlink(destination)
                    info('Removing volume %s/%s'%(src_volume,src_group))
                    removeVolume(src_volume,src_group)
                if signum != 0:
                    for removable in remove_on_failure:
                        if os.path.exists(removable):
                            if __isLVMVolume(removable):
                                rv = removable.split('/')[-1]
                                rg = removable.split('/')[-2]
                                removeVolume(rv, rg)
                            else:
                                try:
                                    os.unlink(removable)
                                except OSError:
                                    pass
                    if callback:
                        callback(False,**callback_args)
                    __removePIDFile(pidname)
                    sys.exit(signum)
            except Exception:
                sys.exit(1)
    
        ret = __ddReadStatus(dd_source,pid,size,current,total)
        current += 1
    
        # Intercept lots of signals
        for sig in __SIGNALS:
            signal.signal(sig,signalHandler)
    
        if ret != 0:
            info(_("Command dd exited with status %s." %ret))
            signalHandler(ret,None)
        if uncompress:
            os.unlink(source)
        if compress:
            info(_("Compressing backup file %s.") %destination)
            p = pexpect.spawn('/usr/local/bin/gzip-progress -1 %s'%destination, timeout=60*60*5)
            while True:
                index = p.expect(['minutes','Done.','Failed.',pexpect.TIMEOUT,pexpect.EOF])
                if index == 0:
                    progress, eta = p.before.split(',')
                    progress = progress.split(' ')[-1]
                    eta = eta.strip().split(' ')[-1]
                    info(_("Compressing backup %d of %d: %s done. %s minutes remaining.") %(current-1,total,progress,eta))
                elif index == 2 or index == 3:
                    signalHandler(0,None)
                    if callback:
                        callback(False,**callback_args)
                    return False
                elif index == 4 or index == 1:
                    p.close()
                    ret = p.exitstatus
                    if ret == None:
                        ret = 0
                    signalHandler(ret,None)
                    if ret != 0:
                        if callback:
                            callback(False,**callback_args)
                        return False
                    break
        else:
            signalHandler(0,None)
    __removePIDFile(pidname)
    if callback:
        callback(True,**callback_args)
    info(_('Done.'))
    return True

def backupVolumes(volumes,pidname,volumegroup=__VOLUME_GROUP,
                 callback=None,**callback_args):
    if not __createPIDFile(pidname):
        info(_("A process is already working on this logical volume. Quitting."))
        if callback:
            callback(False,**callback_args)
        return False

    freespace = getFreeGroupSpace(volumegroup)
    if freespace <= __SNAPSHOT_SIZE:
        if callback:
            callback(False,**callback_args)
        return LVM_ERROR_NO_SPACE

    volumes_for_dd = []
    for volume in volumes:
        newvolume = deepcopy(volume)
        newvolume['destination'] = volume.get('backup')
        newvolume['source'] = volume.get('volume')
        newvolume['copy_from_snapshot'] = True
        newvolume['remove_source_on_failure'] = False
        newvolume['remove_destination_on_failure'] = True
        vg = volume.get('volume').split('/')[-2]
        lv = volume.get('volume').split('/')[-1]
        newvolume['size'] = getVolumeSize(lv, vg)
        volumes_for_dd.append(newvolume)

    __ddWithStatus(volumes_for_dd,
                   pidname,
                   callback=callback,
                   **callback_args)
    return True


def revertToBackups(volumes,pidname,volumegroup=__VOLUME_GROUP,
                     callback=None,**callback_args):
    '''
    Reverts LVM volumes to a previously created snapshot.
    '''
    if not __createPIDFile(pidname):
        info(_("A process is already working on this logical volume. Quitting."))
        if callback:
            callback(False,**callback_args)
        return False

    volumes_for_dd = []
    for volume in volumes:
        newvolume = deepcopy(volume)
        newvolume['source'] = volume.get('backup')
        newvolume['destination'] = volume.get('volume')
        newvolume['remove_source_on_failure'] = False
        newvolume['remove_destination_on_failure'] = False
        newvolume['size'] = getVolumeSize(volume.get('volume'), volumegroup)
        volumes_for_dd.append(newvolume)

    __ddWithStatus(volumes_for_dd,
                   pidname,
                   callback,
                   **callback_args)
    return True

def cloneVolumeFromBackup(source,
                          destination,
                          disksize,
                          pidname,
                          volumegroup=__VOLUME_GROUP,
                          callback=None,
                          **callback_args):
    '''
    Clones LVM volumes from backup and calls a callback function at the end.
    '''

    if not __createPIDFile(pidname):
        info(_("A process is already working on this logical volume. Quitting."))
        if callback:
            callback(False,**callback_args)
        return False
    
    volumes_for_dd = []
    newvolume = {}
    newvolume['copy_from_snapshot'] = True
    newvolume['create_destination'] = True
    newvolume['remove_source_on_failure'] = False
    newvolume['remove_destination_on_failure'] = True
    newvolume['size'] = disksize
    newvolume['source'] = source
    newvolume['destination'] = destination
    volumes_for_dd.append(newvolume)
    
    if (disksize + __SNAPSHOT_SIZE) >= getFreeGroupSpace(volumegroup):
        if callback:
            callback(False,**callback_args)
        __removePIDFile(pidname)
        return LVM_ERROR_NO_SPACE
    
    __ddWithStatus(volumes_for_dd,
                   pidname,
                   callback,
                   **callback_args)
    return True

def cloneVolumes(volumes,pidname,volumegroup=__VOLUME_GROUP,
                 callback=None,**callback_args):
    '''
    Clones LVM volumes and calls a callback function at the end.
    '''

    if not __createPIDFile(pidname):
        info(_("A process is already working on this logical volume. Quitting."))
        if callback:
            callback(False,**callback_args)
        return False

    volumes_for_dd = []
    sizeall = 0
    for volume in volumes:
        size = getVolumeSize(volume.get('original'))
        newvolume = deepcopy(volume)
        newvolume['copy_from_snapshot'] = True
        newvolume['create_destination'] = True
        newvolume['remove_source_on_failure'] = False
        newvolume['remove_destination_on_failure'] = True
        newvolume['size'] = size
        newvolume['source'] = '/dev/%s/%s' %(volumegroup,volume.get('original'))
        newvolume['destination'] = '/dev/%s/%s' %(volumegroup,volume.get('clone'))
        volumes_for_dd.append(newvolume)
        sizeall = sizeall + size

    if (sizeall + __SNAPSHOT_SIZE) >= getFreeGroupSpace(volumegroup):
        if callback:
            callback(False,**callback_args)
        __removePIDFile(pidname)
        return LVM_ERROR_NO_SPACE

    __ddWithStatus(volumes_for_dd,
                   pidname,
                   callback,
                   **callback_args)
    return True

def getFreeGroupSpace(volumegroup=__VOLUME_GROUP):
    '''
    Returns the free space in a volume group in megabytes.
    '''
    p = subprocess.Popen(['/usr/sbin/vgs',
                           '--noheadings',
                           '--nosuffix',
                           '--units',
                           'm',
                           '-o',
                           'vg_free',
                           volumegroup],
                          stderr=subprocess.PIPE,
                          stdout=subprocess.PIPE)
    output = p.communicate()[0].strip()
    ret = p.returncode
    if ret != 0:
        return 0
    size = float(output)
    return size

def getGroupSize(volumegroup=__VOLUME_GROUP):
    '''
    Returns the size of a volume group in megabytes.
    '''
    p = subprocess.Popen(['/usr/sbin/vgs',
                          '--noheadings',
                          '--nosuffix',
                          '--units',
                          'm',
                          '-o',
                          'vg_size',
                          volumegroup],
                         stderr=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    output = p.communicate()[0].strip()
    ret = p.returncode
    if ret != 0:
        return 0
    size = float(output)
    return size

def getVolumeSize(volumename,volumegroup=__VOLUME_GROUP):
    '''
    Returns the volume size in megabytes.
    '''
    p = subprocess.Popen(['/usr/sbin/lvs',
                          '--noheadings',
                          '--nosuffix',
                          '--units',
                          'm',
                          '-o',
                          'lv_size',
                          '/dev/%s/%s'%(volumegroup,volumename)],
                         stderr=subprocess.PIPE,
                         stdout=subprocess.PIPE)
    output = p.communicate()[0].strip()
    ret = p.returncode
    if ret != 0:
        return 0
    size = float(output)
    return size

def getVolumeList(volumegroup=__VOLUME_GROUP):
    '''
    Returns a list of volume names of a volume group
    '''
    p = subprocess.Popen(['/usr/sbin/lvs',
                          volumegroup],
                          stderr=subprocess.PIPE,
                          stdout=subprocess.PIPE)
    output = p.communicate()[0].strip()
    ret = p.returncode
    if ret != 0:
        return []
    volume_names = []
    for volume_info in output.split("\n")[1:]:
        volume_names.append(volume_info.lstrip().split(" ")[0])
    return volume_names

def __createPIDFile(volumename):
    '''
    Create a PID file for a certain LVM volume to indicate that there is work
    going on. Return True if successful otherwise False.
    '''
    pidfile = __getPIDFileName(volumename)
    if not os.path.exists(pidfile):
        f = open(pidfile,'w')
        f.write(str(os.getpid()))
        f.close()
        return True
    info("PID file already exists. Not creating a new one.")
    return False

def __removePIDFile(volumename):
    '''
    Remove the PID file for a certain LVM volume once the work is done.
    Return True if successful otherwise False.
    '''
    pidfile = __getPIDFileName(volumename)
    if os.path.exists(pidfile):
        os.remove(pidfile)
        return True
    return False

def __getPIDFileName(volumename):
    '''
    Return a PID filename for an LVM volume. Always use the same filename
    for the same volume to be able to find out whether the volume is already
    being used.
    '''
    pidfilename = '/var/run/lvm-backup-%s.pid' %volumename
    return pidfilename

def __isLVMVolume(path):
    '''
    Check whether a file is an LVM volume device file.
    ** NEEDS TO BE IMPROVED **
    '''
    if path.startswith('/dev/'):
        return True
    return False
