#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2015 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# +--------------------------------------------------------------------------+
#

__author__ = "Andrea Boomi <a.bonomi@endian.com>"
__date__ = "2015-05-29"

"""
Time based One Time Password
"""

import os
import sys
import time
import struct
import hmac
from base64 import b32encode, b32decode
from hashlib import sha1

__all__ = [
    'get_one_time_password',
    'check_one_time_password',
    'generate_secret',
]

INTERVAL = 30
SECRET_LENGTH = 20

if sys.version_info < (2, 5, 0):

    class Algorithm(object):

        def __init__(self, which):
            self.which = which
            self.digest_size = self.which().digest_size

        def new(self, *args, **kwargs):
            return self.which(*args, **kwargs)

    sha1 = Algorithm(sha1)


def get_one_time_password(secret, timestamp=None, interval=None):
    """
    Generate a One Time Pasword token

    :param secret: secret key
    :type secret: str (base32 encoded)
    :param timestamp: optional unix time
    :type timestamp: long
    :param interval: optional interval length in seconds (default 30)
    :type interval: int
    :return: the generated token
    :rtype: str
    """
    try:
        secret = secret + "=" * (8 - (len(secret) % 8 or 8))
        key = b32decode(secret, casefold=True)
    except:
        raise ValueError('Invalid secret - must be base32 encoded')
    if timestamp is None:
        timestamp = time.time()
    message = int(timestamp / (interval or INTERVAL))
    hash = hmac.new(key, struct.pack('>Q', message), sha1).digest()
    offset = ord(hash[19]) & 15
    truncated_hash = hash[offset:offset + 4] # 4 bytes starting at the offset  
    code = (struct.unpack('>I', truncated_hash)[0] & 0x7fffffff) # Set the first bit of truncatedHash to zero
    code = code % 1000000
    return str(code).zfill(6) #  pad code with 0 until length of code is 6


def check_one_time_password(secret, token, timestamp=None, interval=None, back_to_the_future=0):
    """
    Check the token validity

    :param secret: secret key (base32 encoded)
    :type secret: str
    :param token: token
    :type token: str
    :param timestamp: optional unix time
    :type timestamp: long
    :param interval: optional interval length in seconds (default 30)
    :type interval: int
    :param back_to_the_future: optional check the last n tokens (default 0)
    :type back_to_the_future: int
    :return: returns True if the token is valid
    :rtype: bool
    """
    try:
        from endian.core import logger
        if interval is None:
            interval = INTERVAL
        if timestamp is None:
            timestamp = time.time()
        for i in range(0, back_to_the_future + 1):
            if get_one_time_password(secret, timestamp=timestamp - i * interval, interval=interval) == token:
                return True
        return False
    except Exception, ex:
        logger.info(ex, exc_info=True)
        return False

def generate_secret(length=None):
    """
    Generate a One Time Password secret key

    :param length: optional secret length in bytes
    :type length: int
    :return: secret key (base32 encoded)
    :rtype: str
    """
    return b32encode(os.urandom(length or SECRET_LENGTH))

