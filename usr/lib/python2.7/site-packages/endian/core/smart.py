#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import os
import re
import pexpect
from endian.core import logger

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2010-08-07"


class SmartManager(object):
    """
    ... autoclass::: SmartManager
        Interface for the Smart Package Manager
    """
    
    _log = None
    _proxy = None
    
    def __init__(self, log=None, proxy=None):
        if log:
            self._log = log
        else:
            self._log = logger
        self._proxy = proxy
        # Create the /var/cache/en directory, required by 'smart .... --interface endian'
        try:
            os.mkdir("/var/cache/en")
        except:
            pass

    def _create_cmd(self, cmd, interface=None):
        """ Create the smart command line """
        result = []
        result.append("smart")
        if self._proxy:
            result.append("-o http-proxy=%s" % self._proxy)
        if interface:
            result.append("--interface=%s" % interface)
        result.append(cmd)
        return " ".join(result)

    def get_channel(self, channel_alias):
        """
        ... autofunction::: get_channel
            Returns a channel by its alias
            :param channel_alias: channel alias, e.g. 'rpm-sys', 'efw2.3-base'
            :type channel_alias: string
            :return: channel info as a dictionary, e.g. {'baseurl': 'http://...', 'name': 'AAA BBB', 'type': 'rpm-md'} or None
            :rtype: dict            
        """
        return self.channel_list().get(channel_alias, None)

    def channel_list(self):
        """
        ... autofunction::: channel_list
            Returns the output of 'smart channel --show' as a dictionary, e.g.
                {
                    'rpm-sys': {'type': 'rpm-sys', 'name': 'RPM System'},
                    'aaabbbb': {'baseurl': 'http://...', 'name': 'AAA BBB', 'type': 'rpm-md'}
                }
            :return: channel list
            :rtype: dict
        """
        child = pexpect.spawn("smart channel --show")
        lines = child.readlines()
        result = {}
        channel_alias = None
        for line in lines:
            try:
                line = line[0:-2] # remove cr/lf
                # (note that lines are terminated by CR/LF (\r\n) combination even on
                # UNIX-like systems because this is the standard for pseudo ttys.)
                if line.startswith('['):
                    channel_alias = line[1:-1]
                    result[channel_alias] = {}
                else:
                    (attribute, value) = re.split('\s*=\s*', line, 1)
                    result[channel_alias][attribute] = value
            except:
                pass
        return result

    def remove_channel(self, channel_alias):
        """
        ... autofunction::: remove_channel
            Remove a channel by its alias
            :param channel_alias: channel alias, e.g. 'rpm-sys', 'efw2.3-base'
            :type channel_alias: string
            :return: True if ok, False if channel not found
            :rtype: boolean            
        """
        self._log.info("Remove channel %s" % channel_alias)
        cmd = self._create_cmd("channel --remove %s -y" % channel_alias)
        child = pexpect.spawn(cmd)
        index = child.expect (['.*not found.*', pexpect.EOF, pexpect.TIMEOUT])
        return index == 1

    def add_channel(self, channel_alias, url, name, type):
        """
        ... autofunction::: add_channel
            Add a channel. If the channel exists, first delete the old channel
            :param channel_alias: channel alias, e.g. 'rpm-sys', 'efw2.3-base'
            :type channel_alias: string
            :param url: channel url
            :type url: string
            :param name: name, e.g. 'Endian Firewall 2.3' 
            :type name: string
            :param type: type, e.g. 'rpm-md'
            :type type: string
            :return: True if ok, False if channel not found
            :rtype: boolean            
        """
        if self.get_channel(channel_alias):
            self.remove_channel(channel_alias)
            
        self._log.info("Add channel %s" % channel_alias)
        cmd = self._create_cmd('channel --add "%s" baseurl="%s" name="%s" type="%s" -y' % (channel_alias, url, name, type))
        child = pexpect.spawn(cmd)
        
        index = child.expect (['.*is already in use*', 'error.*', pexpect.EOF, pexpect.TIMEOUT])
        return index == 2

    def update(self, interface="endian"):
        """
        ... autofunction::: update
            Exec the 'smart update' command
            :return: True if no error, False otherwise
            :rtype: boolean
        """
        self._log.info("Update channels information")
        cmd = self._create_cmd("update", interface=interface)
        child = pexpect.spawn(cmd, timeout=60*30)
        index = child.expect (['error.*', pexpect.EOF, pexpect.TIMEOUT])
        return index == 2

    def install_package(self, package_name, interface="endian"):
        """
        ... autofunction::: install_package
            Install a package
            :param package_name: package name
            :type package_name: string
            :return: True if no error, False otherwise
            :rtype: boolean
        """
        self._log.info("Install package %s" % package_name)
        cmd = self._create_cmd("install %s -y" % package_name, interface=interface)
        child = pexpect.spawn(cmd, timeout=60*30)
        lines = child.readlines()
        for line in lines:
            if 'error:' in line:
                return False
        return True
    
    def remove_package(self, package_name, interface="endian"):
        """
        ... autofunction::: remove_package
            Remove a package
            :param package_name: package name
            :type package_name: string
            :return: True if no error, False otherwise
            :rtype: boolean
        """
        self._log.info("Remove package %s" % package_name)
        cmd = self._create_cmd("remove %s -y" % package_name, interface=interface)
        child = pexpect.spawn(cmd, timeout=60*30)
        lines = child.readlines()
        for line in lines:
            if 'error:' in line:
                return False
        return True

    def updatable_packages(self, interface="endian"):
        """
        ... autofunction::: updatable_packages
            Return the number of updatable packages
            :return: The number of updatable packages
            :rtype: int
        """
        self._log.info("Get number of updatable packages")
        cmd = self._create_cmd("upgrade --url -y", interface=interface)
        child = pexpect.spawn(cmd, timeout=60*30)
        lines = child.readlines()
        counter = 0
        for line in lines:
            if 'http://' in line or 'https://' in line:
                counter = counter + 1
        return counter
        
if __name__ == '__main__':
    import pprint
    sm = SmartManager()
    pprint.pprint(sm.channel_list())
    #pprint.pprint(sm.get_channel('commtouch'))
    #pprint.pprint(sm.get_channel('xyz'))
    #pprint.pprint(sm.add_channel('test', url='http://localhost/1234', name='test', type='rpm-md'))
    #pprint.pprint(sm.remove_channel('test'))
    #pprint.pprint(sm.update())
    #pprint.pprint(sm.install_package('endian-client'))
    pprint.pprint(sm.updatable_packages())
