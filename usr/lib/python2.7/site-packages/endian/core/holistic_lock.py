#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2015 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2013-03-06"

__all__ = ['HolisticLock']

import os
import fcntl
import time 
import threading

# _master_lock is used for populating _locks
_master_lock = threading.Lock()
# map filename to Lock
_locks = {}

class HolisticLock(object):
    """
        'Holistic' lock, works for both multiprocess and multithreads locking 
    """

    def __init__(self, filename):
        """
            Create an holistic (not reentrant) lock

            :param filename: lock file name
            :type filename: string
        """
        self.filename = filename
        if not self.filename in _locks:
            try:
                _master_lock.acquire()
                if not self.filename in _locks:
                    _locks[self.filename] = threading.Lock()
            finally:
                _master_lock.release()
        self.f = None
 
    def acquire(self):
        """
            Acquire a blocking lock.
        """
        _locks[self.filename].acquire()
        while True:
            try:
                self.f = os.open(self.filename, os.O_CREAT | os.O_RDWR)
            except:
                time.sleep(0.001)
                continue # retry
            try:
                os.chmod(self.filename, 0666)
            except:
                os.close(self.f)
                time.sleep(0.001)
                continue # retry
            fcntl.lockf(self.f, fcntl.LOCK_EX)
            try:
                # Compare the inode number of the opened file an the file on disk
                # If the inodes are different, another process creates a lock file
                # http://stackoverflow.com/questions/17708885/flock-removing-locked-file-without-race-condition
                if os.fstat(self.f).st_ino == os.stat(self.filename).st_ino:
                    break
            except:
                pass
            os.close(self.f)
 
    def release(self):
        """
            Release a lock.
        """
        if self.f is None:
            raise threading.ThreadError()
        try:
            os.unlink(self.filename)
        except:
            pass
        fcntl.lockf(self.f, fcntl.LOCK_UN)
        os.close(self.f)
        _locks[self.filename].release()

