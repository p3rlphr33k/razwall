#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

"""
The endian logger module creates a pre-configured default logger.

Once the logger module will be loaded using

from endian.core.logger import *

the functions debug(), info(), warn(), critical() and error()
are defined and can be used without configuration and without
instantiation.
Those functions use the default logger instance which is stored
in ''logger''.

The default logger automatically use the current program name
as log name and logs to both console and syslog handlers.

The default facility for the syslog handler is LOCAL4 and logs
through ''/dev/log''.

Per default all log messages will be forwarded to the handlers.
If you would like to change this behaviour, use
logger.setLevel() in order to set the minimum log level.

A special log level has been implemented: ''DEVELDEBUG''
Once set, it enables logging of filename:function:lineno of where
the log call came from.

Special behaviour:
* info() and error() use the notification framework in order to
  communicate with the ajax notification interface.
* debug() adds the caller-frame to the log-name.
* syslog handler splits messages containing multiple lines and
  sends one syslog message per line. Traceback's captured with
  exc_info=True will also be splitted in multiple lines.

"""

import logging
import logging.handlers
import os
import sys
from socket import error as SocketError

__formatter = None

logger = None
"""Default logger to which buildin logging functions are bound"""

DEVELDEBUG = 5
"""DEBUG log level which enables logging of caller filename:function:lineno"""

from logging import DEBUG, INFO, WARNING, ERROR

logString = {
    'DEBUG': DEBUG,
    'DEVELDEBUG': DEVELDEBUG,
    'INFO': INFO,
    'WARNING': WARNING,
    'ERROR': ERROR,
    }

def setLogfile(f):
    """
    Defines file ''f'' as logfile. All other log handlers
    will be disabled. It will only be logged to this file

    @type  f: string
    @param f: The filename
    """
    logger.handler['file'] = logging.FileHandler(f)
    fh = logger.handler['file']
    fh.setFormatter(__formatter)
    fh.setLevel(logging.DEBUG)
    logger.addHandler(fh)
    for i in logger.handler:
        if i == 'file':
            continue
        logger.removeHandler(logger.handler[i])

def reopenLogfile():
    """
    If the file handler is active (setLogfile) called before),
    this function reopen's the file. This can be used to reopen
    the logfile after SIGHUP has been caught, which may happen
    while log rotation.

    Does nothing if setLogFile() has not been called before.
    """
    fh = logger.handler['file']
    if fh == None:
        return
    oldstream = fh.stream
    fh.stream = open(fh.stream.name, 'a+')
    oldstream.close()

def disableLogHandler(id):
    """
    Disables the specified log handler.

    @type  id: string
    @param id: The log handler id. Valid id's are:
               'file', 'syslog', 'console'
    """
    handler = logger.handler[id]
    logger.removeHandler(handler)

def enableLogHandler(id):
    """
    Enables the specified log handler.

    @type  id: string
    @param id: The log handler id. Valid id's are:
               'file', 'syslog', 'console'
    """
    handler = logger.handler[id]
    logger.addHandler(handler)


def logname(name):
    """Sets the name for a log section and should be called
    at the top of a method."""
    if not globals().has_key("logger"):
        return

    # separator need to be '/'. syslog uses it to split away
    # from the real program name. Otherwise program() match of
    # syslog-ng would not match a program.service combination
    global logger
    logger.name = "%s/%s" % (logger.name_prefix, name)

def enable_notifications(servicename):
    """Post log messages of type info and error to the notification service"""
    logger.enable_notifications(servicename)
    import atexit
    atexit.register(end_notifications)

def end_notifications():
    logger.end_notifications()

currentframe = sys._getframe

class MultiLineSysLogHandler(logging.handlers.SysLogHandler):
    unixsocket = 0 # Avoid "MultiLineSysLogHandler instance has no attribute 'unixsocket'"
    __doc__ = logging.handlers.SysLogHandler.__doc__
    def emit(self, record):
        """
        Emit a record. Splits multilines in a record per line.
        Gets also rid of Tracebacks in order to have them splitted
        to one line per record.
        """
        if record.exc_info:
            # Cache the traceback text to avoid converting it multiple times
            # (it's constant anyway)
            if not record.exc_text:
                record.exc_text = self.formatException(record.exc_info)
            del record.exc_info
        split = []
        try:
            split = record.msg.split("\n")
        except AttributeError:
            split = [record.msg]
        try:
            if record.exc_info:
                split.extend(record.exc_text.split("\n"))
        except AttributeError:
            pass
        records = []
        for line in split:
            item = EndianLogRecord(
                record.name,
                record.levelno,
                record.pathname,
                record.lineno,
                record.function,
                line,
                record.args,
                False
                )
            records.append(item)
        for i in records:
            logging.handlers.SysLogHandler.emit(self, i)

class EndianLogRecord(logging.LogRecord):
    __doc__ = logging.LogRecord.__doc__
    def __init__(self, name, level, pathname, lineno, func, msg, args, exc_info):
        logging.LogRecord.__init__(self, name, level, pathname, lineno, msg, args, exc_info)
        self.function = func

class EndianLogger(logging.Logger):
    __doc__ = logging.Logger.__doc__
    def __init__(self, name, level=logging.NOTSET, name_prefix=None):
        logging.Logger.__init__(self, name, level)
        self.__notification_service = None
        self.handler = {}
        self.name_prefix = name_prefix or name
    def info(self, msg, *args, **kw):
        """
        Log 'msg % args' with severity 'INFO' and passes the message also
        to the endian ajax notification framework.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.info("Houston, we have a %s", "interesting problem", exc_info=1)
        """
        logging.Logger.info(self, msg, *args, **kw)
        if self.__notification_service:
            self.__notification_service.update(msg)
    def error(self, msg, *args, **kw):
        """
        Log 'msg % args' with severity 'ERROR' and passes the message also
        to the endian ajax notification framework.

        To pass exception information, use the keyword argument exc_info with
        a true value, e.g.

        logger.error("Houston, we have a %s", "major problem", exc_info=1)
        """
        logging.Logger.error(self, msg, *args, **kw)
        if self.__notification_service:
            self.__notification_service.error(msg)
    def makeRecord(self, name, level, fn, lno, msg, args, exc_info, func=None, extra=None):
        fnn, lnon, func = self.findCaller()
        r = EndianLogRecord(name, level, fnn, lnon, func, msg, args, exc_info)
        return r
    def setLevel(self, level):
        """
        Set the logging level of this logger.

        If the level is set to DEVELDEBUG, caller filename:function:lineno
        will be prefixed to each log message.
        """
        if level != DEVELDEBUG:
            logging.Logger.setLevel(self, level)
            return
        logging.Logger.setLevel(self, logging.DEBUG)
        shf = logging.Formatter("%(name)s[%(process)s]: %(pathname)s:%(function)s:%(lineno)d: %(message)s")
        for i in self.handlers:
            i.setFormatter(shf)
    def findCaller(self):
        f = currentframe().f_back
        rv = "(unknown file)", 0, "(unknown function)"
        while hasattr(f, "f_code"):
            co = f.f_code
            filename = os.path.normcase(co.co_filename)
            if (filename.find('/logging/') != -1 or
                filename.find('logger') != -1):
                f = f.f_back
                continue
            rv = (filename, f.f_lineno, co.co_name)
            break
        return rv
    def enable_notifications(self, servicename):
        """Post log messages of type info and error to the notification service"""
        from endian.core.notification import ServiceNotification
        self.__notification_service = ServiceNotification(servicename)
        # this info() is in order to create a valid json file rather than an
        # empty one, making the gui start the ajax polling
        info("Initializing notification for service '%s'" % servicename)
    def end_notifications(self):
        if self.__notification_service:
            self.__notification_service.end()
    @property
    def has_notification_service(self):
        """True if logger has notification service """
        return self.__notification_service != None

def create_logger(name=None, level=logging.NOTSET, name_prefix=None, log_format=None, log_formatter=None):
    global __formatter

    if not name:
        name = os.path.basename(sys.argv[0])
    logger = EndianLogger(name=name, level=level, name_prefix=name_prefix)
    if not __formatter:
        __formatter = logging.Formatter("%(asctime)s - %(name)s[%(process)s] - %(levelname)s - %(message)s")
    logger.setLevel(logging.INFO)

    # console handler
    ch = logging.StreamHandler()
    logger.handler['console'] = ch
    ch.setLevel(logging.DEBUG)
    if log_formatter:
        ch.setFormatter(log_formatter(log_format))
    elif log_format:
        ch.setFormatter(logging.Formatter(log_format))
    else:
        ch.setFormatter(__formatter)
    logger.addHandler(ch)

    # syslog handler - only if syslog is accessible
    try:
        sh = MultiLineSysLogHandler(
            facility=MultiLineSysLogHandler.LOG_LOCAL4,
            address='/dev/log')
        logger.handler['syslog'] = sh
        sh.setLevel(logging.DEBUG)
        shf = logging.Formatter("%(name)s[%(process)s]: %(message)s")
        sh.setFormatter(shf)
        logger.addHandler(sh)
    except SocketError:
        logger.debug("Could not connect to syslog!", exc_info=True)
        pass

    return logger

def configureLogger(options):
    if options.debug:
        logger.setLevel(logging.DEBUG)
    else:
        logger.setLevel(logging.INFO)

# Create default logger
logger = create_logger()
debug = logger.debug
info = logger.info
warn = logger.warning
error = logger.error
critical = logger.critical
log = logger.log

if __name__ == '__main__':
    debug("test")
    info("test")
    warn("test")
    error("test")
    critical("test")

    critical("test")
    disableLogHandler('console')
    disableLogHandler('console')
    critical("test")
    enableLogHandler('console')
    enableLogHandler('console')
    critical("test")

    setLogfile('testlogfile')
    debug("no console")
    enableLogHandler('console')
    debug("console and logfile")

    disableLogHandler('file')
