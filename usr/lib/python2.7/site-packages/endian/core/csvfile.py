#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#
#  settingsfile
#
#  Created by Peter Warassin on 2006-09-03.

import csv

class CSVFileException(Exception):
    def __init__(self, value):
        self.value = value
    def __str__(self):
        print repr(self.value)

def toclass(meta, cls, row, tolerant):
    if not tolerant:
        if len(meta) != len(row):
            raise CSVFileException("Row has to few fields compared with cLass meta information")
    obj = cls()
    for i in range(0,len(row)):
        name = meta[i]
        if tolerant:
            try:
                value = row[i]
            except IndexError:
                value = ''
        else:
            value = row[i]
        obj.__dict__[name] = value
    return obj

def todict(meta, obj):
    d = []
    for i in range(0, len(meta)):
        name = meta[i]
        d.append(obj.__dict__[name])
    return d
        

class CSVFile:
    def __init__(self, filename=None, obj=None, delimiter=',', tolerant=False):
        self.cls = obj.__class__
        if obj._meta == None:
	    raise CSVFileException("No class meta information found!")
        self.meta = obj._meta
        self.filename = filename
        self._data = []
        self._dialect = csv.excel()
        self._dialect.delimiter = delimiter
        self._tolerant = tolerant

    def load(self):
        """
        Loads the CSV file and populates a dictionary with representations of
        the supplied class containing the read data.
        """

        class SanitizedFile(file):
            def __init__(self, fname, mode='r'):
                file.__init__(self, fname, mode)
            def next(self):
                return file.next(self).replace("\r","")

        sfile=None
        try:
            sfile = SanitizedFile(self.filename, "r")
        except:
            return self
        i = csv.reader(sfile, self._dialect)
        for row in i:
            if len(row) <= 0:
                continue
            self._data.append(toclass(self.meta, self.cls, row, self._tolerant))
        sfile.close()
        return self

    def get(self, i):
        return self._data[i]

    def size(self):
        return len(self._data)

    def store(self, filename=None):
        """
        Stores the current configuration into a file
        
        If no filename is set then it uses the filename of currently opened
        file.
        """
	if not filename:
	    filename = self.filename

	outfile = open(filename, "w")
        out = csv.writer(outfile, self._dialect)
        if self._data == None:
            outfile.close()
            return True
        for i in self._data:
            row = todict(self.meta, i)
            out.writerow(row)
	outfile.close()
	return True
