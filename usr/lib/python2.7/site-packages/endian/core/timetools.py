#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.core.i18n import _
import re
import time
import datetime

__author__ = "Andrea Boomi <a.bonomi@endian.com>"
__date__ = "2010-05-05"

__all__ = [
    'ONE_DAY',
    'ONE_HOUR',
    'ONE_MIN',
    'ONE_SEC',
    'utcnow',
    'now',
    'timedelta',
    'format_time',
    'is_same_day',
    'get_timezone_tuple',
    'get_timezone_string',
    'datetime_from_ISO8601',
    'datetime_to_ISO8601',
    'utcdatetime_from_datetime',
    'utcdatetime_to_datetime',
    'datetime_from_timestamp',
    'datetime_to_timestamp'
]


"""
defines generic date/time utility functions
"""

seconds_per_minute = 60
seconds_per_hour = 3600
seconds_per_day = 86400
seconds_per_month = seconds_per_day * 30
seconds_per_years = seconds_per_day * 365

TIME_INTERVALS = [1,
                  seconds_per_minute,
                  seconds_per_hour,
                  seconds_per_day,
                  seconds_per_month,
                  seconds_per_years]

TIME_LABELS = [(_('second'), _('seconds')),
               (_('minute'), _('minutes')),
               (_('hour'),   _('hours')),
               (_('day'),    _('days')),
               (_('month'),  _('months')),
               (_('year'),   _('years'))]

SHORT_TIME_LABELS = [('s', 's'),
                     ('m', 'm'),
                     ('h', 'h'),
                     ('d', 'd'),
                     ('m', 'm'),
                     ('y', 'y')]
      
ONE_DAY = datetime.timedelta(days=1)
ONE_HOUR = datetime.timedelta(hours=1)
ONE_MIN = datetime.timedelta(minutes=1)
ONE_SEC = datetime.timedelta(seconds=1)

ISO8601_REGEX = re.compile(r"(?P<year>[0-9]{4})(-(?P<month>[0-9]{1,2})(-(?P<day>[0-9]{1,2})"
    r"((?P<separator>.)(?P<hour>[0-9]{2}):(?P<minute>[0-9]{2})(:(?P<second>[0-9]{2})(\.(?P<fraction>[0-9]+))?)?"
    r"(?P<timezone>Z|(([-+])([0-9]{2}):([0-9]{2})))?)?)?)?"
)

utcnow = datetime.datetime.utcnow
now = datetime.datetime.now
timedelta = datetime.timedelta

def format_time(seconds=0, days=0, hide_seconds=False, abbreviate=False, short_labels=False):
    """
       Format a temporal interval in a human readable format

        :param seconds:      number of seconds
        :type seconds:       integer
        :param days:         number of days
        :type days:          integer
        :param hide_seconds: if true, don't display the seconds
        :type hide_seconds:  boolean
        :param abbreviate:   if true, hide the secconds if the temporal interval is longer than one day
                             and hide the seconds, minutes and hours if it is longer than one month
        :type abbreviate:    boolean
        :param short_labels: if true, use short labels
        :type short_labels:  boolean
        :return:             the formatted temporal interval
        :rtype:              str
    """
    seconds = seconds + days * seconds_per_day
    negative = seconds < 0
    seconds = abs(seconds)
    empty = True
    cut = -1
    if hide_seconds:
        cut = 0
    if abbreviate:
        if seconds >= seconds_per_month:
            cut = 2
        elif seconds >= seconds_per_day:
            cut = 0
    result = []
    labels = short_labels and SHORT_TIME_LABELS or TIME_LABELS
    for i in range(len(labels)-1, -1, -1):
        if i == cut:
            break
        interval = TIME_INTERVALS[i];
        a = seconds // interval
        if a > 0 or (i == 0 and empty) or (i == 1 and hide_seconds and empty):
            if negative:
                part = "-%d" % int(a)
            else:
                part = str(int(a))
            if not short_labels:
                part = part + ' '
            part = part + labels[i][a != 1 and 1 or 0]
            result.append(part)
            seconds -= a * interval
            empty = False
            
    return " ".join(result)

def is_same_day(date1, date2):
    """
       Checks if two dates are on the same day ignoring time.
    """
    if not date1 or not date2:
        return date1 == date2
    else:
        try:
            return date1.year == date2.year and date1.month ==  date2.month and date1.day == date2.day
        except:
            return False

def get_timezone_tuple():
    delta = datetime.datetime.now() - datetime.datetime.utcnow()
    hours, minutes = divmod((delta.days*24*60*60 + delta.seconds + 30) // 60, 60)
    return (hours, minutes)

def get_timezone_string():
    hours, minutes = get_timezone_tuple()
    return "%+03d:%02d" % (hours, minutes)

def datetime_from_ISO8601(datestring):
    """
      Parses ISO 8601 dates into datetime objects.
      The timezone is ignored, means we expect the ISO8601 datestring uses the local timezone.
      If you know that it is UTC and you want it to be local time, use utcdatetime_to_datetime.
    """
    m = ISO8601_REGEX.match(datestring)
    if not m:
        raise ValueError("Error parsing %s" % datestring)
    groups = m.groupdict()
    if groups["fraction"] is None:
        groups["fraction"] = 0
    else:
        groups["fraction"] = int(float("0.%s" % groups["fraction"]) * 1e6)
    datetime_object = datetime.datetime(int(groups["year"]), int(groups["month"]), int(groups["day"]),
        int(groups["hour"]), int(groups["minute"]), int(groups["second"]),
        int(groups["fraction"]))
    return datetime_object

def datetime_to_ISO8601(datetime_object):
    """
        convert datetime object to ISO 8601 with localtimezone
    """
    return "%s%s" % (datetime_object.isoformat(), get_timezone_string())

def utcdatetime_from_datetime(datetime_object):
    """
        convert datetime object with local timezone to utc datetime object
    """
    hours, minutes = get_timezone_tuple()
    if hours < 0:
        delta = datetime.timedelta(hours=-1*hours, minutes=minutes)
        utcdatetime_object = datetime_object + delta
    else:
        delta = datetime.timedelta(hours=hours, minutes=minutes)
        utcdatetime_object = datetime_object - delta
    return utcdatetime_object

def utcdatetime_to_datetime(utcdatetime_object):
    """
        convert utc datetime object into datetime object with local timezone
    """
    hours, minutes = get_timezone_tuple()
    if hours < 0:
        delta = datetime.timedelta(hours=-1*hours, minutes=minutes)
        datetime_object = utcdatetime_object - delta
    else:
        delta = datetime.timedelta(hours=hours, minutes=minutes)
        datetime_object = utcdatetime_object + delta
    return datetime_object

def datetime_from_timestamp(timestamp):
    """
        convert timestamp into datetime object
    """
    return datetime.datetime.fromtimestamp(float(timestamp))

def datetime_to_timestamp(datetime_object):
    """
        convert datetime object into timestamp
    """
    return time.mktime(datetime_object.timetuple())

if __name__ == '__main__':
    print "timetools"
    from random import randint
    for i in range(0, 10):
        x = randint(0, seconds_per_day*2)
        print "-"
        print x, format_time(x)
        print x, format_time(x, hide_seconds=True)
        print x, format_time(x, abbreviate=True)

    for i in range(0, 10):
        x = randint(0, seconds_per_years*2)
        print "-"
        print x, format_time(x)
        print x, format_time(x, hide_seconds=True)
        print x, format_time(x, abbreviate=True)
