#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

from endian.core.logger import debug, warn
from endian.datatypes.config_dict import ConfigDict
from endian.datatypes.network import CIDR
from endian.data.ds import DataSource

__all__ = ['cidrnet2nmnet',
           'hasLan2',
           'hasDmz',
           'getZones']

def cidrnet2nmnet(net):
    """
    Converts ip/cidr to ip/netmask

    @param net: netaddress in ip/cidr format
    @type net: string

    @returns netaddress in ip/netmask format
    """
    import iplib
    obj = iplib.CIDR(net)
    return "%s/%s"%(obj.get_network_ip().get(),obj.get_netmask().get())

def hasLan2():
    """
    checks if blue zone exists

    @returns boolean
    """
    netsettings = DataSource().ethernet.settings

    if int(netsettings['CONFIG_TYPE']) in [4,5,6,7]:
        return True
    return False

def hasDmz():
    """
    checks if orange zone exists

    @returns boolean
    """
    netsettings = DataSource().ethernet.settings

    if int(netsettings['CONFIG_TYPE']) in [1,3,5,7]:
        return True
    return False

def getZones():
    """
    reads zones and their settings for future support of datasource

    @returns boolean
    """
    netsettings = DataSource().ethernet.settings

    zones = ConfigDict()

    zonenames = ["LAN"]
    if hasLan2():
        zonenames.append("LAN2")
    if hasDmz():
        zonenames.append("DMZ")

    for zone in zonenames:
        settings = ConfigDict()
        for key, value in netsettings.iteritems():
            if key.startswith(zone):
                try:
                    settings[key.split("_")[1]] = value
                except:
                    debug("could not add key '%s'" % key)
        if 'IPS' in settings:
            subnets = settings["IPS"].split(",")
            ips = filter(lambda x: x not in [None, ''], subnets)
            subnets = map(lambda x: cidrnet2nmnet(x), ips)
            settings["IPS_ARR"] = subnets
            subnetsobj = []
            ipsobj = []
            settings['IPS_OBJ'] = subnetsobj
            settings['IPS_CIDR'] = ipsobj
            for i in subnets:
                try:
                    subnetsobj.append(CIDR(i))
                except ValueError:
                    warn("IPS value '%s' of zone '%s' is no valid ip/bits pair" %
                         (i, zone),
                         exc_info=True)
            for i in ips:
                try:
                    ipsobj.append(CIDR(i))
                except ValueError:
                    warn("IPS value '%s' of zone '%s' is no valid ip/bits pair" %
                         (i, zone),
                         exc_info=True)
        zones[zone] = ConfigDict()
        zones[zone]["SETTINGS"] = settings
        dev = settings["DEV"]
        zones[zone]["MEMBERS"] = DataSource("ethernet")[dev]

    return zones
