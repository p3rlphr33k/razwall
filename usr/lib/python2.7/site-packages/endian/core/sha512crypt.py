#!/usr/bin/env python
# encoding: utf-8
#
#    Based on Passlib SHA256/512-CRYPT
#
#    Passlib
#    Copyright (c) 2008-2011 Assurance Technologies, LLC.
#    All rights reserved.
#
#    Redistribution and use in source and binary forms, with or without
#    modification, are permitted provided that the following conditions are
#    met:
#
#    * Redistributions of source code must retain the above copyright
#      notice, this list of conditions and the following disclaimer.
#
#    * Redistributions in binary form must reproduce the above copyright
#      notice, this list of conditions and the following disclaimer in the
#      documentation and/or other materials provided with the distribution.
#
#    * Neither the name of Assurance Technologies, nor the names of the
#      contributors may be used to endorse or promote products derived
#      from this software without specific prior written permission.
#
#    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
#    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
#    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
#    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
#    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
#    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import random
from hashlib import sha512
import re

__all__ = [
    "sha512crypt",
]

SALT_SIZE = 16
INVALID_SALT_VALUES = "\x00$"
DEFAULT_ROUNDS = 5000
CHARS = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
CHARS_LEN = len(CHARS)
SHA512_OFFSETS = (
    42, 21, 0,  1,  43, 22, 23, 2,
    44, 45, 24, 3,  4,  46, 25, 26,
    5,  47, 48, 27, 6,  7,  49, 28,
    29, 8,  50, 51, 30, 9,  10, 52,
    31, 32, 11, 53, 54, 33, 12, 13,
    55, 34, 35, 14, 56, 57, 36, 15,
    16, 58, 37, 38, 17, 59, 60, 39,
    18, 19, 61, 40, 41, 20, 62, 63
)

def sha512crypt(word, salt=None, rounds=DEFAULT_ROUNDS):
    """
        The sha512crypt() function performs password encryption,
        based on the SHA-512 Crypt developed in 2008 by Ulrich Drepper.

        :param word:   the password to be encrypted
        :type word:    str or unicode
        :param salt:   an optional salt with characters in in the set [./a-zA-Z0-9]
                       or a full crypted password
        :type salt:    str or unicode
        :param rounds: optional number of rounds (must be > 1000, default is 5000)
        :type rounds:  int
        :return:       An sha512-crypt hash string has the format:
                       $6$[rounds=<ROUNDS>]$<SALT>$<PWD>
                       The default number of rounds (if omitted) is 5000.
        :rtype:        str
    """
    try:
        (rounds, salt, checksum, strict) = parse_sha512crypt(salt)
    except ValueError:
        salt = generate_random_salt()
    return raw_sha512_crypt(word, salt, rounds)

def raw_sha512_crypt(secret, salt, rounds=DEFAULT_ROUNDS):
    """
        Perform raw sha512 crypt

        :param secret: the password to be encrypted
        :type secret:  str or unicode
        :param salt:   salt string to use (required)
        :type salt:    str or unicode
        :param rounds: optional number of rounds (must be > 1000, default is 5000)
        :type rounds:  int
        :return:       An sha512-crypt hash string has the format:
                       $6$[rounds=<ROUNDS>]$<SALT>$<PWD>
                       The default number of rounds (if omitted) is 5000.
        :rtype:        str
    """
    #validate salt
    for c in INVALID_SALT_VALUES:
        if c in salt:
            raise ValueError("invalid chars in salt")
    if len(salt) > 16:
        salt = salt[:16]

    #init helpers
    def extend(source, size_ref):
        "helper which repeats <source> digest string until it's the same length as <size_ref> string"
        assert len(source) == chunk_size
        size = len(size_ref)
        return source * int(size/chunk_size) + source[:size % chunk_size]

    #calc digest B
    b = sha512(secret)
    chunk_size = b.digest_size #grab this once hash is created
    b.update(salt)
    a = b.copy() #make a copy to save a little time later
    b.update(secret)
    b_result = b.digest()
    b_extend = extend(b_result, secret)

    #begin digest A
    #a = sha512(secret) <- performed above
    #a.update(salt) <- performed above
    a.update(b_extend)

    #for each bit in slen, add B or SECRET
    value = len(secret)
    while value > 0:
        if value % 2:
            a.update(b_result)
        else:
            a.update(secret)
        value >>= 1

    #finish A
    a_result = a.digest()

    #calc DP - hash of password, extended to size of password
    dp = sha512(secret * len(secret))
    dp_result = extend(dp.digest(), secret)

    #calc DS - hash of salt, extended to size of salt
    ds = sha512(salt * (16+ord(a_result[0])))
    ds_result = extend(ds.digest(), salt) #aka 'S'

    #
    #calc digest C
    #NOTE: this has been contorted a little to allow pre-computing
    #some of the hashes. the original algorithm was that
    #each round generates digest composed of:
    #   if round%2>0 => dp else lr
    #   if round%3>0 => ds
    #   if round%7>0 => dp
    #   if round%2>0 => lr else dp
    #where lr is digest of the last round's hash (initially = a_result)
    #

    #pre-calculate some digests to speed up odd rounds
    dp_hash = sha512(dp_result).copy
    dp_ds_hash = sha512(dp_result + ds_result).copy
    dp_dp_hash = sha512(dp_result * 2).copy
    dp_ds_dp_hash = sha512(dp_result + ds_result + dp_result).copy

    #pre-calculate some strings to speed up even rounds
    ds_dp_result = ds_result + dp_result
    dp_dp_result = dp_result * 2
    ds_dp_dp_result = ds_result + dp_dp_result

    #run through rounds
    last_result = a_result
    i = 0
    while i < rounds:
        if i % 2:
            if i % 3:
                if i % 7:
                    c = dp_ds_dp_hash()
                else:
                    c = dp_ds_hash()
            elif i % 7:
                c = dp_dp_hash()
            else:
                c = dp_hash()
            c.update(last_result)
        else:
            c = sha512(last_result)
            if i % 3:
                if i % 7:
                    c.update(ds_dp_dp_result)
                else:
                    c.update(ds_dp_result)
            elif i % 7:
                c.update(dp_dp_result)
            else:
                c.update(dp_result)
        last_result = c.digest()
        i += 1

    ###encode result
    out = encode_transposed_bytes(last_result)
    if rounds == 5000:
        return "$6$%s$%s" % (salt, out or "")
    else:
        return "$6$rounds=%d$%s$%s" % (rounds, salt, out or "")

HASH_RE = re.compile(ur"""
        ^
        \$6
        (\$rounds=(?P<rounds>\d+))?
        \$
        (
            (?P<salt1>[^:$\n]*)
            |
            (?P<salt2>[^:$\n]{0,16})
            (
                \$
                (?P<chk>[A-Za-z0-9./]{86})?
            )?
        )
        $
        """, re.X)

def parse_sha512crypt(hash):
    """
        Parse a sha512 encrypted password

        :param hash:   A sha512-crypt hash string
        :type hash:    str or unicode
        :return:       A tuple (rounds, salt, checksum, strict)
        :rtype:        tuple
    """
    if not hash:
        raise ValueError("no hash specified")
    if isinstance(hash, str):
        hash = hash.decode("ascii")
    m = HASH_RE.match(hash)
    if not m:
        raise ValueError("invalid sha512-crypt hash")
    rounds, salt1, salt2, chk = m.group("rounds", "salt1", "salt2", "chk")
    if rounds and rounds.startswith("0"):
        raise ValueError("invalid sha512-crypt hash (zero-padded rounds)")
    try:
        rounds = int(rounds)
    except:
        rounds = 5000
    salt = salt1 or salt2
    checksum = chk
    strict = bool(chk)
    return (rounds, salt, checksum, strict)

_encode_6bit = CHARS.__getitem__

def encode_int12(value):
    "encodes 12-bit integer -> 2 char hash64 string (little-endian order)"
    #NOTE: this is optimized form of encode_int(value,2)
    return  _encode_6bit(value & 0x3f) + _encode_6bit((value>>6) & 0x3f)

def encode_int18(value):
    "encodes 18-bit integer -> 3 char hash64 string (little-endian order)"
    #NOTE: this is optimized form of encode_int(value,3)
    return (
        _encode_6bit(value & 0x3f) +
        _encode_6bit((value>>6) & 0x3f) +
        _encode_6bit((value>>12) & 0x3f)
        )

def encode_int24(value):
    "encodes 24-bit integer -> 4 char hash64 string (little-endian order)"
    #NOTE: this is optimized form of encode_int(value,4)
    return  _encode_6bit(value & 0x3f) + \
            _encode_6bit((value>>6) & 0x3f) + \
            _encode_6bit((value>>12) & 0x3f) + \
            _encode_6bit((value>>18) & 0x3f)

def _encode_bytes_helper(source):
    #FIXME: do something much more efficient here.
    # can't quite just use base64 and then translate chars,
    # since this scheme is little-endian.
    end = len(source)
    tail = end % 3
    end -= tail
    idx = 0
    while idx < end:
        v1 = ord(source[idx])
        v2 = ord(source[idx+1])
        v3 = ord(source[idx+2])
        yield encode_int24(v1 + (v2<<8) + (v3<<16))
        idx += 3
    if tail:
        v1 = ord(source[idx])
        if tail == 1:
            #NOTE: 4 msb of int are always 0
            yield encode_int12(v1)
        else:
            #NOTE: 2 msb of int are always 0
            v2 = ord(source[idx+1])
            yield encode_int18(v1 + (v2<<8))

def encode_transposed_bytes(source):
    """ Encode byte string to h64 format, using offset list to transpose elements """
    tmp = [source[off] for off in SHA512_OFFSETS]
    return "".join(_encode_bytes_helper(tmp))

def generate_random_salt():
    """ Generate a random salt string """
    def helper():
        value = random.randrange(0, CHARS_LEN**SALT_SIZE)
        i = 0
        while i < SALT_SIZE:
            yield CHARS[value % CHARS_LEN]
            value //= CHARS_LEN
            i += 1

    return "".join(helper())
