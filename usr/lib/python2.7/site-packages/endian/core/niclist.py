#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+


"""Produces DataSource compatible tree of available network interfaces with their configuration and assignements."""

import os
import simplejson
import subprocess
import endian.core.zones
from endian.core.i18n import _
from endian.data.ds import DataSource
from endian.datatypes.config_dict import ConfigDict
from endian.core.pdict import PersistentDict
from uplinksdaemon.uplinks.pool import UplinksPool
from endian.job.commons import to_bool


__all_ = [
    'get_system_nics',
    'get_default_wan',
    'get_vpn_devices',
    'get_nic_devices',
    'get_bond_devices',
    'get_vlan_devices',
    'get_zone_devices',
    'get_uplinks',
    'get_vpns',
    'get_nic_list',
    # Obsoletes
    'getZoneDevices'
    'getUplinks',
    'getNicList',
]

ETHCONFIG_INTERFACES_PATH = "/var/cache/ethconfig/interfaces.json"

_devices_cache = {}
ds = DataSource()

def register_device(name, obj):
    if name in _devices_cache:
        return
    _devices_cache[name] = obj

def get_device_by_name(name):
    return _devices_cache[name]

def clear_cache():
    _devices_cache.clear()

def sanitize_list(list):
    for iff in list:
        iff = iff.strip()
        if iff == '':
            continue
        yield(iff)

def get_system_nics(include_only_names=False):
    """
        Return the ethconfig info as dict or list (if include_only_names is True)

        :param include_only_names: if True, return only the names
        :type include_only_names: bool
        :return: a dict with 'businfo' and 'dev' keys or a list of names
        :type: dict or list
    """
    if not os.path.exists(ETHCONFIG_INTERFACES_PATH):
        subprocess.call(['ethconfig', '--json', '--output', ETHCONFIG_INTERFACES_PATH])
    with open(ETHCONFIG_INTERFACES_PATH) as f:
        data = simplejson.load(f)
        if include_only_names:
            return [x['iface'] for x in data]
        ret = {}
        ret['businfo'] = {}
        ret['dev'] = {}
        for nic in data:
            ret['businfo'][nic['businfo']] = nic
            ret['dev'][nic['iface']] = nic
        return ret

def get_default_wan():
    """
        Return the default WAN nic

        :return: default wan nic (e.g. eth3)
        :rtype: str
    """
    try:
        default_wan = ds.product.settings.default_wan
    except:
        default_wan = None
    # If the default WAN is not configured, return the last nic
    if not default_wan:
        default_wan = get_system_nics(include_only_names=True)[-1]
    return default_wan


def attribution(item, key, value, deep=True):
    if key in item and isinstance(item[key], list):
        if value not in item[key]:
            item[key].append(value)
    else:
        item[key] = value
    if 'MEMBERS' in item:
        for i in item['MEMBERS']:
            attribution(i, key, value)

def get_purle_devices():
    servers = DataSource("openvpn").server
    pd = PersistentDict('/var/cache/var.efw.vpn.servers')
    vpn_devices = set()
    for server in servers:
        if server.get('bridged') or not server.get('enabled'):
            continue
        vpn_devices = vpn_devices.union(pd.get(server['ID'], {}).get('vpn_devices', []))
    return list(vpn_devices)

def get_zone_devices():
    zones = endian.core.zones.getZones()
    for (zone, item) in zones.iteritems():
        zone = zone.upper()
        bridge_dev = item['SETTINGS']['DEV']
        members = []

        item['DEVICE'] = bridge_dev
        item['MEMBERS'] = members
        item['LOGICAL'] = zone
        item['ATTRIBUTES'] = ['isZone']
        item['PORT'] = -1
        item['SORTORDER'] = "A:%s" % zone

        # XXX: should be read out i18ned from settings['NAME'] later
        item['LABEL'] = _(zone)
        item['DESCRIPTION'] = item['LABEL']

        register_device(bridge_dev, item)
        attribution(item, 'ZONE', zone)

        bridgefile = ds.ethernet.get(bridge_dev, None)
        if bridgefile is None:
            # it's no bridge, so don't try to read out members
            continue

        for iffname in sanitize_list(bridgefile):
            try:
                dev = get_device_by_name(iffname)
                members.append(dev)
                desc = "%s [%s]" % (dev['LABEL'], item['LABEL'])
                attribution(dev, 'ATTRIBUTES', 'isAssigned')
                attribution(dev, 'ATTRIBUTES', 'isJoined')
                attribution(dev, 'ATTRIBUTES', 'isInterface', deep=False)
                attribution(dev, 'DESCRIPTION', desc, deep=False)
            except KeyError:
                # silently ignore unknown interfaces
                pass

    zones['wan'] = ConfigDict({
        'DEVICE': '',
        'MEMBERS': [],
        'LOGICAL': 'WAN',
        'ATTRIBUTES': ['isZone', 'isExplodeable'],
        'PORT': -1,
        'SORTORDER': 'A:WAN',
        'LABEL': _('WAN'),
        'DESCRIPTION': _('WAN'),
        'ZONE': 'WAN'
    })
    zones['vpn'] = ConfigDict({
        'DEVICE': '',
        'MEMBERS': [],
        'LOGICAL': 'VPN:ANY',
        'ATTRIBUTES': ['isZone', 'isExplodeable'],
        'PORT': -1,
        'SORTORDER': 'A:VPN',
        'LABEL': _('VPN'),
        'DESCRIPTION': _('VPN'),
        'ZONE': 'VPN'
    })

    return zones

def get_bond_devices():
    ret = {}
    for k in [x for x in ds.ethernet if x.startswith('BOND')]:
        bdev = k.lower()
        bnr = k[4:]
        members = []
        for iff in sanitize_list(ds.ethernet[k]):
            slave = ""
            try:
                slave = get_device_by_name(iff)
            except KeyError:
                # silently ignore unknown interfaces
                continue
            members.append(slave)
            attribution(slave, 'BOND', bdev)
            attribution(slave, 'ATTRIBUTES', 'isEnslaved')

        item = ConfigDict()
        item['DEVICE'] = bdev
        item['MEMBERS'] = members
        item['LOGICAL'] = "PHYSDEV:%s" % bdev
        item['ATTRIBUTES'] = ['isBond']
        item['LABEL'] = _("Bond %s", bnr)
        item['PORT'] = 0
        item['SORTORDER'] = "I:0.%02s" % (bnr)
        item['ZONE'] = ""
        ret[bdev] = item
        register_device(bdev, item)
    return ret

def get_vlan_devices():
    ret = {}
    for k in [x for x in ds.ethernet if x.startswith('VLAN_')]:
        physdev_name = k[5:].lower()
        physdev_obj = None
        try:
            physdev_obj = get_device_by_name(physdev_name)
        except KeyError:
            # Vlan definition file of unknown physical device.
            # ignore silently
            continue
        attribution(physdev_obj, 'ATTRIBUTES', 'hasVlans', deep=False)
        for vid in sanitize_list(ds.ethernet[k]):
            item = ConfigDict()
            vdev = "%s.%s" % (physdev_name, vid)
            item['DEVICE'] = vdev
            item['LOGICAL'] = "PHYSDEV:%s" % vdev
            item['PARENT'] = physdev_obj
            item['VID'] = vid
            item['ATTRIBUTES'] = ['isVlan']
            item['LABEL'] = _("VLAN %(vid)s on %(physdev)s",
                              {'vid': vid,
                               'physdev': physdev_obj['LABEL']
                               }
                              )
            item['PORT'] = physdev_obj['PORT']
            item['SORTORDER'] = "I:%02s.%04s" % (physdev_obj['PORT'], vid)
            item['ZONE'] = ""
            ret[vdev] = item
            register_device(vdev, item)
            if 'vlans' not in physdev_obj:
                physdev_obj['VLANS'] = []
            physdev_obj['VLANS'].append(vdev)

    return ret

def get_nic_devices():
    ret = {}
    d = get_system_nics()

    sort = []
    if ds.ethernet.fixed_nics is not None:
        sort = d['dev'].keys()
        sort.sort()
    else:
        orderby = d['businfo'].keys()
        orderby.sort()
        if ds.ethernet.reverse_nics is not None:
            orderby.sort(reverse=True)
        for i in orderby:
            sort.append(d['businfo'][i]['iface'])

    i = 1
    for key in sort:
        data = d['dev'][key]
        item = ConfigDict()
        dev = data['iface']
        item['DEVICE'] = dev
        item['LOGICAL'] = "PHYSDEV:%s" % dev
        item['PORT'] = i
        item['SORTORDER'] = "I:%02s" % i
        item['MAC'] = data['mac']
        item['BUSINFO'] = data['businfo']
        item['HARDWARE_DESCRIPTION'] = data['name']
        item['ATTRIBUTES'] = ['isNic']
        item['LABEL'] = _("Interface %(interface_number)s" % {'interface_number': i})
        item['DESCRIPTION'] = item['LABEL']
        item['ZONE'] = ""
        register_device(dev, item)
        ret[i] = item
        i += 1

    return ret

def get_uplinks():
    ret = {}
    for uplink in ds.uplinks:
        if 'SETTINGS' not in ds.uplinks[uplink]:
            continue
        settings = ds.uplinks[uplink]['SETTINGS']
        if len(settings) == 0:
            continue
        data = ds.uplinks[uplink].get('data', {})
        item = ConfigDict()
        item['UPLINK_ID'] = uplink
        uplink = uplink.lower()
        item['DEVICE'] = ''
        item['LOGICAL'] = "UPLINK:%s" % uplink
        item['PORT'] = -1
        item['SORTORDER'] = "U:%s" % uplink
        item['ATTRIBUTES'] = ['isUplink']
        label = settings.get('NAME', None)
        if label is None:
            label = uplink
        item['LABEL'] = _("Uplink %s", label)
        item['DESCRIPTION'] = item['LABEL']
        item['ZONE'] = "WAN"

        if settings.get('WAN_TYPE', None) in ['STATIC', 'DHCP', 'PPPOE', 'PPTP']:
            try:
                dev = get_device_by_name(settings['WAN_DEV'])
                item['DEVICE_DATA'] = dev
                item['DEVICE'] = dev['DEVICE']
                item['PORT'] = dev['PORT']
                attribution(dev, 'ATTRIBUTES', 'isAssigned')
                attribution(dev, 'ZONE', 'WAN')
            except:
                pass

        if settings.get('WAN_TYPE', None) in ['PPPOE', 'PPTP']:
            try:
                item['CHILD_DEVICE'] = data.get('interface')
                attribution(item, 'ATTRIBUTES', 'isParent')
            except:
                pass

        ret[uplink] = item

    return ret


def any_uplink_has_property(uplink_property):
    pool = UplinksPool()
    actives = pool.getActiveUplinks()

    for uplink in actives:
        settings = uplink.getSettings()
        if to_bool(settings.get(uplink_property, False)):
            return True
    return False


def get_vpns(include_ipsec=False):
    ret = {}

    clients = ds.openvpnclients
    if clients is None:
        clients = []
    for vpn in clients:
        if 'SETTINGS' not in ds.openvpnclients[vpn]:
            continue
        settings = ds.openvpnclients[vpn]['SETTINGS']
        if len(settings) == 0:
            continue
        if settings.get('DEVICE', None) is None:
            continue
        vpn = vpn.lower()

        item = ConfigDict()
        item['DEVICE'] = settings['DEVICE']
        item['LOGICAL'] = "VPN:%s" % vpn
        item['PORT'] = -1
        item['SORTORDER'] = "V:%s" % vpn
        item['ATTRIBUTES'] = ['isVPN']
        if settings.get('ROUTETYPE', 'routed') == 'bridged':
            attribution(item, 'ATTRIBUTES', 'isJoined')
        item['LABEL'] = _("VPN %s", settings['NAME'])
        item['DESCRIPTION'] = item['LABEL']
        item['ZONE'] = "VPN"
        attribution(item, 'ATTRIBUTES', 'isAssigned')
        ret[vpn] = item

    if include_ipsec:
        ret['IPSEC'] = ConfigDict({
            'DEVICE': 'ipsec+',
            'LOGICAL': 'VPN:IPSEC',
            'ATTRIBUTES': ['isAssigned', 'isVPN'],
            'PORT': -1,
            'SORTORDER': 'V:IPSEC',
            'LABEL': _("VPN %s", 'IPSEC'),
            'DESCRIPTION': _("VPN %s", 'IPSEC'),
            'ZONE': "VPN"
        })

    vpn_devices = get_purle_devices()
    if vpn_devices:
        ret['SERVER'] = ConfigDict({
            'DEVICE': vpn_devices,
            'MEMBERS': [],
            'LOGICAL': 'VPN:ANY',
            'ATTRIBUTES': ['isZone', 'isExplodeable'],
            'PORT': -1,
            'SORTORDER': 'A:VPN',
            'LABEL': _('VPN'),
            'DESCRIPTION': _('VPN'),
            'ZONE': 'VPN'
        })

    return ret

def get_nic_list(include_ipsec=False):
    clear_cache()
    ret = []
    nics = get_nic_devices()
    bonds = get_bond_devices()
    vlans = get_vlan_devices()
    zones = get_zone_devices()
    uplinks = get_uplinks()
    vpns = get_vpns(include_ipsec=include_ipsec)
    ret.extend(zones.values())
    ret.extend(bonds.values())
    ret.extend(nics.values())
    ret.extend(vlans.values())
    ret.extend(uplinks.values())
    ret.extend(vpns.values())
    ret.sort(cmp=lambda x,y: cmp(x.sortorder, y.sortorder))
    return ret

# Obsoletes
getZoneDevices = get_zone_devices
getUplinks = get_uplinks
getNicList = get_nic_list
