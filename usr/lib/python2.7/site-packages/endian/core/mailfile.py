#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import shlex

# requirements for sendmail
import time
from endian.core.mail import buildMIMEMessage, sendmail

from email.Parser import Parser
from email.Header import Header
from email.Utils import formatdate
from Cheetah.Template import Template
from Cheetah.Tools import RecursiveNull

import traceback

from endian.core.logger import logger, info
from endian.data.ds import DataSource

null = RecursiveNull.RecursiveNull()


class MailSender(object):
    def __init__(self, from_addr, to_addr, mailhost="localhost", caller="", user='', pwd='', desired_auths=[], port=25, mylogger=None, conn_security=None):
        self.from_addr = from_addr.strip("'\"")
        self.to_addr = to_addr.strip("'\"")
        self.mailhost = mailhost
        self.port = port
        self.caller = caller
        self.user = user
        self.pwd = pwd
        self.desired_auths = desired_auths
        self.logger = mylogger or logger
        self.conn_security = conn_security

    def appendVariables(self, variables, doWarn=True, cheetah=False, searchList=None):
        ret = {}
        info("given variables: %s" % variables)
        for item in shlex.split(variables):
            try:
                (key, value) = item.split("=")
            except ValueError:
                if doWarn:
                    self.logger.warn("Variable '%s' not in KEY=VALUE format" % item)
                continue

            checkvalue = value.lower()
            if cheetah != checkvalue.startswith('cheetah:'):
                continue

            self.logger.debug("KEY: %s VALUE: %s" % (key, value))

            if checkvalue.startswith('cheetah:'):
                self.logger.debug("Generating content for key '%s' from template '%s'" % (
                                  key, value))
                try:
                    filename = value.split(':')[1]
                    t = Template(file=filename, searchList=[searchList, null])
                    value = t.respond().strip()
                except:
                    self.logger.error("Could not generate content from cheetah template for key '%s'" % key)
                    continue

            elif checkvalue.startswith('file:'):
                self.logger.debug("Reading content for key '%s' from file '%s'" % (key, value))
                try:
                    value = open(value.split(':')[1]).read().strip()
                except:
                    self.logger.error("Could not read content of file for key '%s'" % key)
                    continue
            ret[key] = value
        return ret

    @staticmethod
    def getMessage(mail):
        p = Parser()
        return p.parsestr(mail)

    @staticmethod
    def encodeHeaderUnicode(s):
        return Header(s, 'utf-8').encode()

    def sendmail(self, subject="", attachment="", text="", cheetah_body=None, mailtemplate=None, variables=""):
        now = time.time()
        maildate = formatdate(timeval=now, localtime=True)
        date = time.ctime(now)

        subst = {
            "date": date,
            "DATE": date,
            "MAILDATE": maildate,
            "maildate": maildate,
            "to_addr": self.to_addr,
            "RCPT_TO": self.to_addr,
            "from_addr": self.from_addr,
            "MAIL_FROM": self.from_addr,
            "filename": attachment,
            "FILENAME": attachment,
            "text": text,
            "subject": "",
            "SUBJECT": "",
            "encodeHeaderUnicode": self.encodeHeaderUnicode,
            "ds": DataSource()
        }

        # setup
        if variables:
            subst.update(self.appendVariables(variables))
            # variable content generated by cheetah templates need to be generated
            # as last, since the templates may need variables
            subst.update(self.appendVariables(variables, cheetah=True, searchList=subst))

        if subject:
            self.logger.debug("Subject set. Try to compile subject string as cheetah template")
            try:
                t = Template(subject, searchList=[subst, null])
                sub = t.respond()
                subject = sub.strip()
            except:
                self.logger.warn("Could not substitute subject template. Use template source instead")

        if subject != '':
            self.logger.debug("Use supplied subject '%s'" % subject)
            subst['subject'] = subject
            subst['SUBJECT'] = subject

        body = ""
        if cheetah_body:
            self.logger.debug("Read in cheetah body template from file '%s'" % cheetah_body)
            try:
                body = open(cheetah_body, "r").readlines()
            except Exception, e:
                self.logger.error("Could not read body from file '%s' due to: \"%s\"" % (cheetah_body, e))
                return
            body = " ".join(body)
            try:
                body = Template(body, searchList=[subst, null]).respond()
            except:
                self.logger.error("Could not substitute body template. Use template source instead")
                return

        elif text:
            self.logger.debug("Use simple text as mail body")
            body = text

        msg = None
        if mailtemplate:
            self.logger.debug("Use full cheetah mail template")
            mail = ""
            self.logger.debug("Compile mail template '%s'" % mailtemplate)
            try:
                mail = Template(file=mailtemplate, searchList=[subst, null]).respond()
                msg = self.getMessage(mail)
            except Exception, e:
                self.logger.error("Could not produce mail content from mailtemplate '%s', due to \"%s\". "
                                  "Send traceback as mail body." % (mailtemplate, e))
                self.logger.debug("Mail content compilation error:", exc_info=True)
                body = "Could not produce mail content, because of \n"
                body += traceback.format_exc()
                err = "Could not produce mail content"
                subst['subject'] = err
                subst['SUBJECT'] = err
                subject = err
                msg = None

        if not msg:
            if attachment:
                self.logger.debug("Produce MIME message with attachment '%s'" % attachment)
            else:
                self.logger.debug("Produce MIME message")

            try:
                msg = buildMIMEMessage(body, subject, self.to_addr, self.from_addr, attachment=attachment)
            except IOError, e:
                self.logger.error(
                    "Could not open attachment '%s' for mail to '%s', due to \"%s\".%s" % (
                        attachment,
                        self.to_addr,
                        e,
                        self.caller
                    ))
                return
            except Exception, e:
                self.logger.error(
                    "Could not create MIME Message for mail to '%s', due to: \"%s\".%s" % (
                        self.to_addr,
                        e,
                        self.caller
                    ))
                self.logger.debug("MIME Message creation error:", exc_info=True)
                return

        # send message
        try:
            sendmail(self.from_addr, self.to_addr, msg, self.mailhost,
                     user=self.user, pwd=self.pwd, desired_auths=self.desired_auths, port=self.port, conn_security=self.conn_security)
        except Exception, e:
            self.logger.error("FAILED sending mail to %s, due to: '%s'.%s" % (
                self.to_addr,
                str(e),
                self.caller
            ))
        else:
            self.logger.info("Mail sent to '%s'.%s" % (self.to_addr, self.caller))
