#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

"""
--- spawnverbose ---

spawns a command, logs its output and returns the exitcode

@author Peter Warasin <peter@endian.com>
@copyright (c) Endian 2007
"""

from endian.core.logger import log, debug, info, error
import logging

import os
import errno
import types
import traceback
import pickle

import subprocess
import time
import signal

import sys
mswindows = (sys.platform == "win32")

class Popen(subprocess.Popen):
    def __init__(self, args, bufsize=0, executable=None,
                 stdin=None, stdout=None, stderr=None,
                 preexec_fn=None, close_fds=False, shell=False,
                 cwd=None, env=None, universal_newlines=False,
                 startupinfo=None, creationflags=0,
                 ignoreSignals=[]):
        """Create new Popen instance, with ability to handle signals."""
        self.ignoreSignals = ignoreSignals
        subprocess.Popen.__init__(self, args, bufsize, executable,
                                  stdin, stdout, stderr,
                                  preexec_fn, close_fds, shell,
                                  cwd, env, universal_newlines,
                                  startupinfo, creationflags)


    if not mswindows:
        def _execute_child(self, args, executable, preexec_fn, close_fds,
                           cwd, env, universal_newlines,
                           startupinfo, creationflags, shell,
                           p2cread, p2cwrite,
                           c2pread, c2pwrite,
                           errread, errwrite):
            """Execute program (POSIX version)"""

            if isinstance(args, types.StringTypes):
                args = [args]

            if shell:
                args = ["/bin/sh", "-c"] + args

            if executable == None:
                executable = args[0]

            # For transferring possible exec failure from child to parent
            # The first char specifies the exception type: 0 means
            # OSError, 1 means some other error.
            errpipe_read, errpipe_write = os.pipe()
            self._set_cloexec_flag(errpipe_write)

            self.pid = os.fork()
            if self.pid == 0:
                # Child
                try:
                    if len(self.ignoreSignals) > 0:
                        for sig in range(1,31):
                            if sig in [signal.SIGKILL, signal.SIGSTOP, signal.SIGPIPE]:
                                continue
                            signal.signal(sig, signal.SIG_DFL)
                        for sig in self.ignoreSignals:
                            signal.signal(sig, signal.SIG_IGN)

                    # Close parent's pipe ends
                    if p2cwrite:
                        os.close(p2cwrite)
                    if c2pread:
                        os.close(c2pread)
                    if errread:
                        os.close(errread)
                    os.close(errpipe_read)

                    # Dup fds for child
                    if p2cread:
                        os.dup2(p2cread, 0)
                    if c2pwrite:
                        os.dup2(c2pwrite, 1)
                    if errwrite:
                        os.dup2(errwrite, 2)

                    # Close pipe fds.  Make sure we doesn't close the same
                    # fd more than once.
                    if p2cread:
                        os.close(p2cread)
                    if c2pwrite and c2pwrite not in (p2cread,):
                        os.close(c2pwrite)
                    if errwrite and errwrite not in (p2cread, c2pwrite):
                        os.close(errwrite)

                    # Close all other fds, if asked for
                    if close_fds:
                        self._close_fds(but=errpipe_write)

                    if cwd != None:
                        os.chdir(cwd)

                    if preexec_fn:
                        apply(preexec_fn)

                    if env == None:
                        os.execvp(executable, args)
                    else:
                        os.execvpe(executable, args, env)

                except:
                    exc_type, exc_value, tb = sys.exc_info()
                    # Save the traceback and attach it to the exception object
                    exc_lines = traceback.format_exception(exc_type,
                                                           exc_value,
                                                           tb)
                    exc_value.child_traceback = ''.join(exc_lines)
                    os.write(errpipe_write, pickle.dumps(exc_value))

                # This exitcode won't be reported to applications, so it
                # really doesn't matter what we return.
                os._exit(255)

            # Parent
            os.close(errpipe_write)
            if p2cread and p2cwrite:
                os.close(p2cread)
            if c2pwrite and c2pread:
                os.close(c2pwrite)
            if errwrite and errread:
                os.close(errwrite)

            # Wait for exec to fail or succeed; possibly raising exception
            data = os.read(errpipe_read, 1048576) # Exceptions limited to 1 MB
            os.close(errpipe_read)
            if data != "":
                os.waitpid(self.pid, 0)
                child_exception = pickle.loads(data)
                raise child_exception


class TimeoutException(Exception):
    """Will be thrown if a timeout has been exceeded."""
    pass

def _setTimeout(signum, frame):
    debug("Got SIGALRM signal because of timeout.")
    raise TimeoutException("Subprocess timed out!")

_oldHandler = None
def _installTimeout(timeout):
    global _oldHandler
    debug("Install timeout %s."%(timeout))
    signal.alarm(0)
    _oldHandler = signal.getsignal(signal.SIGALRM)
    signal.signal(signal.SIGALRM, _setTimeout)
    signal.alarm(timeout)

def _removeTimeout(p):
    debug("Remove timeout handler for process %s."%(p.pid))
    signal.alarm(0)
    if _oldHandler != None:
        signal.signal(signal.SIGALRM, _oldHandler)

def _handleTimeout(p):
    info("Process %s timed out! Kill 'Em All"%p.pid)
    try:
        os.killpg(p.pid, signal.SIGTERM)
    except:
        pass
    try:
        os.kill(p.pid, signal.SIGTERM)
    except:
        pass
    time.sleep(3)
    try:
        os.killpg(p.pid, signal.SIGKILL)
    except:
        pass
    try:
        os.kill(p.pid, signal.SIGKILL)
    except:
        pass



def spawn(cmd, errlevel=logging.INFO, ignoreSignals=[], timeout=-1):
    """
    Spawns a command and returns the return code

    *errlevel* sets the logging level with which the output should be logged
    when the command returns with an error.
    if *ignoreSignals* is True, the spawned process will ignore all signals.
    if *timeout* is greater than 0, the spawned process will be killed after
    timeout seconds, if it will not exit and let spawn() return.

    """
    debug("Spawn subprocess '%s'"%cmd)

    p = Popen(cmd, shell=True, close_fds=True, \
              stderr=subprocess.STDOUT, stdout=subprocess.PIPE, ignoreSignals=ignoreSignals)

    ret = -1

    if timeout >= 0:
        _installTimeout(timeout)

    level = logging.DEBUG
    buffer=[]

    if errlevel == logging.DEBUG:
        log(level, "-------------------------- Output --------------------------")

    # prebuffer the output, if it should only printed out if an error occurrs.
    # This is needed because bufsize of the subprocess module
    # holds to few data and therefore the called process will be blocked.

    while True:
        try:
            debug("Reading from process %s"%p.pid)
            # read data coming from process
            for line in p.stdout:
                if errlevel == logging.DEBUG:
                    log(level, line)
                else:
                    buffer.append(line)
            break
        except TimeoutException:
            _handleTimeout(p)
            break
        except Exception, e:
            errnr = -1
            errcode = None
            if len(e.args) > 0:
                errnr = e[0]
            if len(e.args) > 1:
                errcode = e[1]
            # Eat interrupting signals. The process should not be terminated because of interrupts
            debug("Process has been interrupted. Check why")
            if errnr in [0, errno.EINTR, errno.EAGAIN]:
                debug("Process has been interrupted due to %s. Continue..."%errcode)
                continue
            error("Error reading from process, due to %s. Exit function"%errcode)
            raise Exception(e)

    while True:
        try:
            debug("Wait until process with pid %s ends"%str(p.pid))
            # wait until process ends
            ret = p.wait()
            if ret == None:
                continue
            break

        except TimeoutException:
            _handleTimeout(p)
            break
        except Exception, e:
            errnr = -1
            errcode = None
            if len(e.args) > 0:
                errnr = e[0]
            if len(e.args) > 1:
                errcode = e[1]
            # Eat interrupting signals. The process should not be terminated because of interrupts
            if errnr == errno.EINTR:
                debug("Process has been interrupted. Continue waiting.")
                continue
            debug("Process has been interrupted. Exit function")
            raise Exception(e)

    if timeout >= 0:
        _removeTimeout(p)

    level = logging.DEBUG
    if ret != 0:
        level = errlevel

    if errlevel != logging.DEBUG:
        log(level, "Subprocess '%s' ended with exitcode %s."%(cmd, str(ret)))
        log(level, "-------------------------- Output --------------------------")
        for line in buffer:
            log(level, line.strip())

    log(level, "------------------------------------------------------------")
    log(level, "Subprocess '%s' ended with exitcode %s."%(cmd, str(ret)))

    if ret == 127:
        raise OSError("'%s': Command not found!"%cmd)

    return ret
