#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#
# Pyton File Alteration Monitor
# stolen a lot from Ian Bicking's WSGIKit (www.wsgikit.org) and CherryPy 3 plugins.py

import os
import re
import sys
import time
from threading import Thread

__author__ = "Andrea Boomi <a.bonomi@endian.com>"
__date__ = "2010-08-17"


__all__ = ['install_altertion_monitor']

class MonitorThread(Thread):
    """
        Thread which execute a function when python source files change.
    """

    callback_func = None
    args = None
    kwargs = None
    frequency = None
    debug = None
    changed_modules_arg = None

    def __init__(self, callback_func, args=None, kwargs=None, frequency=1, match=None, ignore_files=None, debug=False, changed_modules_arg=False):
        Thread.__init__(self)
        self.setName("File Alteration Monitor "+ self.getName())
        self.callback_func = callback_func
        self.args = args or []
        self.kwargs = kwargs or {}
        self.frequency = frequency
        self.match = match
        self.ignore_files = ignore_files
        self.changed_modules_arg = changed_modules_arg
        if debug:
            from endian.core.logger import debug
            self.debug = debug

    def run(self):
        mtimes = {}
        first_time = True
        while True:
            run_func = False

            sysfiles = []
            for k, m in sys.modules.items():
                if not self.match or re.match(self.match, k):
                    if hasattr(m, "__loader__"):
                        if hasattr(m.__loader__, "archive"):
                            k = m.__loader__.archive
                    k = getattr(m, "__file__", None)
                    if k:
                        sysfiles.append(k)

            changed_modules = []
            for filename in sysfiles:
                if filename and (not self.ignore_files or filename not in self.ignore_files):

                    if filename.endswith(".pyc"):
                        filename = filename[:-1]

                    # Get the last-modified time of the source file.
                    try:
                        mtime = os.stat(filename).st_mtime

                        if filename not in mtimes:
                            mtimes[filename] = mtime

                        elif mtime > mtimes[filename]:
                            if not first_time:
                                changed_modules.append(filename)
                                if self.debug != None:
                                   self.debug("file changed: %s now: %s old: %d" % (filename, mtime, mtimes[filename]))
                                run_func = True
                            mtimes[filename] = mtime

                    except OSError:
                        pass

            if run_func and not first_time:
                run_func = False
                if not self.changed_modules_arg:
                    self.callback_func(*self.args, **self.kwargs)
                else:
                    changed_modules = [self.path_to_module(x) for x in changed_modules]
                    self.callback_func(changed_modules=changed_modules, *self.args, **self.kwargs)

            if first_time:
                first_time = False

            time.sleep(self.frequency)

    @staticmethod
    def path_to_module(module_file, sorted_path=None):
        if not sorted_path:
            sorted_path = sorted(sys.path, lambda word1, word2: len(word2) - len(word1))
        if module_file.endswith(".py"):
            module_file = module_file[:-3]
        for path in sorted_path:
            if module_file.startswith(path):
                module_file = module_file[len(path):]
                if module_file.startswith(os.path.sep):
                    module_file = module_file[1:]
                return module_file.replace(os.path.sep, '.')
        return module_file.replace(os.path.sep, '.')

def install_altertion_monitor(callback_func, args=None, kwargs=None, frequency=1, match=None, ignore_files=None, debug=False, changed_modules_arg=False):
    """
        Install the alteration monitor, which execute a function when monitored python source files change.

        :param callback_func: callback function executed when python source files change
        :type callback_func: function
        :param args: optional function args (default None)
        :type args: list
        :param kwargs: optional function kwargs (default None)
        :type kwargs: dict
        :param frequency: The optional interval in seconds at which to poll for modified files (default 1 s)
        :type frequency: int
        :param match: An optional regular expression by which to match filenames (default match any file)
        :type match: string
        :param ignore_files: An optional list of files to be ignored (default empty)
        :type ignore_files: list
        :param debug: Enable debug mode
        :type debug: boolean
        :param changed_modules_arg: If true, add the arg 'changed_modules' (list of changed modules) when calling the callback function
        :type changed_modules_arg: boolean
    """
    current = MonitorThread(callback_func, args=args, kwargs=kwargs, frequency=frequency, match=match, ignore_files=ignore_files, debug=debug, changed_modules_arg=changed_modules_arg)
    current.start()
    return current


if __name__ == "__main__":
    def a(changed_modules):
        print time.time()
        print changed_modules

    c = install_altertion_monitor(a, debug=True, changed_modules_arg=True)
    c.join()
