#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2010-12-02"

import time
import datetime
import os
import struct
import fcntl
import UserList

INIT_PROCESS = 5

TYPE_EMPTY    = 0    # No valid user accounting information.
RUN_LVL       = 1    # The system's runlevel.
BOOT_TIME     = 2    # Time of system boot.
NEW_TIME      = 3    # Time after system clock changed.
OLD_TIME      = 4    # Time when system clock changed.
INIT_PROCESS  = 5    # Process spawned by the init process.
LOGIN_PROCESS = 6    # Session leader of a logged in user.
USER_PROCESS  = 7    # Normal process.
DEAD_PROCESS  = 8    # Terminated process.

UT_STRUCT = "hi32s4s32s256shhiii4i20s"
UT_LENGTH = struct.calcsize(UT_STRUCT) # 384

UTMP_FILE = "/var/run/utmp"
WTMP_FILE = "/var/log/wtmp"

class UtmpLine(object):

    type = None               # Entry type: INIT_PROCESS, LOGIN_PROCESS, USER_PROCESS, ...
    pid = None                # Process id
    line = None               # TTY
    id = None                 # Line id (4 char abbreviation af line)
    user = None               # Username (32 chars)
    host = None               # Remote hostname (256 chars)
    exit_termination = None
    exit_exit = None
    session = None            # Session (e.g. os.getsid(0))
    time_sec = None           # Timestamp in seconds
    time_usec = None          # Timestap usec
    addr = None
    _unused = None

    def __init__(self, buffer=None):
        if buffer:
            values = struct.unpack(UT_STRUCT, buffer)
            self.type = values[0]
            self.pid = values[1]
            self.line = values[2].strip("\0")
            self.id = values[3].strip("\0")
            self.user = values[4].strip("\0")
            self.host = values[5].strip("\0")
            self.exit_termination = values[6]
            self.exit_exit = values[7]
            self.session = values[8]
            self.time_sec = values[9]
            self.time_usec = values[10]
            self.addr = [values[11], values[12], values[13], values[14]]
            self._unused = values[15]
        else:
            self.type = 0
            self.line = ""
            self.id = ""
            self.user = ""
            self.host = ""
            self.exit_termination = 0
            self.exit_exit = 0
            self.session = 0
            self.time_sec = 0
            self.time_usec = 0
            self.addr = [0, 0, 0, 0]
            self._unused = ""

    def to_struct(self):
        return struct.pack(UT_STRUCT, self.type, self.pid, self.line, self.id, self.user, self.host,
                           self.exit_termination, self.exit_exit, self.session, self.time_sec, self.time_usec,
                           self.addr[0], self.addr[1], self.addr[2], self.addr[3], self._unused)

    def __str__(self):
        return "[%d] [%05d] [%-4s] [%-8s] [%-12s] [%-30s] [%s]" % (self.type, self.pid, self.id, self.user, self.line, self.host, "%04d-%02d-%02d %02d:%02d:%02d" % time.localtime(self.time_sec)[0:6])

    def __repr__(self):
        return self.__str__()


def read_utmp(filename=UTMP_FILE):
    """
        Read all the entries from the utmp file and return a list of UtmpLine instances

        :param filename: The path of the utmp file (default: /var/run/utmp)
        :type filename: string
    """
    result = []
    f = open(filename, mode='rb')
    f.seek(0)
    buffer = True
    while buffer:
        buffer = f.read(UT_LENGTH)
        if buffer:
            result.append(UtmpLine(buffer))
    f.close()
    return result

def read_wtmp(filename=WTMP_FILE):
    """
        Read all the entries from the wtmp file and return a list of UtmpLine instances

        :param filename: The path of the utmp file (default: /var/log/wtmp)
        :type filename: string
    """
    return read_utmp(filename)

def update_utmp(filename=UTMP_FILE, line=None, type=None, user=None, host=None, pid=None):
    """
         Update an utmp entry identified by a line (the default value for the line is the current tty)

        :param filename: The path of the utmp file (default: /var/run/utmp)
        :type filename: string
        :param line: The line to update (the default value for the line is the current tty)
        :type line: string (e.g. /dev/tty1)
        :param time: The entry type (LOGIN_PROCESS, USER_PROCESS, ...)
        :type type: int
        :param user: The user name
        :type user: string
        :param user: The user's remote host name (default: None)
        :type user: string
        :param pid: Process id (default: current pid)
        :type pid: int
    """
    if line == None:
        line = os.ttyname(0)
    if line.startswith("/dev/"):
        line = line[5:]
    if line.startswith("tty"):
        id = line[3:]
    else:
        id = line
    id = id[-4:]
    try:
        f = open(filename, mode='r+b')
        fcntl.flock(f.fileno(), fcntl.LOCK_EX)
        f.seek(0)
        buffer = True
        i = 0
        while buffer:
            buffer = f.read(UT_LENGTH)
            if buffer:
                utmp_line = UtmpLine(buffer)
            else:
                utmp_line = UtmpLine()
                utmp_line.line = line

            if utmp_line.line == line:
                utmp_line.id = id
                if type != None:
                    utmp_line.type = type
                if user != None:
                    utmp_line.user = user
                if host != None:
                    utmp_line.host = host
                utmp_line.time_sec = time.time()
                if pid != None:
                    utmp_line.pid = pid
                else:
                    utmp_line.pid = os.getpid()
                if utmp_line.type != USER_PROCESS:
                    utmp_line.session = os.getsid(0)
                else:
                    utmp_line.session = 0
                f.seek(i * UT_LENGTH)
                f.write(utmp_line.to_struct())
                break
            i = i + 1
    finally:
        if f:
            fcntl.flock(f.fileno(), fcntl.LOCK_UN)
            f.close()


class Wtmp(UserList.UserList):
    """
    ... autoclass::: Wtmp
        Parse the wtmp file
    """

    def __init__(self, filename=WTMP_FILE):
        self.data = []
        wtmp = reversed(read_wtmp(filename=filename))
        zlist = {}
        for line in wtmp:
            if line.type == BOOT_TIME:
                zlist = {}
            elif line.type == DEAD_PROCESS:
                zlist[line.line] = line
            elif line.type == USER_PROCESS:
                logout_line = zlist.get(line.line)
                self.data.append({'user': line.user,
                      'tty': line.line,
                      'source': line.host,
                      'loginTimestamp': line.time_sec,
                      'time': logout_line != None and (logout_line.time_sec - line.time_sec) or None,
                      'loggedIn': logout_line == None,
                      })

    def last(self):
        """
            Returns the content of the wtmp file in a format similar to the last command
        """
        result = []
        for line in self:
            if line['time']:
                time = "(%s)" % datetime.timedelta(seconds=line['time'])
            else:
                time = "still logged in"
            result.append("%-8.8s %-12.12s  %-16.16s %s %s" % (
                    line['user'],
                    line['tty'],
                    line['source'],
                    str(datetime.datetime.fromtimestamp(line['loginTimestamp'])),
                    time))
        return "\n".join(result)

__all__ = ['read_utmp',
           'read_wtmp',
           'update_utmp',
           'Wtmp',
           'RUN_LVL',
           'BOOT_TIME',
           'NEW_TIME',
           'OLD_TIME',
           'INIT_PROCESS',
           'LOGIN_PROCESS',
           'USER_PROCESS',
           'DEAD_PROCESS',
           'UTMP_FILE',
           'WTMP_FILE',
           ]
