#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

import os
import smtplib
import random
import base64
from binascii import hexlify
import hmac

from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
from email.MIMEBase import MIMEBase
from email import Encoders
from email.Parser import Parser
from email.Header import Header
from email.base64MIME import encode as encode_base64

from endian.core.settingsfile import SettingsFile


MAIN_SETTINGS = 'main/settings'
DEFAULT_MAILHOST = 'localhost'
DEFAULT_MAIN_MAILFROM = 'root@localhost'
DEFAULT_TIMEOUT = 10


# We extend standard smtplib login method to add DIGEST-MD5 authentication
def extended_login(self, user, password, desired_auths=[]):
    """Log in on an SMTP server that requires authentication.

    The arguments are:
        - user:     The user name to authenticate with.
        - password: The password for the authentication.

    If there has been no previous EHLO or HELO command this session, this
    method tries ESMTP EHLO first.

    This method will return normally if the authentication was successful.

    This method may raise the following exceptions:

     SMTPHeloError            The server didn't reply properly to
                              the helo greeting.
     SMTPAuthenticationError  The server didn't accept the username/
                              password combination.
     SMTPException            No suitable authentication method was
                              found.
    """
    def encode_cram_md5(challenge, user, password):
        challenge = base64.decodestring(challenge)
        response = user + " " + hmac.HMAC(password, challenge).hexdigest()
        return encode_base64(response, eol="")

    def digest_md5_decode_challenge(challenge):
        # Challenge is formed with these pairs separated by comma.
        #   realm="hostname" (multiple allowed)
        #   nonce="randomized data, at least 64bit"
        #   qop="auth,auth-int,auth-conf"
        #   maxbuf=number (with auth-int, auth-conf, defaults to 64k)
        #   charset="utf-8" (iso-8859-1 if it doesn't exist)
        #   algorithm="md5-sess"
        #   cipher="3des,des,rc4-40,rc4,rc4-56" (with auth-conf)
        #
        # XXX: multiple realms are not supported
        c = {}
        for e in challenge.split(','):
            off = e.index('=')
            v = e[off + 1:].strip()
            if v[0] == '"':
                v = v[1:-1]
            c[e[:off].strip()] = v
        return c

    def generate_cnonce():
        s = ""
        for i in range(16):
            s = s + chr(random.randint(0, 0xff))
        return encode_base64(s, eol="")

    def md5(indata):
        try:
            import hashlib
            md5 = hashlib.md5(indata)
        except ImportError:
            import md5
            md5 = md5.new(indata)
        return md5.digest()

    def encode_digest_md5(challenge, user, password):
        challenge = base64.decodestring(challenge)
        c = digest_md5_decode_challenge(challenge)

        realm = c["realm"]
        nonce = c["nonce"]
        qop = c["qop"]
        cnonce = generate_cnonce()
        if "realm" in c:
            digest_uri = "smtp/%s" % realm
            realm_pair = ',realm="%s"' % realm
        else:
            digest_uri = "smtp/localhost"
            realm_pair = ""

        credential = md5("%s:%s:%s" % (user, realm, password))
        # XXX: not support authorization ID
        a1 = "%s:%s:%s" % (credential, nonce, cnonce)
        if qop == "auth":
            a2 = "AUTHENTICATE:%s" % digest_uri
        else:
            # XXX: most servers and clients don't implement auth-int/auth-conf,
            # they use dummy MD5 digest for body.
            a2 = "AUTHENTICATE:%s:00000000000000000000000000000000" % digest_uri

        a1 = hexlify(md5(a1))
        a2 = hexlify(md5(a2))
        response = hexlify(md5("%s:%s:00000001:%s:%s:%s" %
                           (a1, nonce, cnonce, qop, a2)))
        response = ('username="%s"%s,nonce="%s",cnonce="%s",'
                    'nc=00000001,qop=%s,digest-uri="%s",response=%s' %
                    (user, realm_pair, nonce, cnonce, qop, digest_uri, response))
        return encode_base64(response, eol="")

    def encode_plain(user, password):
        return encode_base64("\0%s\0%s" % (user, password), eol="")

    AUTH_PLAIN = "PLAIN"
    AUTH_CRAM_MD5 = "CRAM-MD5"
    AUTH_DIGEST_MD5 = "DIGEST-MD5"
    AUTH_LOGIN = "LOGIN"

    self.ehlo_or_helo_if_needed()

    if not self.has_extn("auth"):
        raise smtplib.SMTPException("SMTP AUTH extension not supported by server.")

    # Authentication methods the server supports:
    authlist = self.esmtp_features["auth"].split()

    # List of authentication methods we support: from preferred to
    # less preferred methods. Except for the purpose of testing the weaker
    # ones, we prefer stronger methods like CRAM-MD5:
    preferred_auths = desired_auths or [AUTH_DIGEST_MD5, AUTH_CRAM_MD5, AUTH_PLAIN, AUTH_LOGIN]

    # Determine the authentication method we'll use
    authmethod = None
    for method in preferred_auths:
        if method in authlist:
            authmethod = method
            break

    if authmethod == AUTH_DIGEST_MD5:
        (code, resp) = self.docmd("AUTH", AUTH_DIGEST_MD5)
        if code == 503:
            # 503 == 'Error: already authenticated'
            return (code, resp)
        (code, resp) = self.docmd(encode_digest_md5(resp, user, password))
        if code == 334:
            # XXX: need validate "resp"?
            (code, resp) = self.docmd("")
    elif authmethod == AUTH_CRAM_MD5:
        (code, resp) = self.docmd("AUTH", AUTH_CRAM_MD5)
        if code == 503:
            # 503 == 'Error: already authenticated'
            return (code, resp)
        (code, resp) = self.docmd(encode_cram_md5(resp, user, password))
    elif authmethod == AUTH_PLAIN:
        (code, resp) = self.docmd("AUTH", AUTH_PLAIN + " " + encode_plain(user, password))
    elif authmethod == AUTH_LOGIN:
        (code, resp) = self.docmd("AUTH", "%s %s" % (AUTH_LOGIN, encode_base64(user, eol="")))
        if code != 334:
            raise smtplib.SMTPAuthenticationError(code, resp)
        (code, resp) = self.docmd(encode_base64(password, eol=""))
    elif authmethod is None:
        raise smtplib.SMTPException("No suitable authentication method found.")
    if code not in (235, 503):
        # 235 == 'Authentication successful'
        # 503 == 'Error: already authenticated'
        raise smtplib.SMTPAuthenticationError(code, resp)
    return (code, resp)


smtplib.SMTP.login = extended_login


def guess_smarthost():
    main_settings = SettingsFile(MAIN_SETTINGS)
    return main_settings.get('MAIN_SMARTHOST') or DEFAULT_MAILHOST


def guess_mailfrom():
    main_settings = SettingsFile(MAIN_SETTINGS)
    return main_settings.get('MAIN_MAILFROM') or DEFAULT_MAIN_MAILFROM


def buildMIMEMessage(body, subject, to_addr, from_addr='', _subtype='text', attachment='', multipart_type=None):
    """Create a MIMEMultipart message.

    @type  body string
    @param body The body of the message
    @type  subject string
    @param subject The subject of the message
    @type  to_addr string
    @param to_addr The receiver's email address
    @type  from_addr string
    @param from_addr The sender's email address (guessed, if empty)
    """
    msg = MIMEMultipart(multipart_type)
    msg['To'] = to_addr
    msg['Subject'] = subject
    msg['From'] = from_addr or guess_mailfrom()

    if multipart_type == 'mixed':
        body = MIMEText(body, 'plain')
        msg.attach(body)
    else:
        msg.attach(MIMEText(body, _subtype=_subtype, _charset='utf-8'))

    if attachment:
        part = MIMEBase('application', "octet-stream")
        part.set_payload(open(attachment, "rb").read())
        Encoders.encode_base64(part)
        part.add_header('Content-Disposition', 'attachment; filename="%s"' % os.path.basename(attachment))
        msg.attach(part)

    return msg


def verify_msg_header_encoding(msg):
    if not hasattr(msg, 'as_string'):
        msg = Parser().parsestr(msg)
    for i in msg.keys():
        try:
            msg[i].decode("ascii")
        except:
            msg.replace_header(i, Header(msg[i], 'utf-8').encode())


def sendmail(from_addr, to_addr, msg, mailhost='', user='', pwd='', desired_auths=[], port=0, conn_security=None):
    """
    Send an email.

    If from_addr and mailhost are empty strings, they are
    guessed from the system configuration.

    @type  to_addr string
    @param to_addr The receiver's email address
    @type  from_addr string
    @param from_addr The sender's email address (guessed, if empty)
    @type  msg string
    @param msg A MIMEMultipart or a string with a complete message.
    @type  mailhost string
    @param mailhost Smarthost used to send the email.
    @type  user string
    @param user Username for smarthost authentication.
    @type  pwd string
    @param pwd Password for smarthost authentication.
    @type  desired_auths list
    @param desired_auths List of preferred authentication methods.

    """
    from_addr = from_addr or guess_mailfrom()
    mailhost = mailhost or guess_smarthost()

    if conn_security == 'SSL/TLS':
        smtp = smtplib.SMTP_SSL(mailhost, port, timeout=DEFAULT_TIMEOUT)
    else:
        smtp = smtplib.SMTP(mailhost, port, timeout=DEFAULT_TIMEOUT)
        if conn_security == 'STARTTLS':
            try:
                smtp.starttls()
            except smtplib.SMTPException, e:
                smtp.close()
                raise e

    if user and pwd:
        try:
            smtp.login(user, pwd, desired_auths)
        except Exception, e:
            smtp.close()
            raise e
    verify_msg_header_encoding(msg)
    if hasattr(msg, 'as_string'):
        msg_txt = msg.as_string()
    else:
        msg_txt = msg
    if not isinstance(to_addr, (list, tuple)):
        to_addr = [to_addr]
    try:
        smtp.sendmail(from_addr, to_addr, msg_txt)
    except Exception, e:
        raise e
    finally:
        smtp.close()
