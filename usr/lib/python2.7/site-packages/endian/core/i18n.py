#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import os
import gettext
from endian.core.logger import debug, error
from errno import ENOENT

UNICODE_WORKAROUND = False
currentLang = 'en'
domainRegistry = ['efw', 'efw.enterprise', 'efw.vendor']
domainRegistryDirty = True

def registerDomain(domain):
    global domainRegistryDirty
    if domain in domainRegistry:
        return
    debug("Register i18n domain '%s' to domain stack" % domain)
    domainRegistryDirty = True
    domainRegistry.append(domain)

def get_language():
    try:
        from endian.data.ds import DataSource
        currentLang = DataSource('main').settings.get('LANGUAGE', 'en')
    except Exception:
        error("Could not load language settings", exc_info=True)
        currentLang = "en"
    return currentLang

def setLanguage():
    global currentLang
    currentLang = get_language()
    os.environ['LANG'] = currentLang
    debug("Set i18n language to '%s'" % currentLang)

_translationCache = {}
def getTranslationsInstance(language, domain=None):
    global domainRegistryDirty
    key = "%s/%s" % (language, domain)
    instance = _translationCache.get(key, None)

    if instance == None:
        debug("i18n instance '%s' not found in cache. Creating." % key)
    else:
        if domain != None:
            # there's no domain stack. Only a simple domain
            return instance
        if domainRegistryDirty:
            debug("i18n domain cache is dirty. Rebuilding...")
        else:
            return instance

    domainStack = domainRegistry
    if domain != None:
        domainStack = [domain]

    instance = None
    last = None
    for dom in domainStack:
        debug("Load i18n domain '%s'" % dom)
        try:
            t = gettext.translation(dom, languages=[language])
        except IOError, e:
            if e.errno == ENOENT:
                debug("i18n domain '%s' not found. Skipping..." % dom)
                continue
        if instance == None:
            instance = t
        if last:
            debug("Add i18n domain '%s' as fallback of '%s'" % (dom, domainStack[0]))
            last.add_fallback(t)
        last = t
    if last:
        last.add_fallback(gettext.NullTranslations())
    _translationCache[key] = instance
    domainRegistryDirty = False
    if domain !=None and instance == None:
        error("i18n domain '%s' not found." % domain)
    else:
        debug("Loading of i18n domain stack '%s' complete" % domainStack)
    return instance

def translate(message, domain=None, locale=None):
    if locale == None:
        locale = currentLang
    if locale.startswith('en'):
        return message

    t = getTranslationsInstance(locale, domain)
    if t == None: # getTranslationsInstance returns None if i18n domain is not found
        return message

    if UNICODE_WORKAROUND:
        return t.gettext(message)
    else:
        return t.ugettext(message)

def i18nAllMethods(methodname):
    def _method(self, *argl, **argd):
        s = self
        vars = self.__dict__
        if ('id' in vars and
            'domain' in vars and
            'locale' in vars):
            s = translate(self.id, self.domain, self.locale)
            if 'arglist' in vars and self.arglist:
                if isinstance(s, basestring):
                    s = s % self.arglist
            s = s.encode('utf-8')
        return getattr(s, methodname)(*argl, **argd)
    return _method

class TranslatingString(type):
    def __new__(cls, classname, bases, classdict):
        for attr,item in str.__dict__.items():
            if not callable(item):
                continue
            if attr in ['__new__',
                        '__hash__',
                        '__getattribute__',
                        '__getnewargs__']:
                continue
            classdict[attr] = i18nAllMethods(attr)
        return type.__new__(cls, classname, bases, classdict)

class I18nString(str):
    __metaclass__ = TranslatingString
    def __init__(self, id):
        self.id = id
        self.domain = None
        self.locale = None
        self.arglist = None

class I18nUnicode(str):
    __metaclass__ = TranslatingString
    def __init__(self, id):
        self.id = id
        self.domain = None
        self.locale = None
        self.arglist = None

def translationWrapper(id, *argl, **args):
    inst = None
    if UNICODE_WORKAROUND:
        inst = I18nString(id)
    else:
        inst = I18nUnicode(id)
    if 'domain' in args:
        inst.domain = args['domain']
    if 'locale' in args:
        inst.domain = args['locale']
    if len(argl) == 1 and isinstance(argl[0], dict):
        inst.arglist = argl[0]
    else:
	inst.arglist = argl
    return inst

setLanguage()
__builtins__['_'] = translationWrapper
_ = translationWrapper

