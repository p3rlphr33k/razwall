#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

"""Notification system for Endian Firewall Services.

This class implements an interface for restartscripts to publish updates
of there ongoing status to the webinterface.

The current status is stored using the JSON syntax in a file which is named
after the restartscript or the service, which uses this class.

The JSON file is used in a JavaScript service notification subscriber class.
The Javascript Class is responsible to present the status updates,
contained in the JSON file to the end user via the WEB UI.

Contents:
    - ServiceNotification: Generic JSON Interface to publish status updates
    - StatusFile: Extends FileMutex. Adds file-object like functions.

Example:

>>> from endian.core.notification import ServiceNotification
>>> # Create and initialize the notification system for snort
>>> snortstatus = ServiceNotification("snort")
>>> # Publish first notification
>>> snortstatus.update("Reading configuration")
>>> ...
>>> # Publish another notification
>>> snortstatus.update("Restarting snortrules.py")
>>> # Publish error notification
>>> snortstatus.error("Failure: Snortrules incomplete!")
>>> # Call .end() to tell the signal the notification subscriber that
>>> # no more notifications will follow for this service.
>>> snortstatus.end()

"""

import os
from time import time
from os import path
import simplejson as json
from endian.core.mutex import FileMutex

STATUSFILE = "/var/lock/services/%s.status"

class InvalidNameError(Exception):

    """Exception for invalid names.

    This Error is thrown if the user of the ServiceNotification class, passes
    an empty string as the name of the service.
    Notice: May be extended in the future, to be thrown on other occasions as
    well.

    """
    pass

class StatusFileMutex(FileMutex):

    """Extends FileMutex class with file-like access options."""

    def __init__(self, mutexfile):
        """
        Creates a FileMutex with mutexfile 'mutexfile'.
        """
        FileMutex.__init__(self, mutexfile)
        # If the file already exists, unlink it
        if path.exists(mutexfile):
            try:
                os.unlink(mutexfile)
            except IOError, e:
                print("%s" % (e))

    def seek(self, offset, mode=0):
        """Modify the offset of the locked file-descriptor."""
        self._fd.seek(offset, mode)

    def tell(self):
        """Return the current offset the locked file-descriptor."""
        return self._fd.tell()

    def write(self, data):
        """Write data into the file."""
        self._fd.write(data)

    def flush(self):
        """Flush the file buffer."""
        self._fd.flush()

    def truncate(self, size):
        """Truncate the file to the given size."""
        self._fd.truncate(size)


class StatusFile:

    """Status file class holding status updates from the service.

    Each status file contains that latest notification. A separate history
    file keeps track of all posted notifications and holds a JSON-list of
    notification entries.
    Lines written to the file are automatically converted from python
    dictionaries into JSON objects.

    To improve the performance, despite the fact that JSON can't be streamed,
    each call of write(object), removes an ending ']' (represents the end of a
    list in JSON) and adds it again after the actual json object was added.
    As soon as the file is created, a '[' representing the begin of a list in
    JSON is automatically added.

    """

    def __init__(self, statusfile):
        """Constructor."""
        # Holds the offset of the line, which was last written to the
        # status file
        self._offsetOfLastLine = -1
        # Create a mutex file for the current status and one for the
        # service status history.
        self._status_file = statusfile
        self._status_fd = StatusFileMutex(self._status_file)
        # Append a .history before the .status part.
        history_file = "%s.history.%s" % (".".join(statusfile.split('.')[:-1]),
                                          "".join(statusfile.split('.')[-1]))
        self._history_file = history_file
        self._history_fd = StatusFileMutex(self._history_file)
        # Contains an error message from the service. Is preserved to the next
        # start of the service.
        self._error_file = self._status_file.replace('.status', '.error')
        self._error_fd = StatusFileMutex(self._error_file)
        # Immediately acquire a lock for the service status and history file.
        # Use blocking=False to have an exception raised, if the status
        # file is already blocked.
        self._status_fd.acquire(blocking=False)
        self._status_fd.truncate(0)
        self._status_fd.seek(0)

        self._history_fd.acquire(blocking=False)
        # Add the '[' JSON-list-start character
        self._history_fd.seek(0)
        self._history_fd.truncate(0)
        self._history_fd.write("[]")
        self._offsetOfLastLine = self._history_fd.tell()

    def write(self, data):
        """Convert object to JSON and write the result to the status file.

        Arguments:
        object -- the object containing status information, to convert to json
                  and to write to the status file

        Convert object into a JSON-object and write it into the status file.

        If this is first object to be writte to the history file,
        a preceding '[' is added, initiating a JSON list.
        A ']' is appended after the object, to indicate the end of a JSON
        list.

        """
        json_object = json.dumps(data)
        # Write the status into the status file
        self._status_fd.truncate(0)
        self._status_fd.seek(0)
        self._status_fd.write(json_object)
        self._status_fd.flush()

        # Add the status to the history
        self._history(json_object)

        # If the data contains an error, write it into the error file
        if data.get('type', '') == 'error':
            print "ERROR: %s" % (json_object)
            self._error(json_object)

    def _history(self, json_object):
        """Add json_object to the status history file."""
        # Seek the last line added, since the following line contains the
        # list-ending ']', which must be overwritten to conform with JSON
        # syntax.
        if self._offsetOfLastLine > -1:
            self._history_fd.seek(self._offsetOfLastLine)
        if self._offsetOfLastLine == 2:
            self._history_fd.seek(self._offsetOfLastLine - 1)

        if self._offsetOfLastLine != -1 and self._offsetOfLastLine != 2:
            self._history_fd.write(",\n")
        self._history_fd.write("%s" % (json_object))
        # Memorize the offset of the last line.
        self._offsetOfLastLine = self._history_fd.tell()
        # Add list-ending character
        self._history_fd.write("]")
        self._history_fd.flush()

    def _error(self, json_object):
        self._error_fd.acquire(blocking=False)
        self._error_fd.truncate(0)
        self._error_fd.seek(0)
        self._error_fd.write("%s" % json_object)
        self._error_fd.release()

    def close(self):
        """Release lock and remove the status file."""
        self._status_fd.release()
        try:
            os.unlink(self._status_file)
        except IOError, e:
            print("Couldn't unlink mutexfile: %s" % (e))


class ServiceNotification:

    """Notification class for services.

    Provide a generic JSON interface for Endian Firewall services or
    restartscripts to publish status updates displayed on the Endian Firewall
    Web UI.

    Each status update is represented by a json object, containing the
    following attributes:
        msg -- precise description of the status
        type -- either info or error.
                info is used to display status updates.
                error is used to inform the user about an error which occured.

                Notice: types may be extended in future.
        date -- a timestamp reflecting the time when the status was published

    An Example entry:
    {msg: "Reading SNORT configuration...", type: "info", date: 1214821339}

    The created JSON File conforms to the following syntax:

    [{msg: "Reading SNORT configuration...", type: "info", date: "1214821339"},
     {msg: "Applying migration rules...", type: "info", date: "1214821345"}]

    Public methods:
        update -- publish an update of the status of the service
        end -- end notification.

    """

    def __init__(self, name):
        """Constructor. Defines the name used to identify the service.

        The JavaScript client uses name to subscribe to the service.

        """
        if not name:
            raise InvalidNameError("Name must not be empty.")
        self.isOpen = False

        self._name = name
        try:
            self._status_file = StatusFile(STATUSFILE % self._name)
            self.isOpen = True
        except IOError, e:
            print("%s" % (e))

    def update(self, msg):
        """Post an update of the service status."""
        # Add the message to the status file
        if not self.isOpen:
            return
        self._status_file.write({'msg': msg, 'type': 'info',
                                 'time': time()})

    def error(self, msg):
        """Post an error wich occured during execution of the service."""
        # Add the message to the status file. Use error as type
        if not self.isOpen:
            return
        self._status_file.write({'msg': msg, 'type': 'error',
                                 'time': time()})

    def end(self):
        """Tell subscribers that no notifications will follow."""
        if not self.isOpen:
            return
        self._status_file.close()
        self.isOpen = False

