#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import iplib
import math

__all__ = ['AlreadyInUseException', 'ReservedNetworks', 'AddressNotInRange', 'AddressSpaceExhausted']

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2011-08-26"

# Private Networks (RFC 1918)
PRIVATE_NETWORKS = [
    iplib.CIDR('10.0.0.0/8'),
    iplib.CIDR('172.16.0.0/12'),
    iplib.CIDR('192.168.0.0/16')
]

# Special Networks (RFC 5735)
SPECIAL_NETWORKS = [
    iplib.CIDR('0.0.0.0/8'),           # "This" Network             RFC 1122, Section 3.2.1.3
    iplib.CIDR('127.0.0.0/8'),         # Loopback                   RFC 1122, Section 3.2.1.3
    iplib.CIDR('169.254.0.0/16'),      # Link Local                 RFC 3927
    iplib.CIDR('192.0.0.0/24'),        # IETF Protocol Assignments  RFC 5736
    iplib.CIDR('192.0.2.0/24'),        # TEST-NET-1                 RFC 5737
    iplib.CIDR('192.88.99.0/24'),      # 6to4 Relay Anycast         RFC 3068
    iplib.CIDR('198.18.0.0/15'),       # Network Interconnect, Device Benchmark Testing   RFC 2544
    iplib.CIDR('198.51.100.0/24'),     # TEST-NET-2                 RFC 5737
    iplib.CIDR('203.0.113.0/24'),      # TEST-NET-3                 RFC 5737
    iplib.CIDR('224.0.0.0/4'),         # Multicast                  RFC 3171
    iplib.CIDR('240.0.0.0/4'),         # Reserved for Future Use    RFC 1112, Section 4
]

class AlreadyInUseException(Exception):

    def __init__(self, cidr, used_by):
        self.cidr = cidr
        self.used_by = used_by
        Exception.__init__(self, "%s conflicts with %s" % (self.cidr, ",".join(self.used_by)))

class AddressNotInRange(Exception):

    def __init__(self, cidr):
        self.cidr = cidr
        Exception.__init__(self, "%s not in range" % (self.cidr))

class AddressSpaceExhausted(Exception):
    pass

class CIDRNode(object):
    bits = None # address (as a list of bits) of this node
    depth = None # Node depth (0 is the root node)
    children = None # child 0 and child 1
    reserved = 0 # if > 0, this node is partof a reserved network address
    reserved_children = 0 # number of reserved children nodes
    cidrs = None # list of cidrs sharing this node
    addresses = 0 # number of used addresses under this node

    def __init__(self, bits=[]):
        """
            Create a CIDRNode instance usign a list of bits as address
        """
        self.bits = bits
        self.depth = len(bits)
        if self.depth > 32:
            raise ValueError("Max depth reached")
        self.children = [None, None]
        self.cidrs = []

    def __getitem__(self, key):
        """
            Get one of the child (child 0 or child 1)
            Create the child if it does not exist.
            Raise KeyError if the key is invalid (not 0 or 1) or
            if the max depth is reached.

            :param key: 0 or 1
            :type key: int
        """
        if key not in [0, 1]:
            raise KeyError(key)
        child = self.children[key]
        if not child:
            try:
                child = self.children[key] = CIDRNode(self.bits + [key])
                self.children[key] = child
            except ValueError:
                raise KeyError(key)
        return child

    def get(self, bits):
        """
            Get a CIDRNode instance by its relative address

            :param bits: the relative address
            :type bits: a list of int
        """
        if not bits:
            return self
        head = bits[0]
        tail = bits[1:]
        child = self[head]
        return child and child.get(tail) or None

    def add(self, bits, cidr, addresses, check_only=False, force=False):
        """
            Reserve a network identified by its relative address
            as a list of bits.

            :param bits: the relative address
            :type bits: a list of int
            :param cidr: the complete network address
            :type cidr: string
            :param addresses: the number of addresses to be reserved
            :type addresses: int
        """
        if self.reserved and not force:
            raise AlreadyInUseException(cidr=cidr, used_by=self.cidrs)
        if not bits:
            if self.cidrs and not force:
                raise AlreadyInUseException(cidr=cidr, used_by=self.cidrs)
            if not check_only:
                self.cidrs.append(cidr)
                self.reserved += 1
                # Increment the number of reserved addresses
                self.addresses = self.addresses + addresses
            return self
        else:
            head = bits[0]
            tail = bits[1:]
            child = self[head]
            child.add(tail, cidr, addresses, check_only=check_only, force=force)
            if not check_only:
                # Add this cidr to the cidrs set after calling 'child.add',
                # because 'child.add' can raise an exception
                self.cidrs.append(cidr)
                # Increment the number of reserved addresses
                self.addresses = self.addresses + addresses
                # Increment the number of reserved children
                self.reserved_children += 1
            return child

    def remove(self, bits, cidr, addresses):
        """
            Remove a network identified by its relative address
            as a list of bits.
            Raise a KeyError exception if the network is not present

            :param bits: the relative address
            :type bits: a list of int
            :param cidr: the complete network address
            :type cidr: string
            :param addresses: the number of addresses to be reserved
            :type addresses: int
        """
        try:
            self.cidrs.remove(cidr)
        except:
            raise KeyError(cidr)

        if bits:
            head = bits[0]
            tail = bits[1:]
            child = self[head]
            child.remove(tail, cidr, addresses)
            # Decrement the number of reserved addresses
            self.addresses = self.addresses - addresses
            # Decrement the number of reserved children
            self.reserved_children -= 1
        else:
            if not self.reserved:
                raise KeyError(cidr)
            else:
                # Decrement the number of reserved addresses
                self.reserved -= 1
                self.addresses = self.addresses - addresses

    def search(self, addresses):
        """
            Search for a free network of a given size.

            :param addresses: the number of addresses to be reserved
            :type addresses: int
            :return: the cidr address ot the network or None
            :rtype: string
        """
        if addresses > self.available_addresses:
            return None
        if self.addresses == 0:
            d = 32 - int(math.ceil(math.log(addresses, 2)))
            cidr = "%s/%s" % (self.ip, d)
            return cidr
        return self[0].search(addresses) or self[1].search(addresses)

    @property
    def available_addresses(self):
        """
            Number of available addresses under this node
            Warning! If there are some 'forced' network. this number is wrong!
        """
        return int(math.pow(2, 32 - self.depth)) - self.addresses

    @property
    def ip(self):
        """ Ip address (without netmask) """
        bits_string = "".join([str(x) for x in self.bits]) + ('0' * (32 - len(self.bits)))
        return iplib.convert(bits_string, inotation=iplib.IP_BIN)

    def count_reserved_in_path(self, bits):
        """
            Count the number of reserved ancestor, include the node itself
            (i.e. sum all the 'reserved' fields in the path)

            :param bits: the relative address
            :type bits: a list of int
        """
        result = self.reserved
        if bits:
            head = bits[0]
            tail = bits[1:]
            child = self[head]
            result += child and child.count_reserved_in_path(tail) or 0
        return result

    @property
    def largest_available_block_size(self):
        """
            Return the size of the largest available block
        """
        if self.reserved:
            return 0
        if self.reserved_children == 0:
            return int(math.pow(2, 32 - self.depth))
        try:
            c0 = self.children[0].largest_available_block_size
        except AttributeError:
            return int(math.pow(2, 32 - (self.depth+1)))
        try:
            c1 = self.children[1].largest_available_block_size
        except AttributeError:
            return int(math.pow(2, 32 - (self.depth+1)))
        return max(c0, c1)

    def __repr__(self):
        return self.__str__()

    def __str__(self):
        return "%s/%s" % (self.ip, self.depth)

    def cidr_to_bits(self, cidr, check_range=True):
        """
            Convert a CIDR address into a list of bits.
            The length of the list depends on the CIDR, e.g.:
            cidr_to_bits('192.168.0.0/16') = [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0]
            cidr_to_bits('192.168.0.0/24') = [1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            Raise an AddressNotInRange exception if the given address
            is outside the address space of this node.

            :param cidr: a network address in CIDR notation or
            :type cidr: string or iplib.CIDR
        """
        if isinstance(cidr, iplib.CIDR):
            c = cidr
        else:
            cidr = str(cidr)
            if not '/' in cidr:
                cidr = cidr + '/32' # add the netmask if is not present
            c = iplib.CIDR(cidr)
        bits = int(c.get_netmask().get_bits())
        addr = c.ip.get_bin()
        addr = '0' * (32 - len(addr)) + addr
        addr = addr[:bits]
        result = [x == '1' and 1 or 0 for x in addr]
        if check_range and self.bits and self.bits != result[:len(self.bits)]:
            raise AddressNotInRange(cidr=c)
        return result

    @staticmethod
    def cidr_to_str(cidr):
        """
            Convert a CIDR address to a string.

            :param cidr: a network address in CIDR notation or
            :type cidr: string or iplib.CIDR
        """
        if isinstance(cidr, iplib.CIDR):
            return "%s/%s" % (cidr.get_ip(), cidr.get_netmask().get_bits())
        else:
            cidr = str(cidr)
            if not '/' in cidr:
                cidr = cidr + '/32' # add the netmask it is not present
        return cidr

class ReservedNetworks(object):
    """
        Manage a list of reserved networks
    """

    def __init__(self, special_networks=SPECIAL_NETWORKS, private_networks=PRIVATE_NETWORKS, address_range=None):
        self.root = CIDRNode()
        # Prepare the private networks list
        if not private_networks:
            private_networks = []
        elif not isinstance(private_networks, (list, tuple)):
            private_networks = [private_networks]
        self.private_networks = [isinstance(x, iplib.CIDR) and x or iplib.CIDR(x) for x in private_networks]
        # Add the special networks as reserved networks (before setting the address range)
        self.address_range = self.root
        for network in special_networks or []:
            self.add(network)
        # Parse the address_range parameter if present
        if address_range:
            self.address_range = self.root.get(self.root.cidr_to_bits(address_range, check_range=False))

    def add(self, cidr, force=False):
        """
            Add a network to the reserved networks

            :raises AlreadyInUseException: if the network is not reservable
            :raises AddressNotInRange: if the cidr is outside the address range
            :param cidr: a network address in CIDR notation
            :type cidr: string or iplib.CIDR
        """
        bits = self.address_range.cidr_to_bits(cidr, check_range=True)
        addresses = int(math.pow(2, 32 - len(bits)))
        self.root.add(bits, self.root.cidr_to_str(cidr), addresses, force=force)

    def remove(self, cidr):
        """
            Remove a network from the reserved networks

            :raises KeyError: if the network is not present
            :raises AddressNotInRange: if the cidr is outside the address range
            :param cidr: a network address in CIDR notation
            :type cidr: string or iplib.CIDR
        """
        bits = self.address_range.cidr_to_bits(cidr, check_range=True)
        addresses = int(math.pow(2, 32 - len(bits)))
        self.root.remove(bits, self.root.cidr_to_str(cidr), addresses)

    def search(self, addresses, address_range=None):
        """
            Search for a free network address in a given address range

            :raises AddressNotInRange: if the cidr is outside the address range
            :param addresses: required size for the network
                              (in number of addresses)
            :type addresses: int
            :param address_range: a network address in CIDR notation
            :type address_range: string or iplib.CIDR
            :return: return a network in CIDR notation or None if there is not enough space
            :rtype: string
        """
        if not address_range:
            node = self.address_range
        else:
            address_range_bits = self.address_range.cidr_to_bits(address_range, check_range=True)
            node = self.root.get(address_range_bits)
        return node.search(addresses)

    def search_alternative(self, cidr):
        """
            Search for an alternative address for a given (not free) network

            :param cidr: a (not free) network address in CIDR notation
            :type cidr: string or iplib.CIDR
            :return: return a network in CIDR notation or None if there is not enough space
            :rtype: string
        """
        address_range = None
        if not isinstance(cidr, iplib.CIDR):
            cidr = iplib.CIDR(cidr)
        for private_network in self.private_networks:
            if cidr in private_network:
                address_range = private_network
                break
        bits = int(cidr.get_netmask().get_bits())
        addresses = int(math.pow(2, 32-bits))
        return self.search(addresses=addresses, address_range=address_range)

    def search_and_add(self, addresses, address_range=None):
        """
            Search for a free network address (in a given address range) to be allocated

            :raises AddressSpaceExhausted: if there is not enough allocable space
            :param addresses: required size for the network
                              (in number of addresses)
            :type addresses: int
            :param address_range: a network address in CIDR notation
            :type address_range: string or iplib.CIDR
            :return: return a network in CIDR notation
            :rtype: string
        """
        cidr = self.search(addresses=addresses, address_range=address_range)
        if not cidr:
            raise AddressSpaceExhausted()
        self.add(cidr)
        return cidr

    def search_and_add_alternative(self, cidr):
        """
            Search and allocate an alternative address of the same size of
            the given (not free) network.

            :raises AddressSpaceExhausted: if there is not enough allocable space
            :param cidr: a (not free) network address in CIDR notation
            :type cidr: string or iplib.CIDR
            :return: return a network in CIDR notation
            :rtype: string
        """
        cidr = self.search_alternative(cidr=cidr)
        if not cidr:
            raise AddressSpaceExhausted()
        self.add(cidr)
        return cidr

    def is_in_conflict(self, cidr):
        """
            Check if an existing network
            (i.e. a network that is just present in the reserved network list)
            is in conflicts with other networks

            :raises AddressNotInRange: if the cidr is outside the address range
            :param cidr: a network address in CIDR notation
            :type cidr: string or iplib.CIDR
            :return True is the given network is in conflict with other networks,
                    False otherwise
            :rtype: boolean
        """
        bits = self.address_range.cidr_to_bits(cidr, check_range=True)
        reserved_in_path = self.root.count_reserved_in_path(bits)
        if reserved_in_path == 0:
            return False
        else:
            reserved_children = self.root.get(bits).reserved_children
            return reserved_in_path + reserved_children > 1

    def is_available(self, cidr):
        """
            Check if a network is available.

            :raises AddressNotInRange: if the cidr is outside the address range
            :param cidr: a network address in CIDR notation
            :type cidr: string or iplib.CIDR
            :return: return True if the network is free, False otherwise
            :rtype: string
        """
        bits = self.address_range.cidr_to_bits(cidr, check_range=True)
        addresses = int(math.pow(2, 32 - len(bits)))
        try:
            self.root.add(bits, self.root.cidr_to_str(cidr), addresses, check_only=True)
            return True
        except AlreadyInUseException:
            return False

    def __contains__(self, cidr):
        """
            Check if a network is in use (not free).

            :param cidr: a network address in CIDR notation
            :type cidr: string or iplib.CIDR
            :return: return False if the network is free, True otherwise
            :rtype: string
        """
        bits = self.address_range.cidr_to_bits(cidr, check_range=False)
        addresses = int(math.pow(2, 32 - len(bits)))
        try:
            self.root.add(bits, self.root.cidr_to_str(cidr), addresses, check_only=True)
            return False
        except AlreadyInUseException:
            return True

    def __iter__(self):
        """
            Iterate over the set of the reserved networks
        """
        return self.address_range.cidrs.__iter__()

    def __len__(self):
        """
            Return the number of reserved networks
        """
        return self.address_range.cidrs.__len__()

    @property
    def addresses(self):
        """ Number of reserved addresses """
        return self.address_range.addresses

    @property
    def available_addresses(self):
        """
            Number of not reserved addresses
            Warning! If there are some 'forced' networks
            (i.e. networks conflicts), this number is wrong!
        """
        return self.address_range.available_addresses

    @property
    def largest_available_block_size(self):
        """
            Return the size of the largest available block
        """
        return self.address_range.largest_available_block_size

    def __str__(self):
        return str(self.address_range.cidrs)

    def __repr__(self):
        return repr(self.address_range.cidrs)

