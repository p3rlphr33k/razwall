#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

"""Generic daemon class which implements all generic handling
which is necessary to have a daemon work correctly in a linux
environment.
"""

from endian.core.logger import debug, info, error, logger, logging, setLogfile, reopenLogfile, DEVELDEBUG
from optparse import OptionParser, OptionGroup
from endian.core.pidfile import Pidfile
from endian.core import filetools
import sys

import os
import signal
from os import dup2

def daemonize(stdoutlog = "/dev/null", stderrlog = "/dev/null", pidfile = None, cwd="/"):
    """Detach a process from the controlling terminal and run it in the
    background as a daemon.
    """

    if stdoutlog == None:
        stdoutlog = "/dev/null"
    if stderrlog == None:
        stderrlog = "/dev/null"
    try:
        pid = os.fork()
    except OSError, e:
        # ERROR (return a tuple)
        return((e.errno, e.strerror))

    if (pid != 0):
        # Exit parent of the first child.
        os._exit(0)

    # The first child.
    os.setsid()
    signal.signal(signal.SIGHUP, signal.SIG_IGN)

    try:
        # Fork a second child.
        pid = os.fork()
    except OSError, e:
        # ERROR (return a tuple)
        return((e.errno, e.strerror))

    if (pid != 0):
        # Exit parent (the first child) of the second child.
        os._exit(0)

    # The second child.
    os.chdir(cwd)
    # Give the child complete control over permissions.
    os.umask(022)

    try:
        # close stdin, otherwise the other side would never
        # become an EOF if it is connected with /dev/null.
        # children normally do not close stdin. That's the job
        # of the caller.
        os.close(0)

        # standard output (1)
        cstdout = os.open(stdoutlog, os.O_RDWR | os.O_CREAT | os.O_APPEND)
        dup2 (cstdout, 1)
        if cstdout > 2:
            os.close(cstdout)

        # standard error (2)
        cstderr = os.open(stderrlog, os.O_RDWR | os.O_CREAT | os.O_APPEND)
        dup2 (cstderr, 2)
        if cstderr > 2:
            os.close(cstderr)

    except Exception, e:
        try:
            f = open('/var/log/daemonize.log', 'a')
            f.write("* ERROR: %s\n" % e)
            f.close()
        except:
            pass

    if pidfile == None:
        return (0)
    try:
        f = open(pidfile, 'w')
        f.write("%s"%os.getpid())
        f.close()
    except Exception, e:
        print "* ERROR creating PID file: %s\n" % e
    return(0)


PIDFILE="/var/run/%(name)s.pid"
CONFIGFILE="/etc/%(name)s/%(name)s.conf"

LOGLEVEL={
    0: logging.INFO,
    1: logging.DEBUG,
    2: DEVELDEBUG
    }

# signal handlers cannot call methods, thus
# these routines cannot be inside Daemon class
_signalHandlers = {}
def registerSignalHandler(sig, callbacks):
    """
    register one or more signal handlers for the specified signal 'sig'.

    The Daemon() class installs these handlers after daemonizing and
    calls every registered handler for the appropriate signal.
    """
    if sig not in _signalHandlers:
        _signalHandlers[sig] = []
    sigObj = _signalHandlers[sig]
    debug("Register handler %s for signal '%s'" % (callbacks, sig))
    if type(callbacks) == type([]):
        sigObj.extend(callbacks)
    else:
        sigObj.append(callbacks)

def _handleSignals(signum, frame):
    debug("Call signal handlers for signal '%s'" % signum)
    callbacks = _signalHandlers[signum]
    if not callbacks:
        debug("No callbacks registered for signal '%s'" % signum)
        return
    debug("Signal '%s' has %s registered callbacks" % (signum, len(callbacks)))
    i = 0
    for cb in callbacks:
        i += 1
        debug("Call signal handler %s for signal '%s'" % (i, signum))
        cb(signum, frame)

def _installHandlers():
    for sig in _signalHandlers:
        debug("Install signal handler for signal '%s'" % sig)
        signal.signal(sig, _handleSignals)

class MainLoopExit(SystemExit):
    """
    Will be thrown if an application decides to reload itself
    and for this need to exit from its main loop in order to
    re-instantiate itself.
    """
    pass

class Daemon(object):
    def __init__(self, name=sys.argv[0]):
        self.name = os.path.basename(name)
        self.optparser = self._registerDefaultOptions()
        self.pid = None
        self.options = None
        self.arguments = None
        self.altConfigFile = None
        self.addSearchPath = None
        self.catchTracebacks = False

    def getOptionParserGroup(self, title="Custom Daemon Options"):
        custom = OptionGroup(self.optparser, title)
        self.optparser.add_option_group(custom)
        return custom

    def _registerDefaultOptions(self):
        usage = "usage: %prog <options>"
        parser = OptionParser(usage)
        generic = OptionGroup(parser, "Generic Daemon Options")
        parser.add_option_group(generic)
        generic.add_option("-p", "--pidfile", dest="pidfile",
                          help="Specify where to store the pidfile",
                          metavar="PIDFILE")
        generic.add_option("-D", "--daemonize", dest="daemonize",
                          action="store_true",
                          help="Daemonize", default=False)
        generic.add_option("-d", "--debug", dest="debug",
                          action="count",
                          help="Increase verbosity.", default=0)
        generic.add_option("-l", "--logfile", dest="logfile",
                          metavar="LOGFILE",
                          help="Specify the file where to log"
                           "Default is syslog")
        generic.add_option("-c", "--config", dest="configfile",
                          metavar="CONFIG", default="SEARCH",
                          help="Read configuration from CONFIG")
        generic.add_option("--user", dest="user",
                          help="Change user to USER", default=None,
                          metavar="USER")
        generic.add_option("--group", dest="group",
                          help="Change group to GROUP", default=None,
                          metavar="GRUP")

        return parser

    def opthandler(self):
        if self.options != None:
            return
        (o,a) = self.optparser.parse_args()
        self.options = o
        self.arguments = a

        if o.pidfile == None:
            o.pidfile = PIDFILE % self.__dict__
        if o.debug >= len(LOGLEVEL):
            o.debug = len(LOGLEVEL)-1
        logger.setLevel(LOGLEVEL[o.debug])
        if o.logfile:
            setLogfile(o.logfile)

        if o.configfile == 'SEARCH':
            o.configfile = filetools.searchPath(
                self.name + '.conf',
                appendSearchPath=self.addSearchPath,
                altname=self.altConfigFile
                )

        debug("Got options: %s" % o)
        debug("Got arguments: %s" % a)

    def cleanup(self):
        debug("Cleanup")
        if self.pid:
            self.pid.remove()

    def do(self, *args, **kwargs):
        pass

    def reload(self):
        debug("Got SIGHUP. Reloading")
        pass

    def run(self, *args, **kwargs):
        self.opthandler()

        if not self.options.user:
            uid = -1
        else:
            import pwd
            try:
                uid = pwd.getpwnam(self.options.user)[2]
            except KeyError:
                error("User '%s' not found" % self.options.user)
                sys.exit(2)

        if not self.options.group:
            gid = -1
        else:
            import grp
            try:
                gid = grp.getgrnam(self.options.group)[2]
            except KeyError:
                error("Group '%s' not found" % self.options.group)
                sys.exit(2)

        if self.options.daemonize:
            self.pid = Pidfile(self.options.pidfile)

            if self.pid.isRunning():
                error("Another instance of %s is already running "
                      "with pid '%s'. Exiting..." % (self.name, self.pid.pid))
                sys.exit(1)

            # Create the pid file if it does not exist, change the user/group
            # of the pid file and change the current user
            if uid != -1 or gid != -1:
                open(self.options.pidfile, 'a').close()
                os.chown(self.options.pidfile, uid, gid)
                if gid != -1:
                    os.setgid(gid)
                    os.setgroups([gid])
                if uid != -1:
                    os.setuid(uid)

            debug("%s daemon goes background"%self.name)

            e = daemonize(stdoutlog="/dev/null",
                          stderrlog="/dev/null",
                          pidfile=None)
            if e:
                error("Could not daemonize %s (%s)" % (self.name,e[1]))

            self.pid = Pidfile(self.options.pidfile)
            try:
                debug("Creating pid file '%s' with pid '%s'."%(
                        self.options.pidfile, self.pid.mypid))
                self.pid.create()
            except Exception, e:
                error("Could not create pid file '%s' (%s). Exiting..." % (
                        self.options.pidfile, e))
                debug("Could not create pid file '%s' (%s). Exiting..." % (
                        self.options.pidfile, e), exc_info=True)
                sys.exit(1)

        _installHandlers()
        signum = -1
        while True:
            try:
                try:
                    # reload configuration on SIGHUP
                    # exit on all other signals which let run() return from
                    # it's infinite loop
                    signum = self.do(*args, **kwargs)
                except MainLoopExit:
                    continue
                except SystemExit:
                    raise
                except KeyboardInterrupt:
                    debug("Interrupted by Keyboard. Exiting...")
                    raise
                except:
                    if self.catchTracebacks:
                        error("Traceback:", exc_info=True)
                self.options.ensure_value('onecycle', False)
                if self.options.onecycle:
                    info("Single cycle is finished. Exiting...")
                    break
                else:
                    if signum == signal.SIGHUP:
                        info("Got SIGHUP. Reloading configuration files...")
                        self.reload()
                        if self.options.logfile:
                            reopenLogfile()
                    else:
                        info("Got signal. Exiting...")
                        break
            except SystemExit:
                raise
            except Exception, e:
                # daemon should not crash because of tracebacks
                if not self.catchTracebacks:
                    self.cleanup()
                    raise e

        self.cleanup()

if __name__ == '__main__':

    class TestDaemon(Daemon):
        def do(self, *args, **kwargs):
            return
            #while True:
            #  time.sleep(60)

    a = TestDaemon("processname")
    b = a.getOptionParserGroup()
    b.add_option("-t", dest="test")
    a.run()

