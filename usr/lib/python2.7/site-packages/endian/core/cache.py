#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2008-01-28"

"""
Implements a generic object cache
"""


class CacheException(Exception):
    pass
class CacheExpiredException(CacheException):
    pass
class CacheMissException(CacheException):
    pass

import time
import threading
import os
import stat

from endian.core.pattern import ThreadableObserver

class CacheObject(object):
    def __init__(self, value):
        self.data = value
        self.expired = False
        self.timestamp = time.time()
        self.onExpire = ThreadableObserver()
        self.onPut = ThreadableObserver()
        self.onGet = ThreadableObserver()
        self.lock = threading.Lock()

    def expire(self, quiet=False):
        self.lock.acquire()
        self.expired = True
        observer = self.onExpire
        self.lock.release()
        if quiet:
            return

        # must be outside of mutex block, otherwise it
        # could cause a deadlock, when one of the observer points
        # back to this object
        observer.update()

    def get(self):
        self.lock.acquire()
        ret = self.data
        expired = self.expired
        self.lock.release()
        if expired:
            raise CacheExpiredException("Item expired")
        return ret

    def __repr__(self):
        ret = "CacheObject {'timestamp': %(timestamp)s, 'expired': %(expired)s, " % self.__dict__
        ret += "'data': %s, " % object.__repr__(self.data)
        ret += "'# onExpire': %s, " % len(self.onExpire.data)
        ret += "'# onPut': %s, " % len(self.onPut.data)
        ret += "'# onGet': %s " % len(self.onGet.data)
        ret += "}"
        return ret


class Expirer(object):
    registry = {}
    keys = []
    @classmethod
    def isValid(self, obj, key=None):
        if obj.data == None:
            raise CacheExpiredException("Cache item is None")
        if obj.expired:
            raise CacheExpiredException("Cache item expired")
        for i in Expirer.keys:
            if isinstance(i, str):
                if i != key:
                    continue
            elif isinstance(i, tuple):
                if not isinstance(obj.data, i[0]):
                    continue
                if i[1] != key:
                    continue
            else:
                if not isinstance(obj.data, i):
                    continue
            expired = False
            try:
                expired = self.registry[i](obj)
            except Exception, e:
                obj.expire()
                raise CacheExpiredException("Cache item expired due to '%s'"%e)
            if expired:
                obj.expire()
                raise CacheExpiredException("Cache item expired")
    @classmethod
    def register(self, method, cls=None, key=None):
        if cls == None and key == None:
            raise TypeError("register expected at least 2 arguments, got 1. Class OR key Or both need to be submitted!")
        store = key
        if cls:
            store = cls
            if key:
                store = (cls, key)
        self.registry[store] = method
        Expirer.keys = self.registry.keys()
        Expirer.keys.sort()
        Expirer.keys.reverse()

class TimeExpirer(object):
    """
    Is an expirer which allows to define a timeout 
    of how long the object should be kept in cache.
    """
    def __init__(self, timeout):
        self.timeout = timeout
    def isExpired(self, obj):
        if obj.timestamp + self.timeout < time.time():
            return True
        return False
    def __call__(self, obj):
        return self.isExpired(obj)

def fsExpirer(fsitem, timestamp):
    try:
        filetime = os.stat(fsitem)[stat.ST_MTIME]
        if timestamp < filetime:
            return True
        return False
    except OSError:
        # if the file does not exist anymore, the
        # content is expired
        return True

class Cache(object):
    def __init__(self):
        self.data = {}
        self.lock = threading.Lock()

    def get(self, key):
        ret = None
        try:
            self.lock.acquire()
            try:
                ret = self.data[key]
            finally:
                self.lock.release()
        except KeyError:
            raise CacheMissException("Cache miss of key '%s'"%key)
        Expirer.isValid(ret, key)
        ret.onGet.update()
        return ret

    def put(self, key, value, 
            onExpire=None,
            onPut=None,
            onGet=None):
        obj = CacheObject(value)
        if onExpire != None:
            obj.onExpire.register(onExpire)
        if onPut != None:
            obj.onPut.register(onPut)
        if onGet != None:
            obj.onGet.register(onGet)

        self.lock.acquire()
        if key in self.data:
            oldObj = self.data[key]
            if oldObj.onExpire:
                obj.onExpire = oldObj.onExpire
            if oldObj.onPut:
                obj.onPut = oldObj.onPut
            if oldObj.onGet:
                obj.onGet = oldObj.onGet

        self.data[key] = obj
        self.lock.release()
        obj.onPut.update()
        return obj

    def setDirty(self, key):
        ret = None
        try:
            self.lock.acquire()
            try:
                ret = self.data[key]
            finally:
                self.lock.release()
        except KeyError:
            # is not in cache so no need for
            # making it dirty
            return
        ret.expire(quiet=True)
        
        

    def __repr__(self):
        return "Cache: %s" % self.data


if __name__ == '__main__':
    cache = Cache()
    print "Expirator which expires cached testkey item after 2 seconds"
    Expirer.register(TimeExpirer(10), "testkey")
    print "Put time item in cache: %s" % cache.put("testkey", time.time()).get()
    while True:
        print "Now: %s " % time.time()
        try:
            print "Cached item: %s" % cache.get("testkey").get()
        except CacheException:
            print "Cache item expired!"
            break
        time.sleep(1)
