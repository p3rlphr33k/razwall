#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2013-08-29"

import os
import time
import shutil
import threading
from UserDict import DictMixin
try:
    import cPickle as pickle
except:
    import pickle
try:
    import yaml
    try:
        from yaml import CLoader as Loader, CSafeDumper as SafeDumper 
    except ImportError:
        from yaml import Loader, SafeDumper
except:
    pass
from endian.core.holistic_lock import HolisticLock

__all__ = ['PersistentDict',
           'ReadOnlyPersistentDict',
           'FORMAT_PICKLE',
           'FORMAT_YAML',
          ]

FORMAT_PICKLE = "pickle"
FORMAT_YAML = "yaml"

class PersistentDict(DictMixin):
    """
        Persistent dictionary, stored with pickle (default) or YAML
    """

    def __init__(self, filename, format=FORMAT_PICKLE, *args, **kargs):
        self._dict = dict(*args, **kargs)
        self._format = format and format.lower() or FORMAT_PICKLE
        self.filename = filename
        self._hlock = HolisticLock(filename + '.lck')
        self._hlock.acquire()
        self._get_modification_time_lock = threading.Lock()
        if os.access(self.filename, os.R_OK):
            f = open(self.filename, 'rb')
            try:
                try:
                    if self._format == FORMAT_YAML:
                        self._dict.update(yaml.load(f.read(), Loader=Loader))
                    else:
                        self._dict.update(pickle.load(f))
                    self._inode = self._get_inode()
                    self._time = self._get_modification_time()
                except Exception:
                    self._time = time.time()
                    self._inode = 0
            finally:
                f.close()
        else:
            self._sync() # create an empty file
        self._hlock.release()

    def sync(self):
        """
            Store the content of the dictionary on the disk
        """
        try:
            self._lock()
            self._sync()
        finally:
            self._unlock()

    def _sync(self):
        filename = self.filename
        temp_filename = filename + '.tmp'
        f = open(temp_filename, 'wb')
        try:
            try:
                if self._format == FORMAT_YAML:
                    f.write(yaml.dump(self._dict, Dumper=SafeDumper))
                else:
                    pickle.dump(dict(self._dict), f, 2)
            except Exception:
                os.remove(temp_filename)
                raise
        finally:
            f.close()
        shutil.move(temp_filename, self.filename)
        self._inode = self._get_inode()
        self._time = self._get_modification_time()

    def check(self):
        """
            Check if the file has been updated after the last loading
        """
        if not os.access(self.filename, os.R_OK):
            self._time = time.time()
            self._inode = 0
            self._dict = {}
        elif self._inode != self._get_inode() or self._time < self._get_modification_time():
            f = open(self.filename, 'rb')
            try:
                try:
                    new_dict = dict()
                    if self._format == FORMAT_YAML:
                        new_dict.update(yaml.load(f.read(), Loader=Loader))
                    else:
                        new_dict.update(pickle.load(f))
                    self._dict = new_dict
                    self._time = self._get_modification_time()
                except Exception:
                    pass
            finally:
                f.close()

    def _get_inode(self):
        """
            Return the file inode number

            :return: inode number or 0
            :rtype: long
        """
        try:
            return os.stat(self.filename).st_ino
        except:
            return 0

    def _get_modification_time(self):
        """
            Return the file modification time

            :return: file modification time or 0
            :rtype: float
        """
        try:
            self._get_modification_time_lock.acquire()
            stat_float_times = os.stat_float_times()
            os.stat_float_times(True)
            try:
                return os.path.getmtime(self.filename)
            except:
                return 0
        finally:
            os.stat_float_times(stat_float_times)
            self._get_modification_time_lock.release()

    def _lock(self):
        self._hlock.acquire()
        self.check()

    def _unlock(self, sync=False):
        if sync:
            self._sync()
        self._hlock.release()

    def __getitem__(self, key):
        try:
            self._lock()
            return self._dict.__getitem__(key)
        finally:
            self._unlock()

    def __setitem__(self, key, value):
        try:
            self._lock()
            return self._dict.__setitem__(key, value)
        finally:
            self._unlock(sync=True)

    def __delitem__(self, key):
        try:
            self._lock()
            return self._dict.__delitem__(key)
        finally:
            self._unlock(sync=True)

    def __contains__(self, key):
        try:
            self._lock()
            return self._dict.__contains__(key)
        finally:
            self._unlock()

    def __iter__(self):
        try:
            self._lock()
            return self._dict.__iter__()
        finally:
            self._unlock()

    def __len__(self):
        try:
            self._lock()
            return self._dict.__len__()
        finally:
            self._unlock()

    def __repr__(self):
        try:
            self._lock()
            return self._dict.__repr__()
        finally:
            self._unlock()

    def __str__(self):
        try:
            self._lock()
            return self._dict.__str__()
        finally:
            self._unlock()

    def keys(self):
        """
            Return a copy of the dictionary’s list of keys.
        """
        try:
            self._lock()
            return self._dict.keys()
        finally:
            self._unlock()

    def values(self):
        """
            Return a copy of the dictionary’s list of (key, value) pairs.
        """
        try:
            self._lock()
            return self._dict.values()
        finally:
            self._unlock()

    def items(self):
        """
            Test for the presence of key in the dictionary.
        """
        try:
            self._lock()
            return self._dict.items()
        finally:
            self._unlock()

    def iteritems(self):
        """
            Return an iterator over the dictionary’s (key, value) pairs.
        """
        try:
            self._lock()
            return self._dict.iteritems()
        finally:
            self._unlock()

    def iterkeys(self):
        """
            Return an iterator over the dictionary’s keys.
        """
        try:
            self._lock()
            return self._dict.iterkeys()
        finally:
            self._unlock()

    def itervalues(self):
        """
            Return an iterator over the dictionary’s values.
        """
        try:
            self._lock()
            return self._dict.itervalues()
        finally:
            self._unlock()

    def has_key(self, key):
        """
            Test for the presence of key in the dictionary.
        """
        try:
            self._lock()
            return self._dict.has_key(key)
        finally:
            self._unlock()

    def update(self, *args, **kargs):
        """
            Update the dictionary with the key/value pairs from other, overwriting existing keys
        """
        try:
            self._lock()
            return self._dict.update(*args, **kargs)
        finally:
            self._unlock(sync=True)

    def clear(self):
        """
            Remove all items from the dictionary.
        """
        try:
            self._lock()
            return self._dict.clear()
        finally:
            self._unlock(sync=True)

    def pop(self, *args, **kargs):
        """
            If key is in the dictionary, remove it and return its value, else return default. If default is not given and key is not in the dictionary, a KeyError is raised.
        """
        try:
            self._lock()
            return self._dict.pop(*args, **kargs)
        finally:
            self._unlock(sync=True)

    def popitem(self):
        """
            Update the dictionary with the key/value pairs from other, overwriting existing keys
        """
        try:
            self._lock()
            return self._dict.popitem()
        finally:
            self._unlock(sync=True)


class ReadOnlyPersistentDict(PersistentDict):
    """
        Read only persistent dictionary, stored with pickle (default) or YAML
    """
    
    def _sync(self):
        pass

    def sync(self):
        """
            Throw TypeError exception
        """
        raise TypeError

    def __setitem__(self, key, value):
        """
            Throw TypeError exception
        """
        raise TypeError

    def __delitem__(self, key):
        """
            Throw TypeError exception
        """
        raise TypeError

    def update(self, *args, **kargs):
        """
            Throw TypeError exception
        """
        raise TypeError

    def clear(self):
        """
            Throw TypeError exception
        """
        raise TypeError

    def pop(self, *args, **kargs):
        """
            Throw TypeError exception
        """
        raise TypeError

    def popitem(self):
        """
            Throw TypeError exception
        """
        raise TypeError

