#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import time
import threading

__author__ = "Raphael Vallazza <raphael@endian.com>"
__date__ = "2009-06-11"

"""
Implements an object that acts like a list but is evaluated in a lazy way.
The function is triggered as soon as there is an iteration over the list.
"""


class LazyList(object):

    def __init__(self, func, *args, **kwargs):
        self.func = func
        self.data = []
        self.index = -1
        self.args = args
        self.kwargs = kwargs

    def __iter__(self):
        return self

    def next(self):
        if self.index == -1:
            self.data = self.func(*self.args, **self.kwargs)

        self.index += 1
        if self.index < len(self.data):
            return self.data[self.index]
        self.index = -1
        raise StopIteration


class CachedListIterator(object):

    def __init__(self, data):
        self.data = data
        self.length = len(data)
        self.index = 0

    def next(self):
        if self.index < self.length:
            result = self.data[self.index]
            self.index += 1
            return result
        raise StopIteration


class CachedList(object):
    """
    ... autoclass::: CachedList
        CachedList acts like LazyList, but the function's result is cached for 'timeout' seconds
    """

    defaultTimeout = 60

    def __init__(self, func, *args, **kwargs):
        """
            Return the class properties

            :param args: args
            :type args: args
            :param kwargs: kwargs
            :type kwargs: kwargs
            :param func: function
            :type func: function
            :param timeout: function's timeout in seconds
            :type timeout: int
        """
        if 'timeout' in kwargs:
            self.timeout = kwargs['timeout']
            del kwargs['timeout']
        else:
            self.timeout = self.defaultTimeout
        self.expiry = 0
        self.func = func
        self.args = args
        self.kwargs = kwargs
        self.data = None
        self.lock = threading.Lock()

    def __iter__(self):
        try:
            self.lock.acquire()
            if (self.data == None) or (time.time() > self.expiry):
                self.data = self.func(*self.args, **self.kwargs)
                self.expiry = time.time() + self.timeout
        finally:
            self.lock.release()
        return CachedListIterator(self.data)

    def invalidate(self):
        """
          Invalidate the cached result (force reexecuting the function at the next access to the list)
        """
        self.expiry = 0

__all__ = ['LazyList', 'CachedList']

if __name__ == "__main__":

    def pippo():
        print "pippo!"
        return [0,1,2,3]

    def pippo2():
        print "pippo2!"
        return [0,1,2,3,4]

    def pippo3(min=0, max=10):
        print "pippo3!", min, max
        return range(min, max)

    def lazyListTest():
        l = LazyList(pippo)
        print list(l)
        print list(l)

        l.func = pippo2
        print list(l)

        l = LazyList(pippo3, 10, 20)
        print list(l)

        l = LazyList(pippo3, min=95, max=100)
        print list(l)

        l = LazyList(pippo3, min=5)
        print list(l)

        l = LazyList(pippo3, max=5)
        print list(l)

    def cachedListTest():
        l = CachedList(pippo, timeout=1)
        print list(l)
        print list(l)
        time.sleep(1)
        print list(l)

        l = CachedList(pippo3, 95, 100, timeout=1)
        print list(l)

    lazyListTest()
    cachedListTest()


