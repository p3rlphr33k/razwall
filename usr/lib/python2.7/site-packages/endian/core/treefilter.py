#!/usr/bin/env python  
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Peter Warasin <peter@endian.com>"
__date__ = "2009-03-26"

"""
Implements data tree query methods, which
allow to join or select [parts of] ConfigDict-trees
"""

from endian.datatypes.config_dict import ConfigDict as CD
import UserList
import types
import endian.core.cache

def take(root, path):
    """
    Returns a subtree of root identified by '''path'''.
    '''path''' is a string containing node names separated
    by '.'.

    For example: 'actions.mail', returns root['actions']['mail']
    """
    access = "root"
    if path != '' and path != '.':
        access += '.'+path
    return eval(access)

def takeCached(root, path, cache, onExpire=None, onPut=None, onGet=None):
    """
    Same as take(), but caches values within cache object 'cache'
    onExpire: callback called when item expires
    onPut: callback called when item will be replaced in cache
    onGet: callback called when item will be read out
    """
    try:
        return cache.get(path).get()
    except endian.core.cache.CacheException:
        try:
            return cache.put(path, take(root, path), onExpire, onPut, onGet).get()
        except endian.core.cache.CacheException:
            return None
    return None
    

def join(left, right, leftid, rightid, targetnode='',
         select=None, mapper=None):
    """
    Iterates the root nodes of the '''right''' tree
    and merges the values of corresponding 'rows' of the
    '''left''' tree.

    '''leftid''' and '''rightid''' are those id's of the
    tree's which will be compared in order to check if the
    records correspond.

    '''targetnode''' is the address of the subtree of the
    left tree to which the values from the right tree should
    be merged. For example: 'actions.mail'

    '''select' is a list of keys which should be taken from
    right to merge into left.

    '''mapper''' is a dict which maps right key names to
    left key names, while the right key name is the dict's key
    and the left key name is the dict's value.
    During merge this mapping will be applied to the key names
    which will me merged from right data to left data.

    """

    rightiter = right.__iter__
    if type(right) != type([]) and not isinstance(right, UserList.UserList):
        rightiter = right.itervalues
    leftiter = left.__iter__
    if type(left) != type([]) and not isinstance(left, UserList.UserList):
        leftiter = left.itervalues

    for r in rightiter():
        rightval = ''
        try:
            rightval = take(r, rightid)
        except AttributeError:
            # Ignore right record if there is no field which
            # could be taken to compare with left
            continue

        for l in leftiter():
            try:
                leftval = take(l, leftid)
            except AttributeError:
                # Ignore right record if there is no field in left
                # which could be taken to compare with left
                continue
            if rightval != leftval:
                continue

            # records correspond -> merge
            target = None
            try:
                target = take(l, targetnode)
            except AttributeError:
                continue

            if select == None or len(select) == 0:
                select = r.keys()
            if mapper:
                mapper = CD(mapper)

            for cp in select:
                tgt = cp
                if mapper:
                    if cp in mapper:
                        tgt = mapper[cp]
                target[tgt] = r[cp]
            break

    return left

_BOOL_LOOKUP = {
    'on': True,
    'off': False,
    'yes': True,
    'no': False,
    'true': True,
    'false': False,
    'enabled': True,
    'disabled': False,
    True: True,
    False: False,
    1: True,
    0: False,
    '1': True,
    '0': False,
}
def toBool(value, default=False):
    """
    transforms '''value''' to a boolean value.

    In order to return True, '''value''' may be one of
    (case insensitive) 'on', 1, '1', True, 'enabled'

    If the value does not correspond to True or False,
    for example '' or None, the value of '''default'''
    will be returned, which is False if not specified.

    @param  value value to transform to boolean
    @type   value any

    @param  default value to return when no corresponding
            boolean value for '''value''' could be found.
            Defaults to False.
    @type   default boolean


    @type    boolean
    @returns corresponding boolean value of '''value'''

    """
    # XXX: unittests
    if type(value) == types.StringType:
        value = value.lower()
    try:
        return _BOOL_LOOKUP[value]
    except KeyError:
        return default

if __name__ == "__main__":
    a1 = CD({'transport': 'mail', 'enabled': 'off'})
    a2 = CD({'transport': 'mail', 'enabled': 'off'})

    a = CD({'CODE': 'a1', 'ENABLED': 'off', 'ACTION': a1})
    b = CD({'CODE': 'a2', 'ENABLED': 'on', 'ACTION': a2})
    left = CD({'A': a, 'B': b})

    x = CD({'MAIL': 'off', 'EVENT': 'a1', 'REMARK': 'blah'})
    y = CD({'MAIL': 'on', 'EVENT': 'a2', 'REMARK': 'blahsad'})
    right = [x, y]

    print "rigth: %s"%right
    print "left: %s"%left

    print join(left, right, 'CODE', 'EVENT', 'action', ['mail', 'event'], {'MAIL': 'enabled'})
