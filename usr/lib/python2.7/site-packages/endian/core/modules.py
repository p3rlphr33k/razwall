#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Raphael Vallazza <raphael@endian.com>"
__date__ = "2009-04-21"

"""
Module for fetching endian module information
"""

import os.path
import sys
import glob
import fnmatch
import threading
from endian.core.logger import debug, info, error, logger, logging

MODULES_ROOT =            "endian"
SKIP_MODULES =           ["endian._dummy",
                          "endian.core",
                          "endian.emi"]
UNLOADABLE_MODULES =     ["endian.*"] # "endian.*" because "endian" it is not unloadable
NOT_UNLOADABLE_MODULES = ["endian.core*",
                          "endian.data*",
                          "endian.emi*",
                          "endian.job*",
                          "endian.validators*",
                          ]
BASE_FUNCTION_FIELDS = dir(lambda : 0)

__all__ = [
    'family',
    'module_registry',
]


def family(family_name):
    """
        This decorator assign a 'family' to a module (or better, to the init function of a module).
        The family can be used to filter the modules to include/exclude

        Usage example:

        @family("EndianNetwork")
        def init(root):
            registerController(root, "beautiful_controller", ABeautifulController())

    """
    def wrap(fn):
        def wrapped_f(*args, **argv):
            return fn(*args, **argv)
        wrapped_f.family = family_name
        # Copy additional fields
        wrapped_f.__doc__ = fn.__doc__
        for field in [x for x in dir(fn) if x not in BASE_FUNCTION_FIELDS]:
            setattr(wrapped_f, field, getattr(fn, field))
        return wrapped_f
    return wrap


class PathRegistry(object):

    def __init__(self, module_registry):
        self.module_registry = module_registry
        self.items = {}

    def bind(self, path, module):
        """
            Register an item in the registy

            :param path: path (e.g /manage/hotspotgui/index)
            :type path: string
            :param module: module name to be registered at the given path
            :type module: string
        """
        self.items[path] = module

    def lookup(self, path):
        """
            Return the module for a given path

            :param path: the requested path (e.g /manage/hotspotgui/index)
            :type path: string
            :return: Return the longest matching module or None
            :rtype: string
        """
        item = None
        item_path = ""
        for k, v in self.items.iteritems():
            if path.startswith(k) and len(k) > len(item_path):
                item = v
                item_path = k
        return item

    def lookup_and_init(self, path):
        """
            Return the module for a given path

            :param path: the requested path (e.g /manage/hotspotgui/index)
            :type path: string
            :return: Return the longest matching module or None
            :rtype: function or NoneType
        """
        module = self.lookup(path)
        if module == None:
            return False
        self.module_registry.init_module(module)
        return True


class ModuleName(object):

    def __init__(self, module):
        tmp = module.split('.')
        if tmp[0] != MODULES_ROOT:
            tmp.insert(0, MODULES_ROOT)
        if tmp[-1] not in ['web', 'commands', 'status', 'emi_manifest']:
            tmp.append('web')
        self._module = ".".join(tmp[1:-1])
        self._sub_system = tmp[-1]
        self._full_name = ".".join(tmp)

    @property
    def module(self):
        """ Module name, e.g. 'dashboard' """
        return self._module

    @property
    def sub_system(self):
        """ Module subsystem, e.g. 'web' """
        return self._sub_system

    @property
    def full_name(self):
        """ Module full name, e.g. 'endian.dashboard.web' """
        return self._full_name

    def __str__(self):
        return self._full_name

    def __repr__(self):
        return self._full_name


class ModuleRegistry(object):

    def __init__(self):
        self._lock = threading.RLock()
        self.modules = {}
        self.web = PathRegistry(self) # web
        self.commands = PathRegistry(self) # commands and status
        self.menu = {}
        self.emi_root = None
        self.exclude_modules = []
        self.exclude_families = []
        self.include_families = []

    def init_modules(self, options=None, subSystem='web'):
        """
        Scan all EMI modules and register ther subsystems
        """

        endian_dir = self.get_modules_path()

        info("Initializing %s subsystems of EMI modules in '%s'" % (
                subSystem, endian_dir))

        if options:
            self.set_options(options)

        foundModules = self.find_modules(endian_dir,
                                         sub_system=subSystem,
                                         append_sub_system=True)
        try:
            self._lock.acquire()
            for module in foundModules:
                self._init_module(module)
        finally:
            self._lock.release()

    def init_module(self, module, ignore_import_error=False):
        """
            Initialize an EMI module

            :param module: module name (e.g. endian.dashboard.web)
            :type module: string
        """
        try:
            self._lock.acquire()
            self._init_module(module, ignore_import_error)
        finally:
            self._lock.release()

    def _init_module(self, module, ignore_import_error=False):
        if not isinstance(module, ModuleName):
            module = ModuleName(module)

        # Check if the module is in the exclude_modules list
        if self.exclude_modules != None and (\
                module.module in self.exclude_modules or \
                module.full_name in self.exclude_modules):
            debug("Skip module '%s' since it's excluded" % module)
            return

        # Check if the module is just imported
        if module.full_name in self.modules:
            return

        # Check if the emi_root is setted
        if module.sub_system == 'web' and self.emi_root == None:
            error('The emi_root attribute must be not null registering a web subsystem')
            return

        # Import the module
        init = None
        deinit = None
        self.before_import(module.full_name)
        try:
            if module.sub_system == "emi_manifest":
                # If the syb_system is 'emi_manifest', load the manifest
                self._load_emi_manifest(module)
                init = None
                deinit = None
            else:
                # If the sub system is web, import the required modules
                mod = __import__(module.full_name, None, None, ["endian"])
                if module.sub_system == "web":
                    self.import_web_require(module.full_name)
                # Get the init an deinit method
                init = hasattr(mod, "init") and getattr(mod, "init")
                deinit = hasattr(mod, "deinit") and getattr(mod, "deinit")
                self.after_import(module.full_name, deinit=deinit)

        except Exception, e:
            if ignore_import_error and isinstance(e, ImportError):
                return
            error("Could not import module '%s'" % module, exc_info=True)
            return

        # Check if the modules has the init function
        if not init:
            if (module.sub_system != "emi_manifest"):
                debug("No 'init' function for module '%s'" % module)
            return

        # Check the module family
        family = getattr(init, "family", None)
        if self.include_families:
            if family not in self.include_families:
                debug("Excluding module '%s', family does not match include_families" % module)
                return
        elif self.exclude_families:
            if family in self.exclude_families:
                debug("Excluding module '%s', family matches exclude_families" % module)
                return

        # Exec the module init function
        try:
            init(self.emi_root)
            info("Initialized module '%s' %s" % (
                module,
                family and '(family: %s)' % family or ""))
        except Exception, e:
            error("Error initializing module '%s'" % module, exc_info=True)

    def _load_emi_manifest(self, module):
        manifest_module = __import__(module.full_name, globals(), locals(), ["endian"])

        # Check if the module is in the exclude_modules list
        if self.exclude_modules != None and (\
                module.module in self.exclude_modules or \
                module.full_name in self.exclude_modules):
            debug("Skip module '%s' since it's excluded" % module)
            return

        # Check the module family
        family = getattr(manifest_module, "family", None)
        if self.include_families:
            if family not in self.include_families:
                debug("Excluding module '%s', family does not match include_families" % module)
                return
        elif self.exclude_families:
            if family in self.exclude_families:
                debug("Excluding module '%s', family matches exclude_families" % module)
                return

        # Bind status, commands and web
        for path in getattr(manifest_module, "status", []):
            self.commands.bind(path, module.module + ".status")
        for path in getattr(manifest_module, "commands", []):
            self.commands.bind(path, module.module + ".commands")
        for path in getattr(manifest_module, "web", []):
            self.web.bind(path, module.module + ".web")

        # Menu
        menu = getattr(manifest_module, "menu", None)
        if menu:
            self._update_menu(self.menu, menu)

        # Exec the after_import
        self.after_import(module.full_name,
                          web_require=getattr(manifest_module, "web_require", []))

        # If the module has the force_loading attributes equals to True, load the module
        if getattr(manifest_module, "force_loading", False):
            for sub in [ "status", "commands", "web" ]:
                try:
                    self._init_module(module="%s.%s" % (module.module, sub),
                                    ignore_import_error=True)
                except Exception, e:
                    error("Could not import '%s' subsystem of module '%s'" % (
                            sub, module.module), exc_info=True)

    def _update_menu(self, d, u):
        for k, v in u.iteritems():
            if hasattr(v, 'keys'):
                r = self._update_menu(d.get(k, {}), v)
                d[k] = r
            else:
                d[k] = u[k]
        return d

    def get_modules_path(self):
        """
        Return the path where the modules can be found
        """
        try:
            basedir = os.path.abspath(os.path.dirname(__import__(MODULES_ROOT,globals(),locals(),["endian"]).__file__))
        except ImportError:
            raise Exception("Could not find endian modules folder")
        return basedir

    def find_modules(self, basedir=None, sub_system='web', append_sub_system=False):
        """
            Returns a list of available modules

            :param basedir: base directory for searching the modules
            :type basedir: string
            :param sub_system: sub system to be searched
            :type sub_system: string
            :param append_sub_system: if true, append the sub system to the module names in the result
            :type append_sub_system: boolean
            :return: Return a list of module names (optional followed by a dot and the sub system)
            :rtype: list
        """
        if not basedir:
            basedir = self.get_modules_path()

        modules = set()
        globmod = []
        globmod.extend(glob.glob("%s/*/%s.py*" % (basedir, sub_system)))
        globmod.extend(glob.glob("%s/*/%s/__init__.py*" % (basedir, sub_system)))
        globmod.sort()

        for entry in globmod:
            tok = entry.split("/")
            # subsystem is in a file
            module = tok[-2]
            if tok[-1].startswith("__init__"):
                # subsystem is in a directory
                module = tok[-3]

            if not self.is_skipable_module("%s.%s" % (MODULES_ROOT, module)):
                if append_sub_system:
                    module = "%s.%s" % (module, sub_system)
                modules.add(module)

        return list(modules)

    def is_skipable_module(self, module_name):
        """ Return true is the module must be ignored """
        for skipable_module_exp in SKIP_MODULES:
            if fnmatch.fnmatch(module_name, skipable_module_exp):
                return True
        return False

    def is_unloadable_module(self, module_name):
        """ Return true is a module is unloadable """
        # Dont unload the modules in NOT_UNLOADABLE_MODULES (e.g. 'endian.emi*', etc...)
        for not_unloadable_module_exp in NOT_UNLOADABLE_MODULES:
            if fnmatch.fnmatch(module_name, not_unloadable_module_exp):
                return False
        # Unload only the modules in UNLOADABLE_MODULES (e.g. 'endian.*')
        for unloadable_module_exp in UNLOADABLE_MODULES:
            if fnmatch.fnmatch(module_name, unloadable_module_exp):
                return True
        # Not in NOT_UNLOADABLE_MODULES nor in UNLOADABLE_MODULES, so the module
        # is not unloadable
        return False

    def unload_modules(self, modules_to_unload=None):
        """ Unload a list of modules or all the modules """
        try:
            self._lock.acquire()
            unloaded_modules = set()
            for k,v in sys.modules.items():
                if modules_to_unload and not k in modules_to_unload:
                    continue
                # Dont unload a modules if it is not present in sys.modules
                # or module with 'real' name different from key
                # (e.g. 'endian.core.re' real module name is 're')
                if v == None or v.__name__ != k or k not in sys.modules:
                    continue
                # Check if the module is unloadable
                if not self.is_unloadable_module(k):
                    continue # keep the module
                unloaded_modules.add(k)
                # Exec the deinit method
                if k in self.modules:
                    self.deinit_module(k)
                    del self.modules[k]
                # Unload the module
                del(sys.modules[k])
        finally:
            self._lock.release()
        #print 'unloaded_modules:', unloaded_modules
        #from endian.core.commands import registerCommand, getCommandRegistry
        #    for k, v in getCommandRegistry(True).items():
        #        if v and v.get('__function__'):
        #            module = inspect.getmodule(v['__function__'])
        #            if not module or module.__name__ in unloaded_modules:
        #                unregisterCommand(k)

    def before_import(self, module_full_name):
        pass

    def after_import(self, module_full_name, deinit=None, web_require=None):
        """ Store the information about a module """
        module_info = {}
        if deinit:
            module_info['deinit'] = deinit
        if web_require:
            module_info['web_require'] = web_require
        self.modules[module_full_name] = module_info

    def deinit_module(self, module_full_name):
        """ Deinitialize a module, calling the deinit() method """
        try:
            deinit = self.modules[module_full_name]['deinit']
        except:
            return
        try:
            info("Deinitializing %s ..." % (module_full_name))
            deinit()
        except Exception, ex:
            error("Error deinitializing %s: %s" % (module_full_name, ex))
            debug("Error deinitializing %s" % module_full_name, exc_info=True)

    def import_web_require(self, module_full_name):
        """ Import the module dependencies """
        try:
            if module_full_name.endswith('.web'):
                module_full_name = module_full_name[:-4] + ".emi_manifest"
            web_require = self.modules[module_full_name]['web_require']
        except:
            return
        debug("Process %s dependencies", module_full_name)
        if not web_require:
            return
        for module in web_require:
            module = ModuleName(module)
            if module.full_name not in self.modules:
                self.init_module(module)

    def available_modules(self):
        """
            Returns the list of the available modules (i.e. modules that can be loaded)

            :return: list of available modules
            :rtype: list of string
        """
        return  [x[:-13] for x in self.modules if x.endswith('.emi_manifest')]

    def loaded_modules(self):
        """
            Returns the list of the loaded modules

            :return: list of loaded modules
            :rtype: list of string
        """
        return [x for x in self.modules if not x.endswith('.emi_manifest')]

    def set_modules_root(self, modules_root):
        """
            Set the modules root (global)
        """
        global MODULES_ROOT
        MODULES_ROOT = modules_root

    def set_unloadable_modules(self, unloadable_modules):
        """
            Set the unloadable modules (global)
        """
        global UNLOADABLE_MODULES
        UNLOADABLE_MODULES = unloadable_modules

    def set_not_unloadable_modules(self, not_unloadable_modules):
        """
            Set the not unloadable modules (global)
        """
        global NOT_UNLOADABLE_MODULES
        NOT_UNLOADABLE_MODULES = not_unloadable_modules

module_registry = ModuleRegistry()


def findModulePaths(basedir=None):
    """
    Returns a list of available module paths
    """
    return module_registry.find_modules(basedir)


if __name__ == "__main__":
    logger.setLevel(logging.DEBUG)
    print module_registry.get_modules_path()
    print module_registry.find_modules()

    module_registry.init_modules(subSystem='status')
    print module_registry.modules

    @family("testFamily")
    def test(x):
        pass
    test(1)
    print test.family
