#!/usr/bin/env python
# encoding: utf-8
#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2013 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | endian-core is free software: you can redistribute it and/or modify      |
# | it under the terms of GNU General Public License (GPL) version 2.0       |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | endian-core is distributed in the hope that it will be useful,           |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with endian-core.   |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Raphael Vallazza <raphael@endian.com>"
__date__ = "2009-04-27"

"""
Module for registering/managing endian module commands
"""

_REGISTRY = {}

from endian.core.logger import debug, info, error
from endian.core.modules import module_registry
from endian.core.timetools import datetime_from_ISO8601
from optparse import OptParseError, OptionParser, Option, OptionValueError, BadOptionError
from datetime import datetime
import re
import inspect
import sys
import copy

__all__ = [
    'register',
    'lookup',
    'getRegistry',
    'unregister',
    'registerCommand',
    'lookupCommand',
    'getCommandRegistry',
    'call',
    'HTTPOptionError',
    'OptionParserHelpExit',
    'OptParseError',
    'parseFunctionDoc',
    'registerCommandsDict',
    'has_force_json_output',
    'force_json_output',
    ]

def register(command, func):
    """
    .. autofunction:: register
        Register a command (or a status) based on a command name command (Example 'module.command')
    """
    global _REGISTRY

    reg = _REGISTRY
    debug("Registering command '%s': %s" % (command, func))
    for key in command.split("."):
        if reg.has_key(key):
            reg = reg[key]
        else:
            reg[key] = dict()
            reg = reg[key]
    reg["__function__"] = func
    reg["__doc__"] = func.__doc__ and func.__doc__.strip() or ''
    return True

def registerCommandsDict(prefix, command_dict):
    """
    Register a dict of commands under a common prefix
    """
    global _REGISTRY
    reg = _REGISTRY
    debug("Registering command dict '%s'" % (prefix))

    splitted_prefix = prefix.split(".")
    for key in splitted_prefix[:-1]:
        if reg.has_key(key):
            reg = reg[key]
        else:
            reg[key] = dict()
            reg = reg[key]
    reg[splitted_prefix[-1]] = command_dict
    return True

def lookup(command):
    """
    .. autofunction:: lookup
        Lookup a command in the command registry
    """
    try:
        reg = _REGISTRY
        for key in command.split("."):
            reg = reg[key]
        return reg["__function__"]
    except KeyError, ex:
        debug("Command '%s' not found; try module import" % command)
        # Import the module defining the command
        if not module_registry.commands.lookup_and_init(command):
            raise ex
        # Try again..
        reg = _REGISTRY
        for key in command.split("."):
            reg = reg[key]
        return reg["__function__"]


def getRegistry(flat=False, root_node=None):
    """
    .. autofunction:: getRegistry
        Return the global commmand registry
        :param flat: If true, return the registry as a 'flat' dictionary
        :type flat: boolean
        :param root_node: Root node, e.g. 'status' (used for filter the results)
        :type root_node: string
    """
    reg = _REGISTRY
    if root_node != None:
        reg = _REGISTRY
        for key in root_node.split("."):
            reg = reg[key]
    if not flat:
        return reg
    else:
        result = {}
        def flatize(result, prefix, d):
            if prefix:
                prefix = prefix + "."
            for k,v in d.iteritems():
                if hasattr(v, 'keys') and not '__function__' in v:
                    flatize(result, prefix + k, v)
                else:
                    result[prefix + k] = v
        flatize(result, "", reg)
        return result

def unregister(command):
    """
    .. autofunction:: unregister
        Unregister a command (or a status) based on a command name command (Example 'module.command')
    """
    global _REGISTRY

    reg = _REGISTRY
    debug("Unregistering command '%s'" % command)
    parent = None
    for key in command.split("."):
        if not reg.has_key(key):
            info("Command '%s' not found" % command)
            return False
        else:
            parent = reg
            reg = reg[key]
    if parent:
        del parent[key]
    return True

class HTTPOptionError(OptParseError):
    pass
class OptionParserHelpExit(OptParseError):
    pass

def check_datetime(option, opt, value):
    try:
        if isinstance(value, datetime):
            return value
        else:
            return datetime_from_ISO8601(value)
    except Exception:
        raise OptionValueError("option %s: invalid ISO 8601 date value: %r" % (opt, value))

class EnhancedOption(Option):
    """
        'Enhanced' version of Option with
        datetime option type support
    """
    TYPES = Option.TYPES + ("datetime",)
    TYPE_CHECKER = copy.copy(Option.TYPE_CHECKER)
    TYPE_CHECKER["datetime"] = check_datetime

class HTTPOptionParser(OptionParser):
    def exit(self, status=0, msg=None):
        raise HTTPOptionError(msg)
    def error(self, msg):
        ret = """%s\n\n%s""" % (self.format_help(), msg)
        raise HTTPOptionError(ret)
    def print_help(self):
        raise OptionParserHelpExit(self.format_help())
    def _add_help_option(self):
        self.add_option("--help",
                        action="help",
                        help="show this help message and exit")

    def _process_args(self, largs, rargs, values):
        while rargs:
            try:
                OptionParser._process_args(self,largs,rargs,values)
            except BadOptionError: # ignore bad options
                pass

    def _process_long_opt(self, rargs, values):
        arg = rargs.pop(0)

        # Value explicitly attached to arg?  Pretend it's the next
        # argument.
        if "=" in arg:
            (opt, next_arg) = arg.split("=", 1)
            rargs.insert(0, next_arg)
            had_explicit_value = True
        else:
            opt = arg
            had_explicit_value = False

        opt = self._match_long_opt(opt)
        option = self._long_opt[opt]
        if option.takes_value():
            nargs = option.nargs
            if len(rargs) < nargs:
                if nargs == 1:
                    self.error("%s option requires an argument" % opt)
                else:
                    self.error("%s option requires %d arguments"
                               % (opt, nargs))
            elif nargs == 1:
                value = rargs.pop(0)
            else:
                value = tuple(rargs[0:nargs])
                del rargs[0:nargs]
            option.process(opt, value, values, self)

        elif had_explicit_value:
            from endian.validators.boolean import to_bool
            value = to_bool(rargs.pop(0))
            if value and option.action == "store_true":
                option.process(opt, None, values, self)
            elif not value and option.action == "store_false":
                option.process(opt, None, values, self)

        else:
            value = None
            option.process(opt, value, values, self)


def argsToOptions(*argl, **args):
    ret = []
    for k,v in args.iteritems():
        if k == 'help':
            ret.append('--help')
        elif v == '':
            ret.append('--%s='%k)
        elif isinstance(v, list):
            for e in v:
                ret.append('--%s=%s'%(k, e))
        else:
            ret.append('--%s=%s'%(k, v))
    return ret

def optionsToDict(options, include=None):
    ret = {}
    for k in options.__dict__:
        if include and k not in include:
            continue
        ret[k] = getattr(options, k)
    return ret

_paramRx = re.compile('^:(?P<tag>\S+)\s+(?P<name>\S+):\s+(?P<text>.+)$')
def parseFunctionDoc(func):
    """
    .. autofunction:: parseFunctionDoc

    Parses the docstring of function 'func' and returns a
    structure containing the relevant items as seen below::
    {'summary': 'summary text',
     'description': 'description text',
     'parameters': {
        'parameter1': {
            'description': 'parameter description',
            'type': 'type name'
            }
        }
     }

     :param func: The function to parse
     :type func: function
     :returns: dict with all parsed elements
    """
    params = {}
    ret = {
        'summary': '',
        'description': '',
        'parameters': params,
        }
    s = func.__doc__
    if not s:
        return ret
    s = s.split('\n')

    text = []
    last = None
    for line in s:
        line = line.strip()
        if line.startswith('..'):
            # eat it
            last = None
            continue
        if line.startswith(':'):
            last = None
            match = _paramRx.match(line)
            if not match:
                continue
            items = match.groupdict()
            name = items['name']
            if name not in params:
                params[name] = {
                    'type': '',
                    'description': [],
                    }
            if items['tag'] == 'type':
                params[name]['type'] = items['text']
            if items['tag'] == 'param':
                last = params[name]['description']
                last.append(items['text'])
            continue
        if not last:
            last = text
        if line == '':
            if len(last) <= 0:
            # eat trailing white-lines
                continue
        last.append(line)

    try:
        sep = text.index('')
        ret['summary'] = text[:sep]
        ret['description'] = text[sep:]
    except ValueError:
        ret['summary'] = text

    # sanitize to a human readable form
    ret['summary'] = "".join(ret['summary']).strip()
    ret['description'] = "\n".join(ret['description']).strip()
    if ret['description'] == '':
        ret['description'] = ret['summary']
    for (k,v) in ret['parameters'].iteritems():
        v['description'] = " ".join(v['description'])

    return ret


def generateOptions(parser, func, doc):
    """
    .. autofunction::

    Populates the OptionParser 'parser' with options
    by reading out the parameter list of the function
    'func' and creating an option for each parameter
    using the descriptions from the structure passed by
    'doc'.
    If a parameter has default values it will be set so.
    The type described within 'doc' will be used when
    possible in order to set a corresponding OptionParser
    action.
    Valid types are:
    * boolean (or bool)
    * integer (or int)
    * long
    * float
    * datetime (ISO 8601)
    * string (or str) default type
    * list of <type>s
    """

    spec = inspect.getargspec(func)
    args = spec[0]
    defaults = spec[3] or []
    argsDict = spec[2]

    args.reverse()
    params = doc['parameters']

    i = 0
    for name in args:
        if name == argsDict:
            continue
        i += 1
        default = None
        try:
            default = defaults[-i]
        except IndexError:
            default = None
        except Exception, e:
            error(e)

        action = 'store'
        type_ = 'string'
        help = ''
        if default is not None:
            help = " (default: '%s')"%default
        if name in params:
            p = params[name].copy()
            if p['type'].startswith("list of"):
                p['type'] = p['type'][:-1].lstrip("list of")
                action = "append"
            if p['type'] == 'boolean' or p['type'] == 'bool':
                type_ = None
                if default:
                    action = 'store_false'
                else:
                    action = 'store_true'
            elif p['type'] in ['int', 'integer', 'long', 'float', 'datetime']:
                type_ = p['type']

            help = p['description'] + help

        parser.add_option("--%s" % name,
                          dest=name,
                          type=type_,
                          action=action,
                          help=help,
                          default=default)

    for name in params:
        if name == argsDict:
            continue
        if name in args:
            continue

        default = None

        action = 'store'
        type = 'string'

        p = params[name].copy()
        if p['type'].startswith("list of"):
            p['type'] = p['type'][:-1].lstrip("list of")
            action = "append"
        if p['type'] == 'boolean':
            type = None
            if default:
                action = 'store_false'
            else:
                action = 'store_true'
        if p['type'] == 'int' or p['type'] == 'integer':
            type = 'int'
        help = p['description']

        parser.add_option("--%s" % name,
                          dest=name,
                          type=type,
                          action=action,
                          help=help,
                          default=default)


def call(cmd, http=False, *argl, **args):
    """
    .. autofunction:: call

    Calls the supplied method 'method' and returns the
    result.

    :param http: If True, uses the http parser, which gets the
        options from POST/GET variables.
        Otherwise uses normal option parser, which reads from
        sys.stdin
    :type http: boolean

    """
    if http:
        cls = HTTPOptionParser
        input = argsToOptions(**args)
    else:
        cls = OptionParser
        input = sys.argv

    method = lookup(cmd)
    if not hasattr(method, '_parsed_doc'): # cache the parsed doc
        method._parsed_doc = parseFunctionDoc(method)
    parser = cls(usage="usage: %prog <options>",
                 description=method._parsed_doc['description'],
                 prog=cmd,
                 option_class=EnhancedOption)
    generateOptions(parser, method, method._parsed_doc)
    options = parser.parse_args(input)[0]
    method_args = dict()
    method_args.update(args)
    method_args.update(optionsToDict(options))
    try:
        return method(**method_args)
    except Exception, ex:
        msg = str(ex)
        error(msg, exc_info=True)
        if "got an unexpected keyword argument" in msg:
            msg = msg.split("got an unexpected keyword argument", 2)[1]
            raise Exception("Unexpected argument%s" % msg)
        raise ex


def has_force_json_output(cmd):
    """
    .. autofunction:: has_force_json_output

    Return true if the output format of the command is forced to JSON.
    """
    method = lookup(cmd)
    return getattr(method,'force_json_output',False)


BASE_FUNCTION_FIELDS = dir(lambda : 0)

def force_json_output(fn):
    """
    .. autofunction:: force_json_output

        Force the JSON output format to an Emi command

        @force_json_output
        def login_test(name, password):
            ...

    """
    def wrapped_f(*args, **kargs):
        return fn(*args, **kargs)
    # Copy additional fields
    wrapped_f.force_json_output = True
    wrapped_f.__doc__ = fn.__doc__
    for field in [x for x in dir(fn) if x not in BASE_FUNCTION_FIELDS]:
        setattr(wrapped_f, field, getattr(fn, field))
    return wrapped_f

# Old API

cmd = lookup
registerCommand = register
lookupCommand = lookup
unregisterCommand = unregister
getCommandRegistry = getRegistry
