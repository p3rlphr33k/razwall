#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

__author__ = "Alber Maximilian <m.alber@endian.com>"
__date__ = "2010-12-07"

import threading
import time
from UserDict import DictMixin
from endian.core.logger import *
from endian.core.commands import registerCommand, registerCommandsDict
from endian.job.engine_control import send_cmd_to_engine, send_query_to_engine, FactBase


def jobsengine_list(arg=None):
    """
      Get jobs short status information
      :param arg: an optiona value in ok,err,start,stop,exe,group
      :type arg: string
    """
    return send_cmd_to_engine("list %s" % (arg or ""))

def jobsengine_actions():
    """
      Get the actions list
    """
    return send_cmd_to_engine("actions")

def jobsengine_handlers():
    """
      Get the list of the events handlers
    """
    return send_cmd_to_engine("handlers")

def jobsengine_events():
    """
      Get the events queue
    """
    return send_cmd_to_engine("events")

def jobsengine_threads():
    """
      Get the jobsengine threads list
    """
    return send_cmd_to_engine("threads")

def jobsengine_messages():
    """
      Get the last messages
    """
    return send_cmd_to_engine("messages")

def jobsengine_functions():
    """
      Get the functions list
    """
    return send_cmd_to_engine("functions")

def jobsengine_dump():
    """
      Dump the fact base
    """
    return send_cmd_to_engine("dump")

def jobsengine_query(fact):
    """
      Query the fact base
      :param fact: a fact to be searched
      :type fact: string
    """
    return send_cmd_to_engine("query %s" % fact)

def get_job_command_function(jobname=None, command=None, options=None):
    """
    Returns a wrapped function which calls the job_command.

    :param jobname: Job name
    :type jobname: String
    :param command: Job command (e.g. 'start')
    :type command: String
    :param options: dict with the options. key = optionname,
       value= dict with two keys: type and description
    :type options: dict
    :return: A wrapped command call to the jobsengine.
    :rtype: function
    """

    if not jobname: # jobsengine command (e.g. emit)
        job_command = command
    elif command in ['start', 'stop', 'restart']:
        job_command = "%s %s" % (command, jobname)
    else:
        job_command = "call %s.%s" % (jobname, command)

    def command_function(**params):
        """
        Calls the job_command(defined in the outter function) with the given
        params or with no params, if none are specified.

        :return: The string of the returned by the engine.
        :rtype: String
        """
        if len(params):
            return send_cmd_to_engine(job_command, options=params)
        else:
            return send_cmd_to_engine(job_command)

    documentation = "Sends following command to jobsengine: %s" % job_command
    if options != None:
        for key, option in options.iteritems():
            if key == "predicate":
                continue
            if not hasattr(option, 'get'):
                continue
            documentation += "\n:param %s: %s" % (key, option.get("description","No description."))
            documentation += "\n:type %s: %s" % (key, option.get("type","Unknown"))
    command_function.__doc__ = documentation

    return command_function

class JobsEngineCommandsDict(DictMixin):
    """
    Dictionary of the jobsengine commands

    This dictionary keep the list of the josengine commands.
    It fetches the list from the jobsengine using the "actions" cmd.
    The fected list is shared between all the instances of this class and
    is cached for 'timeout' seconds.

    """

    timeout = 60 * 5
    _lock = None
    _actions = None
    _expiry = None

    def __init__(self, job=None):
        self.job=job

    @classmethod
    def get_jobsengine_actions(cls):
        if cls._lock == None:
            cls._actions = None
            cls._lock = threading.Lock()
        try:
            cls._lock.acquire()
            if (cls._actions == None) or (time.time() > cls._expiry):
                try:
                    cls._actions = send_query_to_engine("action") + send_query_to_engine("function")
                    cls._expiry = time.time() + cls.timeout
                except Exception, ex:
                    warn(ex)
                    cls._expiry = time.time() # expire now
        finally:
            cls._lock.release()
        if cls._actions == None:
            return FactBase() # return an empty FactBase
        else:
            return cls._actions

    @classmethod
    def get_jobsengine_action(cls, job, name):
        actions = cls.get_jobsengine_actions()
        return actions.matches_one("action(job:%s,name:%s)" % (job, name)) or \
               actions.matches_one("function(job:%s,name:%s)" % (job, name))

    @classmethod
    def check_if_job_exist(cls, job):
        actions = cls.get_jobsengine_actions()
        return actions.matches_one("action(job:%s)" % (job)) != None or \
               actions.matches_one("function(job:%s)" % (job)) != None

    def keys(self):
        """
            Returns the list of the commands
            
            :return: The string of the returned by the engine.
            :rtype: a list of strings
        """
        if self.job == None:
            # Return the jobs names
            # (e.g. ['monit', 'ssh', ...]
            result = [fact.get_value("job") \
                      for fact in self.get_jobsengine_actions()]
            # Uniqify the list (see http://www.peterbe.com/plog/uniqifiers-benchmark)
            return {}.fromkeys(result).keys()
        else:
            # Return only actions of a specific jobs
            # (e.g. job='monit' --> return ['start', 'stop'])
            return [fact.get_value("name") \
                      for fact in self.get_jobsengine_actions() \
                      if fact.get_value("job") == self.job]

    def __getitem__(self, command_name):
        """
            Returns the list of the commands
            
            :param command_name: a command name
            :type command_name: string
            :return: the command as a dict with a '__function__' and '__doc__' keys, e.g.:
                     { '__function__' : func, '__doc__' : func.__doc__.strip() }
            :rtype: a dict
        """
        if self.job == None:
            if not self.check_if_job_exist(command_name) or \
                    command_name == '__function__' or \
                    command_name == '__doc__':
                raise KeyError(command_name)
            return JobsEngineCommandsDict(command_name)
        else:
            action = self.get_jobsengine_action(job=self.job, name=command_name)
            if action == None:
                raise KeyError(command_name)
            func = get_job_command_function(jobname=self.job, command=command_name,
                                         options=action.get_value("options",get_type=dict))
            doc = func.__doc__ and func.__doc__.strip() or ''
            return { '__function__' : func,
                     '__doc__' : doc }

    def __repr__(self):
        if self.job == None:
            return DictMixin.__repr__(self)
        else:
            return "{" + ",".join([repr(x) + ": <lazy command>" for x in self.keys()]) + "}"


def init(root=None):
    """
    Registers the function of the jobsengine at the emi commands
    module.
    """
    registerCommand("commands.jobsengine.list", jobsengine_list)
    registerCommand("commands.jobsengine.actions", jobsengine_actions)
    registerCommand("commands.jobsengine.handlers", jobsengine_handlers)
    registerCommand("commands.jobsengine.events", jobsengine_events)
    registerCommand("commands.jobsengine.threads", jobsengine_threads)
    registerCommand("commands.jobsengine.query", jobsengine_query)
    registerCommand("commands.jobsengine.messages", jobsengine_messages)
    registerCommand("commands.jobsengine.functions", jobsengine_functions)
    registerCommand("commands.jobsengine.dump", jobsengine_dump)
    registerCommand("commands.jobsengine.query", jobsengine_query)

    registerCommandsDict("commands.jobs", JobsEngineCommandsDict())
