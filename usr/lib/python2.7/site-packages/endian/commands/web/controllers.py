#
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2005-2011 Endian                                           |
# |         Endian GmbH/Srl                                                  |
# |         Bergweg 41 Via Monte                                             |
# |         39057 Eppan/Appiano                                              |
# |         ITALIEN/ITALIA                                                   |
# |         info@endian.com                                                  |
# |                                                                          |
# | emi is free software: you can redistribute it and/or modify it under     |
# | the terms of GNU General Public License (GPL) version 2.0                |
# | when released with the Community edition                                 |
# | or the GNU Lesser General Public License (LGPL) version 2.1              |
# | when released with the Enterprise edition.                               |
# |                                                                          |
# | emi is distributed in the hope that it will be useful,                   |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the             |
# | GNU General Public License for more details or the                       |
# | GNU Lesser General Public License for more details.                      |
# |                                                                          |
# | You should have received a copy of the license along with emi.           |
# | If not, see <http://www.gnu.org/licenses/>.                              |
# +--------------------------------------------------------------------------+
#

import traceback
import time
from endian.emi.tg import jsonify
from cgi import parse_qs

from endian.emi.controllers import Controller, expose, redirect
from endian.emi.framework import HTTPError, request, response

from endian.core import logger
import endian.core.commands
from endian.core.modules import module_registry
from endian.core.daemon import MainLoopExit

__all__ = [
    'CommandsController'
]

class CommandsController(Controller):
    default_type = "text"
    
    @expose(template="endian.commands.web.templates.index")
    def index(self, root_node=None, **args):
        return self._index_internal(root_node, **args)
    
    @expose()
    def default(self, cmd, **args):
        if self.default_type == "json":
            return self.json(cmd, **args)
        return self.text(cmd, **args)
    
    @expose(content_type="text/plain")
    def text(self, cmd, **args):
        # hack to get post data from cherrypy....
        # cherrypy will not add post data to **args, it requires it to be a param...
        if request.method == "POST":
            try:
                post_data = parse_qs(request.body.read())
            except:
                post_data = {}
            args.update(post_data)
        
        return self._call_command(cmd, type_="text", **args)

    @expose(content_type="application/json")
    def json(self, cmd, **args):
        # hack to get post data from cherrypy....
        # cherrypy will not add post data to **args, it requires it to be a param...
        if request.method == "POST":
            try:
                post_data = parse_qs(request.body.read())
            except:
                post_data = {}
            args.update(post_data)
        return self._call_command(cmd, type_="json", **args)
    
    def _index_internal(self, root_node=None, **args):
        if not root_node:
            root_node = None
        # List the commands
        entries = {}
        try:
            commands = endian.core.commands.getRegistry(root_node=root_node)
        except KeyError:
            try:
                module_registry.commands.lookup_and_init(root_node)
                commands = endian.core.commands.getRegistry(root_node=root_node)
            except KeyError:
                commands = {}
            
        for (id, method) in commands.iteritems():
            if root_node:
                id = "%s.%s" % (root_node, id)
            commanditem = { 'url': 'URL',
                            'id': id,
                            'description': '',
                            'is_function': False,
                            'loaded': True }
            if method.has_key("__function__"):
                doc = endian.core.commands.parseFunctionDoc(method['__function__'])
                commanditem['is_function'] = True
                commanditem['description'] = doc['summary']                
            entries[id] = commanditem
            
        # Add the not-jet-loaded commands
        deeph = root_node and (root_node.count('.') + 1) or 0
        for command in module_registry.commands.items.keys():
            if not root_node or command.startswith("%s." % root_node):
                id = ".".join(command.split('.')[:deeph+1])                
                if id not in entries:
                    commanditem = {
                            'url': 'URL',
                            'id': id,
                            'description': '',
                            'is_function': False,
                            'loaded': False }
                    entries[id] = commanditem
        
        # Create the breadcrumb
        breadcrumb = []
        breadcrumb.append(('','root'))
        if root_node:
            tmp = []
            for item in root_node.split('.'):
                tmp.append(item)
                breadcrumb.append((".".join(tmp), item))
        
        return {'entries': entries,
                'root_node': root_node or '',
                'breadcrumb': breadcrumb}
    
    def _call_command(self, cmd, type_="text", **args):
        # delete timestamp used to prevent caching
        if args.has_key("_"):
            del args["_"]
        try:
            logger.debug("Call '%s' with parameters: '%s'", cmd, str(dict([(k,(k == 'password') and 'XXX' or v) for k,v in args.items()])))
            ret = endian.core.commands.call(cmd, http=True, **args)
            if type_ == "json" or endian.core.commands.has_force_json_output(cmd):
                if not isinstance(ret, dict) and not isinstance(ret, list):
                    ret = {'info': ret}
                if isinstance(ret, dict) and not ret.has_key('time'):
                    ret['time'] = time.time()
                response.headers['Content-Type'] = 'application/json'
                return jsonify.dumps(ret)
            else: # type_ == "text"
                # If ret is a dict or a list, convert to json
                if isinstance(ret, dict) or isinstance(ret, list):
                   return jsonify.dumps(ret)
                return str(ret) + "\n"
        except KeyError:
            logger.debug("Command '%s' not found in registry.", cmd)
            raise HTTPError(404, "Command not found")

        except endian.core.commands.OptionParserHelpExit, e:
            # Display the help message
            help_message = self._format_help_message(e)
            if type_ == "json": # don't format the help message as json unless is explicitly requested
                 return {'info': help_message,
                         'time':  time.time()}
            else: # type_ == "text":
                return help_message
            
        except endian.core.commands.OptParseError, e:
            # Invalid/missing parameter
            help_message = self._format_help_message(e)
            response.status = 500
            if type_ == "json" or endian.core.commands.has_force_json_output(cmd):
                response.headers['Content-Type'] = 'application/json'
                return {'error': help_message,
                        'time':  time.time()}
            else: # type_ == "text":
                return help_message
            
        except MainLoopExit:
            # Allow commands to reload the EMI application server
            raise
        
        except HTTPError, e: # e.g 401, etc...
            if type_ == "json" or endian.core.commands.has_force_json_output(cmd):
                response.headers['Content-Type'] = 'application/json'
            raise e
        
        except Exception, e:
            logger.error("Calling command '%s' with parameters '%s' failed with '%s'.",
                str(cmd), str(dict([(k,(k == 'password') and 'XXX' or v) for k,v in args.items()])), str(e))
            response.status = 500
            if type_ == "json" or endian.core.commands.has_force_json_output(cmd):
                response.headers['Content-Type'] = 'application/json'
                return {'error': str(e),
                        'time': time.time()}
            else: # type_ == "text":
                return "ERROR: %s(%s):\n\n%s""" % (
                       cmd,
                       ",".join("%s=%s" % (k,v) for k,v in args.iteritems()),
                       str(e))

    def _format_help_message(self, e):
        if request.headers.get('User-Agent') == "emicommand":
            return str(e)
        help = []
        for line in str(e).split("\n"):
            lline = line and line.lower() or ""
            if lline.startswith("usage:"):
                continue
            if lline.startswith("options:"):
                line = "Parameters:\n"
            line = line.replace("--","")    
 
            help.append(line)
        return "\n".join(help)

def test(force=False, msg=""):
    """
    Test command interface

    Is a sample for a function of the EMI command interface.
    This text is multiline since it describes what exactly
    does this function.

    In this example the function does nothing of interest,
    it simple prints out "TEST" following with the supplied
    arguments which have been passed to the function.

    This text is only so long and says nothing in the end
    because I want to test the docstring parser with it and
    therefore I would like to have some paragraphs, which are
    separated by empty newlines.

    :param force: Forces something if True, otherwise does not
    force at all.
    :type force: boolean
    :param msg: Specify a cool message
    :type msg: string

    """
    if force:
        return "FORCE %s" % msg
    else:
        return "TEST %s" % msg

from endian.core.commands import registerCommand
registerCommand("commands.commands.test", test)
