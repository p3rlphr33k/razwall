#!/usr/bin/env python
#        +-----------------------------------------------------------------------------+
#        | Endian Firewall                                                             |
#        +-----------------------------------------------------------------------------+
#        | Copyright (c) 2005-2012 Endian                                              |
#        |         Endian GmbH/Srl                                                     |
#        |         Bergweg 41 Via Monte                                                |
#        |         39057 Eppan/Appiano                                                 |
#        |         ITALIEN/ITALIA                                                      |
#        |         info@endian.it                                                      |
#        |                                                                             |
#        | This program is free software; you can redistribute it and/or               |
#        | modify it under the terms of the GNU General Public License                 |
#        | as published by the Free Software Foundation; either version 2              |
#        | of the License, or (at your option) any later version.                      |
#        |                                                                             |
#        | This program is distributed in the hope that it will be useful,             |
#        | but WITHOUT ANY WARRANTY; without even the implied warranty of              |
#        | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the               |
#        | GNU General Public License for more details.                                |
#        |                                                                             |
#        | You should have received a copy of the GNU General Public License           |
#        | along with this program; if not, write to the Free Software                 |
#        | Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA. |
#        | http://www.fsf.org/                                                         |
#        +-----------------------------------------------------------------------------+
#

import os
import re
import glob
import platform
import subprocess

BASE_PATH = '/tmp/collectd/rrd'
UUID_FILE = '/etc/uuid'

RRDINFO_CMD = ['rrdtool', 'info']

re_last_update = re.compile(r'^last_update = (.*)$', re.M)
re_read = re.compile(r'^ds\[read\]\.last_ds = "(.*)"', re.M)
re_write = re.compile(r'^ds\[write\]\.last_ds = "(.*)"', re.M)

MOUNT_CACHE = {}


def getUUID():
    """Return the UUID of the system."""
    if not os.path.isfile(UUID_FILE):
        return None
    try:
        f = open(UUID_FILE, 'r')
        uuid = f.read().strip()
        f.close()
        return uuid
    except IOError:
        pass
    return None

def mountPoint(disk):
    """Return the mount point of the given disk."""
    global MOUNT_CACHE
    if not MOUNT_CACHE:
        cmd = subprocess.Popen(['mount'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        cmd_out = cmd.communicate()[0]
        if cmd.returncode != 0:
            return disk
        for line in cmd_out.split(os.linesep):
            line = line.strip()
            if not line:
                continue
            line_s = line.split()
            if len(line_s) < 3:
                continue
            MOUNT_CACHE[os.path.basename(line_s[0])] = line_s[2]
    return MOUNT_CACHE.get(disk, disk)


def getPartitionStats(path):
    """Return data stored in the given path."""
    out = {}
    part = os.path.basename(path).replace('disk-', '')
    mount_point = mountPoint(part)
    out['mount point'] = mount_point
    for data_type in ('octets', 'ops'):
        data_file = os.path.join(path, 'disk_%s.rrd' % data_type)
        if not os.path.isfile(data_file):
            continue
        cmd_opts = RRDINFO_CMD + [data_file]
        cmd = subprocess.Popen(cmd_opts, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        cmd_out = cmd.communicate()[0]
        if cmd.returncode != 0:
            continue
        l_search = re_last_update.search(cmd_out)
        if l_search:
            out['last update'] = l_search.group(1)
        r_search = re_read.search(cmd_out)
        if r_search:
            out.setdefault(data_type, {})['read'] = r_search.group(1)
        w_search = re_write.search(cmd_out)
        if w_search:
            out.setdefault(data_type, {})['write'] = w_search.group(1)
    return out


def getAllData():
    """Return information on all the partitions/disks."""
    uuid = getUUID()
    if not uuid:
        return {}
    out = {}
    base_path = os.path.join(BASE_PATH, uuid)
    disks = ''
    if platform.machine().startswith('arm'):
        disks = 'disk-mmcblk0*'
    else:
        disks = 'disk-sda*'
    for path in glob.glob(os.path.join(base_path, disks)):
        part_name = os.path.basename(path).replace('disk-', '')
        part_data = getPartitionStats(path)
        out[part_name] = part_data
    return out

