#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = "Andrea Bonomi <a.bonomi@endian.com>"
__date__ = "2016-06-16"

from Crypto.Cipher import AES
from Crypto import Random
import base64
import hashlib

__all__ = [
    'encrypt',
    'decrypt'
]

# Block size for the cipher object
BLOCK_SIZE = 32

# Checksum (SHA 256) length
CHECKSUM_LEN = 32

# Salt length
SALT_LEN = 16

def generate_secret(key):
    m = hashlib.sha256()
    m.update(key)
    return m.digest()[0:BLOCK_SIZE]

def encrypt(data, key):
    """
    Encrypt a string using a given key

    :param data: data to be encrypted
    :type data: str
    :param key: key
    :type key: str
    :return: encrypted text
    :rtype: str
    """
    m = hashlib.sha256()
    m.update(key)
    checksum = m.digest()
    assert(len(checksum) == CHECKSUM_LEN)
    salt = Random.new().read(SALT_LEN)
    cipher = AES.new(generate_secret(key), AES.MODE_CFB, salt)
    return base64.b64encode(salt + cipher.encrypt(checksum + data))

def decrypt(data, key):
    """
    Decrypt an encrypted string

    :param data: data to be decrypted
    :type data: str
    :param key: key
    :type key: str
    :return: decrypted text or None in case of error
    :rtype: str
    """
    try:
        data = base64.b64decode(data)
        cipher = AES.new(generate_secret(key),  AES.MODE_CFB, data[0:SALT_LEN])
        data = cipher.decrypt(data[SALT_LEN:])
        checksum = data[0:CHECKSUM_LEN]
        m = hashlib.sha256()
        m.update(key)
        if checksum != m.digest():
            return None
        data = data[CHECKSUM_LEN:]
        return data
    except:
        return None

