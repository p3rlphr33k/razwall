#!/usr/bin/env python
# -*- coding: utf-8 -*-
# +--------------------------------------------------------------------------+
# | Endian Firewall                                                          |
# +--------------------------------------------------------------------------+
# | Copyright (c) 2004-2016 S.p.A. <info@endian.com>                         |
# |         Endian S.p.A.                                                    |
# |         via Pillhof 47                                                   |
# |         39057 Appiano (BZ)                                               |
# |         Italy                                                            |
# |                                                                          |
# | This program is free software; you can redistribute it and/or modify     |
# | it under the terms of the GNU General Public License as published by     |
# | the Free Software Foundation; either version 2 of the License, or        |
# | (at your option) any later version.                                      |
# |                                                                          |
# | This program is distributed in the hope that it will be useful,          |
# | but WITHOUT ANY WARRANTY; without even the implied warranty of           |
# | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            |
# | GNU General Public License for more details.                             |
# |                                                                          |
# | You should have received a copy of the GNU General Public License along  |
# | with this program; if not, write to the Free Software Foundation, Inc.,  |
# | 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.              |
# +--------------------------------------------------------------------------+

__author__ = 'Andrea Bonomi <a.bonomi@endian.com>'
__date__ = '2016-06-30'

import random
import base64
import struct
import hashlib
import textwrap
from pyasn1.codec.der import encoder, decoder
from pyasn1.type.univ import Sequence, Integer, OctetString, ObjectIdentifier, BitString
from pyasn1.type.namedtype import NamedTypes, NamedType, OptionalNamedType
from pyasn1.type.namedval import NamedValues
from pyasn1.type.tag import Tag, tagClassContext, tagFormatSimple
from pyasn1.type.constraint import SingleValueConstraint
from endian.crypto.hash import format_digest, FORMAT_HEX
from endian.crypto import elliptic

__all__ = [
    'Elliptic'
]

HASH_FUNCTION = 'sha256'
CURVE_ALG = 'ecdsa-sha2-nistp256'
CURVE_NAME = 'nistp256'
CURVE_OID = '1.2.840.10045.3.1.7'
CURVE_P = 3
BITS = 256
P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffL
N = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551L
B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bL
X = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296L
Y = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5L

def from_bytes(s):
    return int(s.encode('hex'), 16)

def to_bytes(n, length=0):
    h = '%x' % n
    return ('0'*(len(h) % 2) + h).zfill(length*2).decode('hex')

def bytes_to_bits(b):
    bits = bin(long(b.encode('hex'), 16))[2:]
    if len(bits) % 8:
        bits = ('0' * (8 - len(bits) % 8)) + bits
    return tuple(int(i) for i in bits)

def get_random_bits():
    return (random.getrandbits(BITS + 64) % (P - 1)) + 1  # 256 + 64 bits (FIPS 186-3)

class ECPrivateKey(Sequence):
    componentType = NamedTypes(
        NamedType('version', Integer(namedValues = NamedValues(('ecPrivkeyVer1', 1))).subtype(subtypeSpec = Integer.subtypeSpec + SingleValueConstraint(1))),
        NamedType('privateKey', OctetString()),
        OptionalNamedType('parameters', ObjectIdentifier().subtype(explicitTag = Tag(tagClassContext, tagFormatSimple, 0))),
        OptionalNamedType('publicKey', BitString().subtype(explicitTag = Tag(tagClassContext, tagFormatSimple, 1))))

class Elliptic(object):

    def __init__(self, public_key=None, private_key=None):
        """
        Create an Elliptic instance.
        If public and private key are None, new private/public key are generated.
        If only public key is None, the public key is derived from the private.

        :param public_key: public key
        :type public_key: str or number
        :param private_key: private key
        :type private_key: number
        :return: Elliptic instance
        :rtype: Elliptic
        """
        if private_key is None:
            self._priv = get_random_bits()
        else:
            self._priv = private_key
        if public_key is None:
            self._pub = elliptic.mulp(CURVE_P, P - B, P, (X, Y), self._priv)
        elif isinstance(public_key, basestring):
            self._pub = self._from_public_key(public_key)
        else:
            self._pub = public_key

    @classmethod
    def read_private_key(cls, pem_file):
        """
        Read the private key from a pem file. The public key is derived from the private

        :param pem_file: pem file path
        :type pem_file: str
        :return Elliptic instance
        :rtype: Elliptic
        """
        f = None
        try:
            f = open(pem_file)
            pem = f.read()
        finally:
            if f is not None:
                f.close()
        pem = pem[pem.index('-----BEGIN EC PRIVATE KEY-----'):]
        pem = ''.join([x.strip() for x in pem.split('\n') if x and not x.startswith('-----')])
        data = decoder.decode(base64.b64decode(pem), asn1Spec=ECPrivateKey())[0]
        if not data['version'] == 1:
            raise Exception('Invalid version')
        if str(data['parameters']) != CURVE_OID:
            raise Exception('Invalid curve. Only nistp256 is supported')
        priv = from_bytes(str(data['privateKey']))
        return Elliptic(private_key=priv)

    @classmethod
    def read_public_key(cls, pub_file):
        """
        Read the public key from a SSH public key format.
        Only ecdsa-sha-nistp256 is supported

        E.g.
        ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFgTMCBvifrdXPuS8L9tGoqBUDiIvN5rHZtXY3b0nLoPOxhR1GiUsEFJJOfoRiDWouzjP1O3FUHIefnnbdeSf20= andreax@test

        :param pub_file: file path
        :type pem_file: str
        :return Elliptic instance
        :rtype: Elliptic
        """
        f = None
        try:
            f = open(pub_file)
            pub = f.read().split()
        finally:
            if f is not None:
                f.close()
        if len(pub) < 2:
            raise Exception('Error parsing public key')
        if pub[0] != CURVE_ALG:
            raise Exception('Invalid curve. Only %s is supported' % CURVE_ALG)
        return Elliptic(public_key=pub[1])

    @classmethod
    def _from_public_key(cls, public_key):
        key = base64.b64decode(public_key)
        parts = []
        while key:
            dlen = struct.unpack('>I', key[:4])[0]
            data, key = key[4:dlen+4], key[4+dlen:]
            parts.append(data)
        if len(parts) < 3:
            raise Exception('Error parsing public key')
        if parts[0] != CURVE_ALG:
            raise Exception('Invalid algorithm. Only %s is supported' % CURVE_ALG)
        if parts[1] != CURVE_NAME:
            raise Exception('Invalid curve. Only %s is supported' % CURVE_NAME)
        # key starts with \x04
        if parts[2][0] != '\x04':
            raise Exception('Error parsing public key')
        key = parts[2][1:]
        if len(key) != BITS/8*2:
            raise Exception('Error parsing public key')
        r = from_bytes(key[:BITS/8])
        s = from_bytes(key[BITS/8:])
        return (r, s)

    @property
    def public_key(self):
        """
        Public key as a string, e.g.:
        AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBFgTMCBvifrdXPuS8L9tGoqBUDiIvN5rHZtXY3b0nLoPOxhR1GiUsEFJJOfoRiDWouzjP1O3FUHIefnnbdeSf20=

        :return: public key as a string
        :rtype: str
        """
        pub = ''
        a = CURVE_ALG
        pub += struct.pack('>I', len(a)) + a
        b = CURVE_NAME
        pub += struct.pack('>I', len(b)) + b
        k = '\x04' + to_bytes(self._pub[0], BITS/8) + to_bytes(self._pub[1], BITS/8)
        pub += struct.pack('>I', len(k)) + k
        pub = base64.b64encode(pub)
        return pub

    @property
    def private_key(self):
        """
        Private key in PEM format, e.g.:
        -----BEGIN EC PRIVATE KEY-----
        MHcCAQEEIKTfK6Ykm0jFwo7I6bRWpU7FjiPueTJGFv5bVsyeY5MKoAoGCCqGSM49
        AwEHoUQDQgAEWBMwIG+J+t1c+5Lwv20aioFQOIi83msdm1djdvScug87GFHUaJSw
        QUkk5+hGINai7OM/U7cVQch5+edt15J/bQ==
        -----END EC PRIVATE KEY-----

        :return: private key as a string in PEM format
        :rtype: str
        """
        key = ECPrivateKey()
        key['version']    = 1
        key['privateKey'] = to_bytes(self._priv)
        key['parameters'] = CURVE_OID
        key['publicKey']  = bytes_to_bits(chr(0x04) + to_bytes(self._pub[0]) + to_bytes(self._pub[1]))
        pem = base64.b64encode(encoder.encode(key))
        pem = '-----BEGIN EC PRIVATE KEY-----\n' + ('\n'.join(textwrap.wrap(pem, 64))) + '\n-----END EC PRIVATE KEY-----'
        return pem

    def sign(self, data, fmt=FORMAT_HEX):
        """
        Sign data usign the private key

        :param data: data
        :type data: str
        :param fmt: result format - hex (default), base64, raw
        :type fmt: str
        :return: the calculated hash
        :rtype: str
        """
        if not self._priv:
            raise AttributeError('Private key needed for signing data')
        h = from_bytes(hashlib.new(HASH_FUNCTION, data).digest())
        r = s = 0
        while r == 0 or s == 0:
            k = get_random_bits()
            kinv = elliptic.inv(k, N)
            kg = elliptic.mulp(CURVE_P, P - B, P, (X, Y), k)
            r = kg[0] % N
            if r != 0:
                s = (kinv * (h + r * self._priv)) % N
        return format_digest(to_bytes(r) + to_bytes(s), fmt=fmt)

    def verify(self, data, signature):
        """
        Verify the signature using the public key

        :param data: data
        :type data: str
        :param signature: signature in hex, base64 or raw format
        :type signature: str
        :return: True if the signature is verified
        :rtype: bool
        """
        # Guess the signature format (hex, base64, raw)
        try:
            # try hex
            tmp = signature.decode('hex')
            if len(tmp) == BITS/8*2:
                signature = tmp
        except:
            try:
                # try base64
                padding = '=' * (4 - len(signature) % 4)
                tmp = base64.urlsafe_b64decode(signature + padding)
                if len(tmp) == BITS/8*2:
                    signature = tmp
            except:
                pass
        if len(signature) != BITS/8*2:
            return False
        r = from_bytes(signature[:BITS/8])
        s = from_bytes(signature[BITS/8:])
        h = from_bytes(hashlib.new(HASH_FUNCTION, data).digest())
        if 0 < r < N and 0 < s < N:
            w = elliptic.inv(s, N)
            u1 = (h * w) % N
            u2 = (r * w) % N
            x, y = elliptic.muladdp(CURVE_P, P - B, P, (X, Y), u1, self._pub, u2)
            return r % N == x % N
        return False

if __name__ == '__main__':
    k = Elliptic()
    # k = Elliptic.read_private_key('id_ecdsa')
    # k2 = Elliptic.read_public_key('id_ecdsa.pub')
    print k.public_key
    print k.private_key
    k2 = Elliptic(k._pub, k._priv)
    k3 = Elliptic(k._pub)
    v_raw = k2.sign('random', 'raw')
    v_hex = k2.sign('random', 'hex')
    v_b64 = k2.sign('random', 'base64')
    v_raw2 = k2.sign('endian', 'raw')
    print k3.verify('random', v_raw)
    print k3.verify('random', v_hex)
    print k3.verify('random', v_b64)
    print k3.verify('random', v_raw2)

