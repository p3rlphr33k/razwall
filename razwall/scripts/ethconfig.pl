#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use File::Glob ':glob';
use JSON;

my $IP_BIN      = find_tool('ip');
my $LSPCI_BIN   = find_tool('lspci');
my $ETHTOOL_BIN = find_tool('ethtool');
my $NAMEIF_BIN  = find_tool('nameif');

my @VALIDIF = qw(eth lan);
my @HIDDENIF;
my @INCLUDEIF;

sub find_tool {
    my ($tool) = @_;
    my @paths = qw(/sbin /bin /usr/sbin /usr/bin /razwall/scripts);
    for my $path (@paths) {
        my $toolpath = "$path/$tool";
        return $toolpath if -x $toolpath;
    }
    die "ERROR: This script requires the '$tool' executable. Aborting.\n";
}

sub valid_interface {
    my ($iface) = @_;
    return 0 if grep { $_ eq $iface } @HIDDENIF;
    return 1 if grep { $_ eq $iface } @INCLUDEIF;
    return 1 if grep { $iface =~ /^\Q$_\E/ } @VALIDIF;
    return 0;
}

sub get_cards {
    open my $cmd, '-|', "$IP_BIN -o link show" or die "Unable to run ip command: $!";
    my %ifaces;
    while (<$cmd>) {
        my ($iface) = (split /:/)[1] =~ s/^\s+|\s+$//gr;
        next unless valid_interface($iface);
        next if $iface =~ /\./;  # Skip VLAN interfaces
        my ($mac) = /link\/ether\s+([0-9a-f:]+)/i;
        $ifaces{$iface} = $mac if $mac;
    }
    close $cmd;
    return \%ifaces;
}

sub load_card_info {
    my ($ifaces) = @_;
    $ifaces //= get_cards();
    my @lspci = `$LSPCI_BIN`;
    my (%cardinfo, %tabuinterface);

    for my $iface (keys %$ifaces) {
        my @ethtool = `$ETHTOOL_BIN -i $iface 2>/dev/null`;
        my %ethinfo = map { split /:\s*/, $_, 2 } grep { /:/ } @ethtool;

        my $driver   = $ethinfo{'driver'} // 'n/a';
        my $version  = $ethinfo{'version'} // 'n/a';
        my $firmware = $ethinfo{'firmware-version'} // 'n/a';
        my $businfo  = $ethinfo{'bus-info'} // '';
        my $is_pci   = $businfo && $businfo !~ /^usb/;
        my $name     = $is_pci ? (grep { /$businfo/ } @lspci)[0] =~ s/.*$businfo.*:\s*//r : $driver;

        my $card = {
            name      => $name || 'Unknown Network Interface Card',
            driver    => $driver,
            version   => $version,
            firmware  => $firmware,
            mac       => $ifaces->{$iface},
            interface => $iface,
            isPci     => $is_pci,
            businfo   => $businfo || $iface,
        };
        $is_pci ? ($cardinfo{$businfo} = $card) : ($tabuinterface{$iface} = $card);
    }

    return (\%cardinfo, \%tabuinterface);
}

sub write_businfo_tab {
    my ($ifaces, $filename) = @_;
    open my $fh, '>', $filename or die "Unable to write to $filename: $!";
    print $fh "# Generated by ethconfig\n";
    for my $iface (sort keys %$ifaces) {
        my $info = $ifaces->{$iface};
        printf $fh "%s\t%s\t%s\n", $info->{interface}, $info->{businfo}, $info->{label} // '';
    }
    close $fh;
}

sub update_businfo_tab {
    my ($filename) = @_;
    my ($ifaces, $tabuinterface) = load_card_info();
    my $businfotab = get_businfo_tab($filename);

    for my $iface (keys %$tabuinterface) {
        next if exists $businfotab->{$iface};
        $businfotab->{$iface} = {
            businfo   => $tabuinterface->{$iface}{businfo},
            interface => $iface,
            label     => '',
        };
    }

    for my $businfo (keys %$ifaces) {
        next if grep { $_->{businfo} eq $businfo } values %$businfotab;
        my $card = $ifaces->{$businfo};
        my $iface = $card->{interface};
        $businfotab->{$iface} = {
            businfo   => $businfo,
            interface => $iface,
            label     => '',
        };
    }

    write_businfo_tab($businfotab, $filename);
}

sub get_businfo_tab {
    my ($filename) = @_;
    open my $fh, '<', $filename or return {};
    my %tab;
    while (<$fh>) {
        next if /^#/ || /^\s*$/;
        my ($iface, $businfo, $label) = split;
        $tab{$iface} = { businfo => $businfo, interface => $iface, label => $label // '' };
    }
    close $fh;
    return \%tab;
}

sub main {
    my $config    = '/etc/businfotab';
    my $hide      = '/etc/ethconfig_hide*';
    my $include   = '/etc/ethconfig_include*';
    my $show      = 0;
    my $update    = 0;

    GetOptions(
        'config|c=s' => \$config,
        'hide|H=s'   => \$hide,
        'include|I=s'=> \$include,
        'show|s'     => \$show,
        'update|u'   => \$update,
    ) or die "Invalid options passed.\n";

    @HIDDENIF  = read_exclude_files($hide);
    @INCLUDEIF = read_exclude_files($include);

    update_businfo_tab($config) if $update;
    show_cards($config) if $show;
}

sub show_cards {
    my ($config) = @_;
    my $businfo = get_businfo_tab($config);
    my ($ifaces, $tabuifaces) = load_card_info();

    for my $iface (keys %$businfo) {
        my $info = $businfo->{$iface};
        print "Device: $iface\n";
        print "  Businfo:  $info->{businfo}\n";
        print "  Model:    $info->{name}\n";
        print "  Driver:   $info->{driver} $info->{version}\n";
    }
}

sub read_exclude_files {
    my ($files) = @_;
    my @lines;
    for my $file (bsd_glob($files)) {
        open my $fh, '<', $file or next;
        push @lines, grep { $_ !~ /^#/ && $_ !~ /^\s*$/ } <$fh>;
        close $fh;
    }
    return @lines;
}

main();
